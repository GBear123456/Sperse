//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateMemberSignUp(body: SignUpMemberRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ValidateMemberSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMemberSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMemberSignUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateMemberSignUp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    signUpMember(body: SignUpMemberRequest | undefined): Observable<SignUpMemberResponse> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SignUpMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUpMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUpMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignUpMemberResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignUpMemberResponse>;
        }));
    }

    protected processSignUpMember(response: HttpResponseBase): Observable<SignUpMemberResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignUpMemberResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignUpMemberResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    signUp(body: SignUpRequest | undefined): Observable<SignUpMemberResponse> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignUpMemberResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignUpMemberResponse>;
        }));
    }

    protected processSignUp(response: HttpResponseBase): Observable<SignUpMemberResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignUpMemberResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignUpMemberResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<SendPasswordResetCodeOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendPasswordResetCodeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendPasswordResetCodeOutput>;
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<SendPasswordResetCodeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendPasswordResetCodeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendPasswordResetCodeOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getResetPasswordCodeInfo(body: GetResetPasswordCodeInfoInput | undefined): Observable<GetResetPasswordCodeInfoOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/GetResetPasswordCodeInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResetPasswordCodeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResetPasswordCodeInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetResetPasswordCodeInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetResetPasswordCodeInfoOutput>;
        }));
    }

    protected processGetResetPasswordCodeInfo(response: HttpResponseBase): Observable<GetResetPasswordCodeInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetResetPasswordCodeInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetResetPasswordCodeInfoOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordOutput>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    impersonateAsAdmin(tenantId: number | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ImpersonateAsAdmin?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateAsAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateAsAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonateAsAdmin(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchToLinkedAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchToLinkedAccountOutput>;
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAutoLoginWithReset(body: SendAutoLoginLinkInput | undefined): Observable<SendAutoLoginLinkOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendAutoLoginWithReset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAutoLoginWithReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAutoLoginWithReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendAutoLoginLinkOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendAutoLoginLinkOutput>;
        }));
    }

    protected processSendAutoLoginWithReset(response: HttpResponseBase): Observable<SendAutoLoginLinkOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendAutoLoginLinkOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendAutoLoginLinkOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAutoLoginLink(body: SendAutoLoginLinkInput | undefined): Observable<SendAutoLoginLinkOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendAutoLoginLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAutoLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAutoLoginLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendAutoLoginLinkOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendAutoLoginLinkOutput>;
        }));
    }

    protected processSendAutoLoginLink(response: HttpResponseBase): Observable<SendAutoLoginLinkOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendAutoLoginLinkOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendAutoLoginLinkOutput>(null as any);
    }

    /**
     * @return Success
     */
    cancelUserAccount(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/CancelUserAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelUserAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelUserAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelUserAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateActivityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param assignedTo (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @return Success
     */
    getAll(assignedTo: number | undefined, dateFrom: moment.Moment | undefined, dateTo: moment.Moment | undefined): Observable<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/GetAll?";
        if (assignedTo === null)
            throw new Error("The parameter 'assignedTo' cannot be null.");
        else if (assignedTo !== undefined)
            url_ += "AssignedTo=" + encodeURIComponent("" + assignedTo) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActivityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateActivityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    move(body: MoveActivityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transition(body: TransitionActivityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Transition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignUser(body: AssignActivityUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/AssignUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRelatedAssignableUsers(entityId: number): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/GetRelatedAssignableUsers?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAssignableUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoDto[]>;
        }));
    }

    protected processGetRelatedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(null as any);
    }
}

@Injectable()
export class AffiliateLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<AffiliateLinkInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/AffiliateLink/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AffiliateLinkInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AffiliateLinkInfo[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AffiliateLinkInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AffiliateLinkInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AffiliateLinkInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAffiliateLinkInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/AffiliateLink/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAffiliateLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/AffiliateLink/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setAffiliateLinkImage(body: SetAffiliateLinkImageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/AffiliateLink/SetAffiliateLinkImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAffiliateLinkImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAffiliateLinkImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAffiliateLinkImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/AffiliateLink/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ApiKeyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAll(userId: number | undefined): Observable<ApiKeyInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/GetAll?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKeyInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKeyInfo[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApiKeyInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApiKeyInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiKeyInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generate(body: GenerateApiKeyInput | undefined): Observable<ApiKeyInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKeyInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKeyInfo>;
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<ApiKeyInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKeyInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiKeyInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateApiKeyInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerApplicant(body: RegisterApplicantRequest | undefined): Observable<RegisterApplicantResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/RegisterApplicant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterApplicant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterApplicant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterApplicantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterApplicantResponse>;
        }));
    }

    protected processRegisterApplicant(response: HttpResponseBase): Observable<RegisterApplicantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterApplicantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterApplicantResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerByApplicant(body: RegisterByApplicantRequest | undefined): Observable<RegisterByApplicantResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/RegisterByApplicant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterByApplicant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterByApplicant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterByApplicantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterByApplicantResponse>;
        }));
    }

    protected processRegisterByApplicant(response: HttpResponseBase): Observable<RegisterByApplicantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterByApplicantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterByApplicantResponse>(null as any);
    }

    /**
     * @return Success
     */
    getInitialMemberApplication(applicantUserId: number, applicationId: string): Observable<OfferApplicationDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/GetInitialMemberApplication?";
        if (applicantUserId === undefined || applicantUserId === null)
            throw new Error("The parameter 'applicantUserId' must be defined and cannot be null.");
        else
            url_ += "applicantUserId=" + encodeURIComponent("" + applicantUserId) + "&";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialMemberApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialMemberApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferApplicationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferApplicationDto>;
        }));
    }

    protected processGetInitialMemberApplication(response: HttpResponseBase): Observable<OfferApplicationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferApplicationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferApplicationDto>(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userId (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(filter: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userId: number | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogs?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAuditLogListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAuditLogListDto>;
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userId (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(filter: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userId: number | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDto[]>;
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(null as any);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | undefined, entityId: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPropertyChangeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPropertyChangeDto[]>;
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(null as any);
    }
}

@Injectable()
export class BankAccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getBankAccounts(instanceType: InstanceType | undefined, instanceId: number | undefined, currency: string): Observable<SyncAccountBankDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetBankAccounts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SyncAccountBankDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SyncAccountBankDto[]>;
        }));
    }

    protected processGetBankAccounts(response: HttpResponseBase): Observable<SyncAccountBankDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SyncAccountBankDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAccountBankDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    recalculateAllBankAccountDailyStats(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/RecalculateAllBankAccountDailyStats?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculateAllBankAccountDailyStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculateAllBankAccountDailyStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRecalculateAllBankAccountDailyStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param forecastModelId (optional) 
     * @param accounts (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType | undefined, instanceId: number | undefined, currency: string, forecastModelId: number | undefined, accounts: number[] | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, groupBy: GroupByPeriod): Observable<BankAccountDailyStatDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetStats?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        if (forecastModelId === null)
            throw new Error("The parameter 'forecastModelId' cannot be null.");
        else if (forecastModelId !== undefined)
            url_ += "ForecastModelId=" + encodeURIComponent("" + forecastModelId) + "&";
        if (accounts === null)
            throw new Error("The parameter 'accounts' cannot be null.");
        else if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "Accounts=" + encodeURIComponent("" + item) + "&"; });
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (groupBy === undefined || groupBy === null)
            throw new Error("The parameter 'groupBy' must be defined and cannot be null.");
        else
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountDailyStatDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountDailyStatDto[]>;
        }));
    }

    protected processGetStats(response: HttpResponseBase): Observable<BankAccountDailyStatDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountDailyStatDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountDailyStatDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    discardDiscrepancies(instanceType: InstanceType | undefined, instanceId: number | undefined, body: DiscardDiscrepanciesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/DiscardDiscrepancies?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscardDiscrepancies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscardDiscrepancies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDiscardDiscrepancies(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    discardDiscrepancy(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/DiscardDiscrepancy?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscardDiscrepancy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscardDiscrepancy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDiscardDiscrepancy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateBankAccount(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateBankAccountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/UpdateBankAccount?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBankAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BANKCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getBankCode(body: GetBankCodeInput | undefined): Observable<GetBankCodeOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetBankCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBankCodeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBankCodeOutput>;
        }));
    }

    protected processGetBankCode(response: HttpResponseBase): Observable<GetBankCodeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBankCodeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankCodeOutput>(null as any);
    }

    /**
     * @return Success
     */
    getAdvisorInfo(): Observable<GetAdvisorInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetAdvisorInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvisorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvisorInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdvisorInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdvisorInfoOutput>;
        }));
    }

    protected processGetAdvisorInfo(response: HttpResponseBase): Observable<GetAdvisorInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdvisorInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAdvisorInfoOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLead(body: CreateOrEditLeadInput | undefined): Observable<CreateLeadOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/CreateOrUpdateLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateLeadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateLeadOutput>;
        }));
    }

    protected processCreateOrUpdateLead(response: HttpResponseBase): Observable<CreateLeadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateLeadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLeadOutput>(null as any);
    }

    /**
     * @param aiGeneratedOnly (optional) 
     * @return Success
     */
    getSystemTotals(aiGeneratedOnly: boolean | undefined): Observable<GetSystemTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetSystemTotals?";
        if (aiGeneratedOnly === null)
            throw new Error("The parameter 'aiGeneratedOnly' cannot be null.");
        else if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSystemTotalsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSystemTotalsOutput>;
        }));
    }

    protected processGetSystemTotals(response: HttpResponseBase): Observable<GetSystemTotalsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSystemTotalsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSystemTotalsOutput>(null as any);
    }

    /**
     * @param aiGeneratedOnly (optional) 
     * @return Success
     */
    getUserTotals(aiGeneratedOnly: boolean | undefined): Observable<GetUserTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetUserTotals?";
        if (aiGeneratedOnly === null)
            throw new Error("The parameter 'aiGeneratedOnly' cannot be null.");
        else if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserTotalsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserTotalsOutput>;
        }));
    }

    protected processGetUserTotals(response: HttpResponseBase): Observable<GetUserTotalsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserTotalsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserTotalsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getAiSystemTotals(): Observable<GetSystemTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetAiSystemTotals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAiSystemTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAiSystemTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSystemTotalsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSystemTotalsOutput>;
        }));
    }

    protected processGetAiSystemTotals(response: HttpResponseBase): Observable<GetSystemTotalsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSystemTotalsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSystemTotalsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getAiUserTotals(): Observable<GetUserTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetAiUserTotals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAiUserTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAiUserTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserTotalsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserTotalsOutput>;
        }));
    }

    protected processGetAiUserTotals(response: HttpResponseBase): Observable<GetUserTotalsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserTotalsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserTotalsOutput>(null as any);
    }

    /**
     * @param aiGeneratedOnly (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getLeaderBoard(aiGeneratedOnly: boolean | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetLeaderBoardOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetLeaderBoard?";
        if (aiGeneratedOnly === null)
            throw new Error("The parameter 'aiGeneratedOnly' cannot be null.");
        else if (aiGeneratedOnly !== undefined)
            url_ += "AiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaderBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaderBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLeaderBoardOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLeaderBoardOutput>;
        }));
    }

    protected processGetLeaderBoard(response: HttpResponseBase): Observable<GetLeaderBoardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLeaderBoardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaderBoardOutput>(null as any);
    }

    /**
     * @param aiGeneratedOnly (optional) 
     * @return Success
     */
    getUserRank(aiGeneratedOnly: boolean | undefined): Observable<GetUserRankOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetUserRank?";
        if (aiGeneratedOnly === null)
            throw new Error("The parameter 'aiGeneratedOnly' cannot be null.");
        else if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRank(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserRankOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserRankOutput>;
        }));
    }

    protected processGetUserRank(response: HttpResponseBase): Observable<GetUserRankOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserRankOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserRankOutput>(null as any);
    }

    /**
     * @param aiGeneratedOnly (optional) 
     * @return Success
     */
    getRecentlyAddedContacts(aiGeneratedOnly: boolean | undefined): Observable<RecentlyAddedContact[]> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetRecentlyAddedContacts?";
        if (aiGeneratedOnly === null)
            throw new Error("The parameter 'aiGeneratedOnly' cannot be null.");
        else if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyAddedContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyAddedContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecentlyAddedContact[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecentlyAddedContact[]>;
        }));
    }

    protected processGetRecentlyAddedContacts(response: HttpResponseBase): Observable<RecentlyAddedContact[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecentlyAddedContact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecentlyAddedContact[]>(null as any);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    getBankCodeHistory(personId: number | undefined): Observable<BankCodeHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetBankCodeHistory?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankCodeHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankCodeHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankCodeHistoryInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankCodeHistoryInfo[]>;
        }));
    }

    protected processGetBankCodeHistory(response: HttpResponseBase): Observable<BankCodeHistoryInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankCodeHistoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankCodeHistoryInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBankCodeUserSettings(body: UpdateBankCodeUserSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/UpdateBankCodeUserSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankCodeUserSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankCodeUserSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBankCodeUserSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBankCodeUserSettings(): Observable<BANKCodeUserSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetBankCodeUserSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankCodeUserSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankCodeUserSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BANKCodeUserSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BANKCodeUserSettings>;
        }));
    }

    protected processGetBankCodeUserSettings(response: HttpResponseBase): Observable<BANKCodeUserSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BANKCodeUserSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BANKCodeUserSettings>(null as any);
    }
}

@Injectable()
export class BudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    import(instanceType: InstanceType | undefined, instanceId: number | undefined, body: BudgetImportInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Budget/Import?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    generateReport(instanceType: InstanceType | undefined, instanceId: number | undefined, body: GenerateBudgetReportInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Budget/GenerateReport?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BusinessEntityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getBusinessEntities(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<BusinessEntityDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetBusinessEntities?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessEntityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessEntityDto[]>;
        }));
    }

    protected processGetBusinessEntities(response: HttpResponseBase): Observable<BusinessEntityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessEntityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getTypes(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<BusinessEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetTypes?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessEntityTypeDto[]>;
        }));
    }

    protected processGetTypes(response: HttpResponseBase): Observable<BusinessEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityTypeDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    get(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number | undefined): Observable<BusinessEntityInfoDto> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/Get?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessEntityInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessEntityInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BusinessEntityInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessEntityInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityInfoDto>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createBusinessEntity(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateBusinessEntityDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/CreateBusinessEntity?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBusinessEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBusinessEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateBusinessEntity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateBusinessEntity(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateBusinessEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/UpdateBusinessEntity?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBusinessEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBusinessEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBusinessEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param businessEntityId (optional) 
     * @return Success
     */
    getBankAccounts(instanceType: InstanceType | undefined, instanceId: number | undefined, businessEntityId: number | undefined): Observable<BusinessEntityBankAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetBankAccounts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (businessEntityId === null)
            throw new Error("The parameter 'businessEntityId' cannot be null.");
        else if (businessEntityId !== undefined)
            url_ += "businessEntityId=" + encodeURIComponent("" + businessEntityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessEntityBankAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessEntityBankAccountDto[]>;
        }));
    }

    protected processGetBankAccounts(response: HttpResponseBase): Observable<BusinessEntityBankAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessEntityBankAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityBankAccountDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateBankAccounts(instanceType: InstanceType | undefined, instanceId: number | undefined, body: BusinessEntityUpdateBankAccountsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/UpdateBankAccounts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBankAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfCacheDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfCacheDto>;
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cacheStrings(body: { [key: string]: string[]; } | undefined): Observable<{ [key: string]: moment.Moment; }> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/CacheStrings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCacheStrings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCacheStrings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: moment.Moment; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: moment.Moment; }>;
        }));
    }

    protected processCacheStrings(response: HttpResponseBase): Observable<{ [key: string]: moment.Moment; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? moment(resultData200[key].toString()) : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: moment.Moment; }>(null as any);
    }
}

@Injectable()
export class CashflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType | undefined, instanceId: number | undefined, body: StatsFilter | undefined): Observable<CashFlowStatsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStats?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashFlowStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashFlowStatsDto>;
        }));
    }

    protected processGetStats(response: HttpResponseBase): Observable<CashFlowStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CashFlowStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowStatsDto>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getCashFlowInitialData(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<CashFlowInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowInitialData?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCashFlowInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashFlowInitialData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashFlowInitialData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashFlowInitialData>;
        }));
    }

    protected processGetCashFlowInitialData(response: HttpResponseBase): Observable<CashFlowInitialData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CashFlowInitialData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowInitialData>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getStatsDetails(instanceType: InstanceType | undefined, instanceId: number | undefined, body: StatsDetailFilter | undefined): Observable<CashFlowStatsDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStatsDetails?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatsDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashFlowStatsDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashFlowStatsDetailDto[]>;
        }));
    }

    protected processGetStatsDetails(response: HttpResponseBase): Observable<CashFlowStatsDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CashFlowStatsDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowStatsDetailDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getCashFlowGridSettings(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<CashFlowGridSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowGridSettings?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCashFlowGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashFlowGridSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashFlowGridSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashFlowGridSettingsDto>;
        }));
    }

    protected processGetCashFlowGridSettings(response: HttpResponseBase): Observable<CashFlowGridSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CashFlowGridSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowGridSettingsDto>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveCashFlowGridSettings(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CashFlowGridSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/SaveCashFlowGridSettings?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCashFlowGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCashFlowGridSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCashFlowGridSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CashFlowForecastServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getModels(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<ForecastModelDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetModels?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForecastModelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForecastModelDto[]>;
        }));
    }

    protected processGetModels(response: HttpResponseBase): Observable<ForecastModelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ForecastModelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastModelDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addForecast(instanceType: InstanceType | undefined, instanceId: number | undefined, body: AddForecastInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/AddForecast?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddForecast(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    importForecasts(instanceType: InstanceType | undefined, instanceId: number | undefined, body: ImportForecastInput[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/ImportForecasts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createForecasts(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateForecastsInput | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecasts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processCreateForecasts(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateForecast(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateForecastInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecast?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateForecasts(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateForecastsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecasts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteForecast(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecast?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    deleteForecasts(instanceType: InstanceType | undefined, instanceId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecasts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createForecastSchedule(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateForecastScheduleDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastSchedule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecastSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateForecastSchedule(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateForecastSchedule(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateForecastScheduleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecastSchedule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecastSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateForecastSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    deleteForecastSchedule(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastSchedule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecastSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteForecastSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getForecastSchedule(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number | undefined): Observable<ForecastScheduleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForecastScheduleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForecastScheduleDto>;
        }));
    }

    protected processGetForecastSchedule(response: HttpResponseBase): Observable<ForecastScheduleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForecastScheduleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastScheduleDto>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getForecastSchedules(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<ForecastScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedules?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastSchedules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastSchedules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForecastScheduleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForecastScheduleDto[]>;
        }));
    }

    protected processGetForecastSchedules(response: HttpResponseBase): Observable<ForecastScheduleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ForecastScheduleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastScheduleDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createForecastModel(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateForecastModelInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastModel?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecastModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateForecastModel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    renameForecastModel(instanceType: InstanceType | undefined, instanceId: number | undefined, body: RenameForecastModelInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/RenameForecastModel?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameForecastModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenameForecastModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    deleteForecastModel(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastModel?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecastModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteForecastModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CategoryTreeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param includeNonCashflowNodes (optional) 
     * @return Success
     */
    get(instanceType: InstanceType | undefined, instanceId: number | undefined, includeNonCashflowNodes: boolean | undefined): Observable<GetCategoryTreeOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Get?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (includeNonCashflowNodes === null)
            throw new Error("The parameter 'includeNonCashflowNodes' cannot be null.");
        else if (includeNonCashflowNodes !== undefined)
            url_ += "includeNonCashflowNodes=" + encodeURIComponent("" + includeNonCashflowNodes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCategoryTreeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCategoryTreeOutput>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetCategoryTreeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCategoryTreeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCategoryTreeOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getReportTemplateDefinition(instanceType: InstanceType | undefined, instanceId: number | undefined, reportTemplate: ReportTemplate): Observable<GetReportTemplateDefinitionOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/GetReportTemplateDefinition?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (reportTemplate === undefined || reportTemplate === null)
            throw new Error("The parameter 'reportTemplate' must be defined and cannot be null.");
        else
            url_ += "reportTemplate=" + encodeURIComponent("" + reportTemplate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplateDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplateDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetReportTemplateDefinitionOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetReportTemplateDefinitionOutput>;
        }));
    }

    protected processGetReportTemplateDefinition(response: HttpResponseBase): Observable<GetReportTemplateDefinitionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportTemplateDefinitionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportTemplateDefinitionOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createCategory(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateCategoryInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/CreateCategory?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateCategory(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateCategory?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateCategoryStatus(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateCategoryStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateCategoryStatus?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCategoryStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param moveToCategoryId (optional) 
     * @param deleteAllReferences (optional) 
     * @return Success
     */
    deleteCategory(instanceType: InstanceType | undefined, instanceId: number | undefined, moveToCategoryId: number | undefined, deleteAllReferences: boolean | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/DeleteCategory?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (moveToCategoryId === null)
            throw new Error("The parameter 'moveToCategoryId' cannot be null.");
        else if (moveToCategoryId !== undefined)
            url_ += "MoveToCategoryId=" + encodeURIComponent("" + moveToCategoryId) + "&";
        if (deleteAllReferences === null)
            throw new Error("The parameter 'deleteAllReferences' cannot be null.");
        else if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createAccountingType(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateAccountingTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/CreateAccountingType?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountingType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateAccountingType(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateAccountingTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateAccountingType?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountingType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param moveToAccountingTypeId (optional) 
     * @param deleteAllReferences (optional) 
     * @return Success
     */
    deleteAccountingType(instanceType: InstanceType | undefined, instanceId: number | undefined, moveToAccountingTypeId: number | undefined, deleteAllReferences: boolean | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/DeleteAccountingType?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (moveToAccountingTypeId === null)
            throw new Error("The parameter 'moveToAccountingTypeId' cannot be null.");
        else if (moveToAccountingTypeId !== undefined)
            url_ += "MoveToAccountingTypeId=" + encodeURIComponent("" + moveToAccountingTypeId) + "&";
        if (deleteAllReferences === null)
            throw new Error("The parameter 'deleteAllReferences' cannot be null.");
        else if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountingType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param isOverride (optional) 
     * @param body (optional) 
     * @return Success
     */
    sync(instanceType: InstanceType | undefined, instanceId: number | undefined, isOverride: boolean | undefined, body: SyncDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Sync?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (isOverride === null)
            throw new Error("The parameter 'isOverride' cannot be null.");
        else if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param isOverride (optional) 
     * @param body (optional) 
     * @return Success
     */
    import(instanceType: InstanceType | undefined, instanceId: number | undefined, isOverride: boolean | undefined, body: AccountingCategoryDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Import?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (isOverride === null)
            throw new Error("The parameter 'isOverride' cannot be null.");
        else if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | undefined, userId: number | undefined, minMessageId: number | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatMessages?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId === null)
            throw new Error("The parameter 'minMessageId' cannot be null.");
        else if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfChatMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfChatMessageDto>;
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClassificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getRules(instanceType: InstanceType | undefined, instanceId: number | undefined, input: GetRulesInput | undefined): Observable<RuleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRules?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RuleDto[]>;
        }));
    }

    protected processGetRules(response: HttpResponseBase): Observable<RuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RuleDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createRule(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateRuleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/CreateRule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getRuleForEdit(instanceType: InstanceType | undefined, instanceId: number | undefined, id: number | undefined): Observable<EditRuleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRuleForEdit?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRuleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRuleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditRuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditRuleDto>;
        }));
    }

    protected processGetRuleForEdit(response: HttpResponseBase): Observable<EditRuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditRuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditRuleDto>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    editRule(instanceType: InstanceType | undefined, instanceId: number | undefined, body: EditRuleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/EditRule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    moveRule(instanceType: InstanceType | undefined, instanceId: number | undefined, body: MoveRuleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/MoveRule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param sourceTransactionList (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteRule(instanceType: InstanceType | undefined, instanceId: number | undefined, sourceTransactionList: number[] | undefined, applyOption: ApplyToTransactionsOption, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteRule?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (sourceTransactionList === null)
            throw new Error("The parameter 'sourceTransactionList' cannot be null.");
        else if (sourceTransactionList !== undefined)
            sourceTransactionList && sourceTransactionList.forEach(item => { url_ += "SourceTransactionList=" + encodeURIComponent("" + item) + "&"; });
        if (applyOption === undefined || applyOption === null)
            throw new Error("The parameter 'applyOption' must be defined and cannot be null.");
        else
            url_ += "ApplyOption=" + encodeURIComponent("" + applyOption) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addMapping(instanceType: InstanceType | undefined, instanceId: number | undefined, body: AddMappingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AddMapping?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    deleteMapping(instanceType: InstanceType | undefined, instanceId: number | undefined, name: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteMapping?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    reclassify(instanceType: InstanceType | undefined, instanceId: number | undefined, body: RecategorizeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reclassify?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReclassify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReclassify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReclassify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    resetToDefaults(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ResetToDefaults?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetToDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetToDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetToDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    reset(instanceType: InstanceType | undefined, instanceId: number | undefined, body: ResetClassificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reset?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateTransactionsCategory(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateTransactionsCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategory?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionsCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionsCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTransactionsCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateTransactionsCategoryWithFilter(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateTransactionsCategoryWithFilterInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategoryWithFilter?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionsCategoryWithFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionsCategoryWithFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTransactionsCategoryWithFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getTransactionCommonDetails(instanceType: InstanceType | undefined, instanceId: number | undefined, body: GetTransactionCommonDetailsInput | undefined): Observable<TransactionCommonDetailsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetTransactionCommonDetails?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionCommonDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionCommonDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionCommonDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionCommonDetailsDto>;
        }));
    }

    protected processGetTransactionCommonDetails(response: HttpResponseBase): Observable<TransactionCommonDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionCommonDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionCommonDetailsDto>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    autoClassify(instanceType: InstanceType | undefined, instanceId: number | undefined, body: AutoClassifyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AutoClassify?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoClassify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoClassify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAutoClassify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeCategoryForRules(instanceType: InstanceType | undefined, instanceId: number | undefined, body: ChangeCategoryForRulesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ChangeCategoryForRules?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCategoryForRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCategoryForRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeCategoryForRules(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getKeyAttributeValues(instanceType: InstanceType | undefined, instanceId: number | undefined, body: GetKeyAttributeValuesInput | undefined): Observable<AttributeValuesDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetKeyAttributeValues?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyAttributeValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyAttributeValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttributeValuesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttributeValuesDto[]>;
        }));
    }

    protected processGetKeyAttributeValues(response: HttpResponseBase): Observable<AttributeValuesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttributeValuesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttributeValuesDto[]>(null as any);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param threadId (optional) 
     * @return Success
     */
    getComments(instanceType: InstanceType | undefined, instanceId: number | undefined, threadId: number | undefined): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/GetComments?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (threadId === null)
            throw new Error("The parameter 'threadId' cannot be null.");
        else if (threadId !== undefined)
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processGetComments(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createComment(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateCommentInput | undefined): Observable<CreateCommentOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateComment?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCommentOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCommentOutput>;
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<CreateCommentOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCommentOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCommentOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateComment(instanceType: InstanceType | undefined, instanceId: number | undefined, body: UpdateCommentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/UpdateComment?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param commentId (optional) 
     * @return Success
     */
    deleteComment(instanceType: InstanceType | undefined, instanceId: number | undefined, commentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/DeleteComment?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (commentId === null)
            throw new Error("The parameter 'commentId' cannot be null.");
        else if (commentId !== undefined)
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createTransactionCommentThread(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateTransactionCommentThreadInput | undefined): Observable<CreateTransactionCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateTransactionCommentThread?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransactionCommentThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransactionCommentThread(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateTransactionCommentThreadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateTransactionCommentThreadOutput>;
        }));
    }

    protected processCreateTransactionCommentThread(response: HttpResponseBase): Observable<CreateTransactionCommentThreadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTransactionCommentThreadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTransactionCommentThreadOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createCashFlowCommentThread(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateCashFlowCommentThreadInput | undefined): Observable<CreateCashFlowCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateCashFlowCommentThread?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCashFlowCommentThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCashFlowCommentThread(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCashFlowCommentThreadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCashFlowCommentThreadOutput>;
        }));
    }

    protected processCreateCashFlowCommentThread(response: HttpResponseBase): Observable<CreateCashFlowCommentThreadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCashFlowCommentThreadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCashFlowCommentThreadOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    setResolved(instanceType: InstanceType | undefined, instanceId: number | undefined, body: SetResolvedInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/SetResolved?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetResolved(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetResolved(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetResolved(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CommissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPendingCommissionContacts(): Observable<PendingCommissionContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/GetPendingCommissionContacts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingCommissionContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingCommissionContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingCommissionContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingCommissionContactInfo[]>;
        }));
    }

    protected processGetPendingCommissionContacts(response: HttpResponseBase): Observable<PendingCommissionContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PendingCommissionContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingCommissionContactInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommissionableAmount(body: UpdateCommissionableAmountInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/UpdateCommissionableAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionableAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionableAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCommissionableAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommissionRate(body: UpdateCommissionRateInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/UpdateCommissionRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCommissionRate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommissionAffiliate(body: UpdateCommissionAffiliateInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/UpdateCommissionAffiliate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionAffiliate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionAffiliate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCommissionAffiliate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelCommissions(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/CancelCommissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelCommissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelCommissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelCommissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recordEarnings(body: RecordEarningsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/RecordEarnings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecordEarnings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecordEarnings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRecordEarnings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestWithdrawal(body: RequestWithdrawalInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/RequestWithdrawal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestWithdrawal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestWithdrawal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestWithdrawal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeWithdrawals(body: CompleteWithdrawalInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/CompleteWithdrawals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteWithdrawals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteWithdrawals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompleteWithdrawals(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveLedger(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/ApproveLedger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveLedger(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveLedger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelLedger(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/CancelLedger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLedger(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelLedger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(null as any);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDefaultEditionNameOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDefaultEditionNameOutput>;
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(null as any);
    }
}

@Injectable()
export class CommonUserInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCompany(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/CommonUserInfo/GetCompany";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCompany(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getContactInfo(contactId: number | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfo?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processGetContactInfo(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * @param affiliateCode (optional) 
     * @return Success
     */
    getAffiliateInfo(affiliateCode: string | undefined): Observable<GetAffiliateInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAffiliateInfo?";
        if (affiliateCode === null)
            throw new Error("The parameter 'affiliateCode' cannot be null.");
        else if (affiliateCode !== undefined)
            url_ += "affiliateCode=" + encodeURIComponent("" + affiliateCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAffiliateInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAffiliateInfoOutput>;
        }));
    }

    protected processGetAffiliateInfo(response: HttpResponseBase): Observable<GetAffiliateInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAffiliateInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAffiliateInfoOutput>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getContactLastModificationInfo(contactId: number | undefined): Observable<ContactLastModificationInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactLastModificationInfo?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLastModificationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLastModificationInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactLastModificationInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactLastModificationInfoDto>;
        }));
    }

    protected processGetContactLastModificationInfo(response: HttpResponseBase): Observable<ContactLastModificationInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactLastModificationInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactLastModificationInfoDto>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getContactDetails(contactId: number | undefined): Observable<ContactDetailsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactDetails?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDetailsDto>;
        }));
    }

    protected processGetContactDetails(response: HttpResponseBase): Observable<ContactDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDetailsDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getContactInfoForUser(userId: number | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfoForUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processGetContactInfoForUser(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getContactShortInfoForUser(userId: number | undefined): Observable<ContactShortInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactShortInfoForUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactShortInfoForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactShortInfoForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactShortInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactShortInfo>;
        }));
    }

    protected processGetContactShortInfoForUser(response: HttpResponseBase): Observable<ContactShortInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactShortInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactShortInfo>(null as any);
    }

    /**
     * @param contactLeadId (optional) 
     * @param targetContactLeadId (optional) 
     * @param leadContactGroupId (optional) 
     * @return Success
     */
    getContactInfoForMerge(contactId: number, contactLeadId: number | undefined, targetContactId: number, targetContactLeadId: number | undefined, leadContactGroupId: string | undefined): Observable<GetContactInfoForMergeOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfoForMerge?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactLeadId === null)
            throw new Error("The parameter 'contactLeadId' cannot be null.");
        else if (contactLeadId !== undefined)
            url_ += "ContactLeadId=" + encodeURIComponent("" + contactLeadId) + "&";
        if (targetContactId === undefined || targetContactId === null)
            throw new Error("The parameter 'targetContactId' must be defined and cannot be null.");
        else
            url_ += "TargetContactId=" + encodeURIComponent("" + targetContactId) + "&";
        if (targetContactLeadId === null)
            throw new Error("The parameter 'targetContactLeadId' cannot be null.");
        else if (targetContactLeadId !== undefined)
            url_ += "TargetContactLeadId=" + encodeURIComponent("" + targetContactLeadId) + "&";
        if (leadContactGroupId === null)
            throw new Error("The parameter 'leadContactGroupId' cannot be null.");
        else if (leadContactGroupId !== undefined)
            url_ += "LeadContactGroupId=" + encodeURIComponent("" + leadContactGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoForMerge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoForMerge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactInfoForMergeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactInfoForMergeOutput>;
        }));
    }

    protected processGetContactInfoForMerge(response: HttpResponseBase): Observable<GetContactInfoForMergeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactInfoForMergeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactInfoForMergeOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSourceContactInfo(contactId: number): Observable<GetSourceContactInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSourceContactInfo?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceContactInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSourceContactInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSourceContactInfoOutput>;
        }));
    }

    protected processGetSourceContactInfo(response: HttpResponseBase): Observable<GetSourceContactInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSourceContactInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSourceContactInfoOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateContact(body: CreateOrUpdateContactInput | undefined): Observable<CreateOrUpdateContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/CreateOrUpdateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrUpdateContactOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrUpdateContactOutput>;
        }));
    }

    protected processCreateOrUpdateContact(response: HttpResponseBase): Observable<CreateOrUpdateContactOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrUpdateContactOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateContactOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeContact(body: MergeContactInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/MergeContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMergeContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param forceDelete (optional) 
     * @param notifyUser (optional) 
     * @return Success
     */
    deleteContact(id: number | undefined, forceDelete: boolean | undefined, notifyUser: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/DeleteContact?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (forceDelete === null)
            throw new Error("The parameter 'forceDelete' cannot be null.");
        else if (forceDelete !== undefined)
            url_ += "ForceDelete=" + encodeURIComponent("" + forceDelete) + "&";
        if (notifyUser === null)
            throw new Error("The parameter 'notifyUser' cannot be null.");
        else if (notifyUser !== undefined)
            url_ += "NotifyUser=" + encodeURIComponent("" + notifyUser) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param namePrefix (optional) 
     * @param firstName (optional) 
     * @param middleName (optional) 
     * @param lastName (optional) 
     * @param nameSuffix (optional) 
     * @param companyName (optional) 
     * @param emailAddresses (optional) 
     * @param phoneNumbers (optional) 
     * @param streetAddress (optional) 
     * @param city (optional) 
     * @param stateId (optional) 
     * @param zip (optional) 
     * @param countryId (optional) 
     * @param groupId (optional) 
     * @return Success
     */
    getSimilarContacts(namePrefix: string | undefined, firstName: string | undefined, middleName: string | undefined, lastName: string | undefined, nameSuffix: string | undefined, companyName: string | undefined, emailAddresses: string[] | undefined, phoneNumbers: string[] | undefined, streetAddress: string | undefined, city: string | undefined, stateId: string | undefined, zip: string | undefined, countryId: string | undefined, groupId: string | undefined): Observable<SimilarContactOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSimilarContacts?";
        if (namePrefix === null)
            throw new Error("The parameter 'namePrefix' cannot be null.");
        else if (namePrefix !== undefined)
            url_ += "NamePrefix=" + encodeURIComponent("" + namePrefix) + "&";
        if (firstName === null)
            throw new Error("The parameter 'firstName' cannot be null.");
        else if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (middleName === null)
            throw new Error("The parameter 'middleName' cannot be null.");
        else if (middleName !== undefined)
            url_ += "MiddleName=" + encodeURIComponent("" + middleName) + "&";
        if (lastName === null)
            throw new Error("The parameter 'lastName' cannot be null.");
        else if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (nameSuffix === null)
            throw new Error("The parameter 'nameSuffix' cannot be null.");
        else if (nameSuffix !== undefined)
            url_ += "NameSuffix=" + encodeURIComponent("" + nameSuffix) + "&";
        if (companyName === null)
            throw new Error("The parameter 'companyName' cannot be null.");
        else if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (emailAddresses === null)
            throw new Error("The parameter 'emailAddresses' cannot be null.");
        else if (emailAddresses !== undefined)
            emailAddresses && emailAddresses.forEach(item => { url_ += "EmailAddresses=" + encodeURIComponent("" + item) + "&"; });
        if (phoneNumbers === null)
            throw new Error("The parameter 'phoneNumbers' cannot be null.");
        else if (phoneNumbers !== undefined)
            phoneNumbers && phoneNumbers.forEach(item => { url_ += "PhoneNumbers=" + encodeURIComponent("" + item) + "&"; });
        if (streetAddress === null)
            throw new Error("The parameter 'streetAddress' cannot be null.");
        else if (streetAddress !== undefined)
            url_ += "StreetAddress=" + encodeURIComponent("" + streetAddress) + "&";
        if (city === null)
            throw new Error("The parameter 'city' cannot be null.");
        else if (city !== undefined)
            url_ += "City=" + encodeURIComponent("" + city) + "&";
        if (stateId === null)
            throw new Error("The parameter 'stateId' cannot be null.");
        else if (stateId !== undefined)
            url_ += "StateId=" + encodeURIComponent("" + stateId) + "&";
        if (zip === null)
            throw new Error("The parameter 'zip' cannot be null.");
        else if (zip !== undefined)
            url_ += "Zip=" + encodeURIComponent("" + zip) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSimilarContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSimilarContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimilarContactOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimilarContactOutput[]>;
        }));
    }

    protected processGetSimilarContacts(response: HttpResponseBase): Observable<SimilarContactOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimilarContactOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimilarContactOutput[]>(null as any);
    }

    /**
     * @param searchPhrase (optional) 
     * @param leadId (optional) 
     * @param includeProspective (optional) 
     * @return Success
     */
    getSourceContacts(searchPhrase: string | undefined, leadId: number | undefined, includeProspective: boolean | undefined, topCount: number): Observable<SourceContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSourceContacts?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (leadId === null)
            throw new Error("The parameter 'leadId' cannot be null.");
        else if (leadId !== undefined)
            url_ += "LeadId=" + encodeURIComponent("" + leadId) + "&";
        if (includeProspective === null)
            throw new Error("The parameter 'includeProspective' cannot be null.");
        else if (includeProspective !== undefined)
            url_ += "IncludeProspective=" + encodeURIComponent("" + includeProspective) + "&";
        if (topCount === undefined || topCount === null)
            throw new Error("The parameter 'topCount' must be defined and cannot be null.");
        else
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SourceContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SourceContactInfo[]>;
        }));
    }

    protected processGetSourceContacts(response: HttpResponseBase): Observable<SourceContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SourceContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SourceContactInfo[]>(null as any);
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @param hasUserAccount (optional) 
     * @param exceptUserIds (optional) 
     * @param excludeSubContacts (optional) 
     * @param fullAccess (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | undefined, topCount: number | undefined, hasUserAccount: boolean | undefined, exceptUserIds: number[] | undefined, excludeSubContacts: boolean | undefined, fullAccess: boolean | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAllByPhrase?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (hasUserAccount === null)
            throw new Error("The parameter 'hasUserAccount' cannot be null.");
        else if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&";
        if (exceptUserIds === null)
            throw new Error("The parameter 'exceptUserIds' cannot be null.");
        else if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts === null)
            throw new Error("The parameter 'excludeSubContacts' cannot be null.");
        else if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&";
        if (fullAccess === null)
            throw new Error("The parameter 'fullAccess' cannot be null.");
        else if (fullAccess !== undefined)
            url_ += "FullAccess=" + encodeURIComponent("" + fullAccess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityContactInfo[]>;
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactStatus(body: UpdateContactStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateContactStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactStatuses(body: UpdateContactStatusesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateContactStatuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactStatuses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getContactGroups(): Observable<ContactGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactGroupDto[]>;
        }));
    }

    protected processGetContactGroups(response: HttpResponseBase): Observable<ContactGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGroupDto[]>(null as any);
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @return Success
     */
    getAllowedAssignableUsers(contactGroupId: string, searchPhrase: string | undefined, topCount: number | undefined): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAllowedAssignableUsers?";
        if (contactGroupId === undefined || contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' must be defined and cannot be null.");
        else
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedAssignableUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoDto[]>;
        }));
    }

    protected processGetAllowedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getRelatedAssignableUsers(entityId: number): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetRelatedAssignableUsers?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAssignableUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoDto[]>;
        }));
    }

    protected processGetRelatedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getAffiliateHistory(contactId: number | undefined): Observable<AffiliateInfoHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAffiliateHistory?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AffiliateInfoHistoryInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AffiliateInfoHistoryInfo[]>;
        }));
    }

    protected processGetAffiliateHistory(response: HttpResponseBase): Observable<AffiliateInfoHistoryInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AffiliateInfoHistoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AffiliateInfoHistoryInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignUser(body: AssignUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/AssignUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignUserForEach(body: AssignUserForEachInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/AssignUserForEach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUserForEach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUserForEach(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignUserForEach(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAffiliateCode(body: UpdateContactAffiliateCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAffiliateCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAffiliateRate(body: UpdateContactAffiliateRateInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAffiliateRate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAffiliateIsAdvisor(body: UpdateAffiliateIsAdvisorInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateIsAdvisor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateIsAdvisor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateIsAdvisor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAffiliateIsAdvisor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateXref(body: UpdateContactXrefInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateXref";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateXref(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateXref(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateXref(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomFields(body: UpdateContactCustomFieldsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateCustomFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCustomFields(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAffiliateContact(body: UpdateAffiliateContactInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAffiliateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendReferralPartnersEmail(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/SendReferralPartnersEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReferralPartnersEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReferralPartnersEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendReferralPartnersEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    isAccessible(contactId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/IsAccessible?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAccessible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAccessible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsAccessible(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class ContactAddressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactAddress(body: CreateContactAddressInput | undefined): Observable<CreateContactAddressOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/CreateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateContactAddressOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateContactAddressOutput>;
        }));
    }

    protected processCreateContactAddress(response: HttpResponseBase): Observable<CreateContactAddressOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateContactAddressOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactAddressOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactAddress(body: UpdateContactAddressInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/UpdateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteContactAddress(contactId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/DeleteContactAddress?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAddressUsageTypes(): Observable<ListResultDtoOfAddressUsageTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressUsageTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfAddressUsageTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfAddressUsageTypeDto>;
        }));
    }

    protected processGetAddressUsageTypes(response: HttpResponseBase): Observable<ListResultDtoOfAddressUsageTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfAddressUsageTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAddressUsageTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    getAddressOwnershipTypes(): Observable<ListResultDtoOfAddressOwnershipTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressOwnershipTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressOwnershipTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressOwnershipTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfAddressOwnershipTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfAddressOwnershipTypeDto>;
        }));
    }

    protected processGetAddressOwnershipTypes(response: HttpResponseBase): Observable<ListResultDtoOfAddressOwnershipTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfAddressOwnershipTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAddressOwnershipTypeDto>(null as any);
    }
}

@Injectable()
export class ContactCommunicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMessage(id: number, contactId: number): Observable<MessageDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetMessage?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDto>;
        }));
    }

    protected processGetMessage(response: HttpResponseBase): Observable<MessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageDto>(null as any);
    }

    /**
     * @param parentId (optional) 
     * @param userId (optional) 
     * @param filter (optional) 
     * @param deliveryType (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMessages(contactId: number, parentId: number | undefined, userId: number | undefined, filter: string | undefined, deliveryType: CommunicationMessageDeliveryType | undefined, status: CommunicationMessageSendingStatus | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMessageListDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetMessages?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (deliveryType === null)
            throw new Error("The parameter 'deliveryType' cannot be null.");
        else if (deliveryType !== undefined)
            url_ += "DeliveryType=" + encodeURIComponent("" + deliveryType) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMessageListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMessageListDto>;
        }));
    }

    protected processGetMessages(response: HttpResponseBase): Observable<PagedResultDtoOfMessageListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMessageListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMessageListDto>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @return Success
     */
    getEmailData(templateId: number | undefined, contactId: number): Observable<GetEmailDataOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetEmailData?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmailDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmailDataOutput>;
        }));
    }

    protected processGetEmailData(response: HttpResponseBase): Observable<GetEmailDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmailDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmailDataOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSupportedEmailFromAddresses(): Observable<EmailFromInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetSupportedEmailFromAddresses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportedEmailFromAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportedEmailFromAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailFromInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailFromInfo[]>;
        }));
    }

    protected processGetSupportedEmailFromAddresses(response: HttpResponseBase): Observable<EmailFromInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmailFromInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailFromInfo[]>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    saveAttachment(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/SaveAttachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSaveAttachment(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAttachmentLink(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetAttachmentLink?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAttachmentLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAttachment(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/DeleteAttachment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmail(body: SendEmailInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkEmailSend(body: BulkSendEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/BulkEmailSend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkEmailSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkEmailSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkEmailSend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    storeEmail(body: StoreEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/StoreEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendSMS(body: SendSMSInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/SendSMS";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSMS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSMS(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSendSMS(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ContactEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactEmail(body: CreateContactEmailInput | undefined): Observable<CreateContactEmailOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/CreateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateContactEmailOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateContactEmailOutput>;
        }));
    }

    protected processCreateContactEmail(response: HttpResponseBase): Observable<CreateContactEmailOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateContactEmailOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactEmailOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactEmail(body: UpdateContactEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/UpdateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteContactEmail(contactId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/DeleteContactEmail?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContactEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getEmailUsageTypes(): Observable<ListResultDtoOfEmailUsageTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/GetEmailUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailUsageTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfEmailUsageTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfEmailUsageTypeDto>;
        }));
    }

    protected processGetEmailUsageTypes(response: HttpResponseBase): Observable<ListResultDtoOfEmailUsageTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEmailUsageTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEmailUsageTypeDto>(null as any);
    }
}

@Injectable()
export class ContactLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactLink(body: CreateContactLinkInput | undefined): Observable<CreateContactLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/CreateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateContactLinkOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateContactLinkOutput>;
        }));
    }

    protected processCreateContactLink(response: HttpResponseBase): Observable<CreateContactLinkOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateContactLinkOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactLinkOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactLink(body: UpdateContactLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/UpdateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteContactLink(contactId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/DeleteContactLink?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContactLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getContactLinkTypes(): Observable<ListResultDtoOfContactLinkTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/GetContactLinkTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLinkTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLinkTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfContactLinkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfContactLinkTypeDto>;
        }));
    }

    protected processGetContactLinkTypes(response: HttpResponseBase): Observable<ListResultDtoOfContactLinkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfContactLinkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfContactLinkTypeDto>(null as any);
    }
}

@Injectable()
export class ContactListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactLists(body: UpdateContactListsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/UpdateContactLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addContactsToLists(body: AddContactsToListsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/AddContactsToLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddContactsToLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContactsToLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddContactsToLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactIds (optional) 
     * @param listIds (optional) 
     * @return Success
     */
    removeContactsFromLists(contactIds: number[] | undefined, listIds: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/RemoveContactsFromLists?";
        if (contactIds === null)
            throw new Error("The parameter 'contactIds' cannot be null.");
        else if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "ContactIds=" + encodeURIComponent("" + item) + "&"; });
        if (listIds === null)
            throw new Error("The parameter 'listIds' cannot be null.");
        else if (listIds !== undefined)
            listIds && listIds.forEach(item => { url_ += "ListIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContactsFromLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContactsFromLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveContactsFromLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rename(body: UpdateContactListInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param moveToListId (optional) 
     * @param deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number, moveToListId: number | undefined, deleteAllReferences: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moveToListId === null)
            throw new Error("The parameter 'moveToListId' cannot be null.");
        else if (moveToListId !== undefined)
            url_ += "MoveToListId=" + encodeURIComponent("" + moveToListId) + "&";
        if (deleteAllReferences === null)
            throw new Error("The parameter 'deleteAllReferences' cannot be null.");
        else if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContactPhoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getContactPhones(contactId: number | undefined): Observable<ContactPhoneInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetContactPhones?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactPhones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactPhones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactPhoneInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactPhoneInfo[]>;
        }));
    }

    protected processGetContactPhones(response: HttpResponseBase): Observable<ContactPhoneInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactPhoneInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactPhoneInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactPhone(body: CreateContactPhoneInput | undefined): Observable<CreateContactPhoneOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/CreateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateContactPhoneOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateContactPhoneOutput>;
        }));
    }

    protected processCreateContactPhone(response: HttpResponseBase): Observable<CreateContactPhoneOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateContactPhoneOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactPhoneOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactPhone(body: UpdateContactPhoneInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/UpdateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactPhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteContactPhone(contactId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/DeleteContactPhone?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContactPhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPhoneUsageTypes(): Observable<ListResultDtoOfPhoneUsageTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetPhoneUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhoneUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhoneUsageTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfPhoneUsageTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfPhoneUsageTypeDto>;
        }));
    }

    protected processGetPhoneUsageTypes(response: HttpResponseBase): Observable<ListResultDtoOfPhoneUsageTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfPhoneUsageTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPhoneUsageTypeDto>(null as any);
    }
}

@Injectable()
export class ContactPhotoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactPhoto(body: CreateContactPhotoInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhoto/CreateContactPhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateContactPhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    clearContactPhoto(contactId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhoto/ClearContactPhoto?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearContactPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearContactPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearContactPhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContactRatingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRatings(): Observable<ContactRatingInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/GetRatings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactRatingInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactRatingInfoDto[]>;
        }));
    }

    protected processGetRatings(response: HttpResponseBase): Observable<ContactRatingInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactRatingInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactRatingInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rateContact(body: RateContactInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/RateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rateContacts(body: RateContactsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/RateContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRateContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContactStarsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markContact(body: MarkContactInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactStars/MarkContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markContacts(body: MarkContactsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactStars/MarkContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContactTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactTags(body: UpdateContactTagsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/UpdateContactTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tagContacts(body: TagContactsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/TagContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTagContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTagContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTagContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    untagContacts(body: UntagContactsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/UntagContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUntagContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUntagContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUntagContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rename(body: UpdateContactTagInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param moveToTagId (optional) 
     * @param deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number, moveToTagId: number | undefined, deleteAllReferences: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moveToTagId === null)
            throw new Error("The parameter 'moveToTagId' cannot be null.");
        else if (moveToTagId !== undefined)
            url_ += "MoveToTagId=" + encodeURIComponent("" + moveToTagId) + "&";
        if (deleteAllReferences === null)
            throw new Error("The parameter 'deleteAllReferences' cannot be null.");
        else if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContactUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    requestAutoLoginToken(userKey: string): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactUser/RequestAutoLoginToken?";
        if (userKey === undefined || userKey === null)
            throw new Error("The parameter 'userKey' must be defined and cannot be null.");
        else
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestAutoLoginToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestAutoLoginToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequestAutoLoginToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getCountryStates(code: string | undefined): Observable<CountryStateDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountryStates?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryStates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryStateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryStateDto[]>;
        }));
    }

    protected processGetCountryStates(response: HttpResponseBase): Observable<CountryStateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryStateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryStateDto[]>(null as any);
    }
}

@Injectable()
export class CreditReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param reportId (optional) 
     * @return Success
     */
    downloadCreditReport(reportId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Reports/CreditReport/DownloadCreditReport?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCreditReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDownloadCreditReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param dateTime (optional) 
     * @return Success
     */
    getLastCreditReport(dateTime: moment.Moment | undefined): Observable<CreditReportOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetLastCreditReport?";
        if (dateTime === null)
            throw new Error("The parameter 'dateTime' cannot be null.");
        else if (dateTime !== undefined)
            url_ += "DateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCreditReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditReportOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditReportOutput>;
        }));
    }

    protected processGetLastCreditReport(response: HttpResponseBase): Observable<CreditReportOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreditReportOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditReportOutput>(null as any);
    }

    /**
     * @param creditReport (optional) 
     * @param accountIds (optional) 
     * @return Success
     */
    getAccountInfo(creditReport: number | undefined, accountIds: number[] | undefined): Observable<AccountInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetAccountInfo?";
        if (creditReport === null)
            throw new Error("The parameter 'creditReport' cannot be null.");
        else if (creditReport !== undefined)
            url_ += "creditReport=" + encodeURIComponent("" + creditReport) + "&";
        if (accountIds === null)
            throw new Error("The parameter 'accountIds' cannot be null.");
        else if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "accountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountInfoDto[]>;
        }));
    }

    protected processGetAccountInfo(response: HttpResponseBase): Observable<AccountInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountInfoDto[]>(null as any);
    }

    /**
     * @param periodYears (optional) 
     * @param reportId (optional) 
     * @return Success
     */
    getCreditReportHistory(periodYears: number | undefined, reportId: number | undefined): Observable<KeyValuePairOfBureauListOfScoreHistoryDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetCreditReportHistory?";
        if (periodYears === null)
            throw new Error("The parameter 'periodYears' cannot be null.");
        else if (periodYears !== undefined)
            url_ += "periodYears=" + encodeURIComponent("" + periodYears) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValuePairOfBureauListOfScoreHistoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValuePairOfBureauListOfScoreHistoryDto[]>;
        }));
    }

    protected processGetCreditReportHistory(response: HttpResponseBase): Observable<KeyValuePairOfBureauListOfScoreHistoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValuePairOfBureauListOfScoreHistoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyValuePairOfBureauListOfScoreHistoryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    loadAlerts(): Observable<AlertDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/LoadAlerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertDto[]>;
        }));
    }

    protected processLoadAlerts(response: HttpResponseBase): Observable<AlertDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AlertDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AlertDto[]>(null as any);
    }
}

@Injectable()
export class CreditSimulatorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getScoreSimulatorInfo(): Observable<ScoreSimulatorInfoDto> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditSimulator/GetScoreSimulatorInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScoreSimulatorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScoreSimulatorInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScoreSimulatorInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScoreSimulatorInfoDto>;
        }));
    }

    protected processGetScoreSimulatorInfo(response: HttpResponseBase): Observable<ScoreSimulatorInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScoreSimulatorInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScoreSimulatorInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    simulateScore(body: ScoreSimulatorDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditSimulator/SimulateScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulateScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulateScore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSimulateScore(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CurrencyInfo[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Currency/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyInfo[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CurrencyInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyInfo[]>(null as any);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @param hasUserAccount (optional) 
     * @param exceptUserIds (optional) 
     * @param excludeSubContacts (optional) 
     * @param fullAccess (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | undefined, topCount: number | undefined, hasUserAccount: boolean | undefined, exceptUserIds: number[] | undefined, excludeSubContacts: boolean | undefined, fullAccess: boolean | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Customer/GetAllByPhrase?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (hasUserAccount === null)
            throw new Error("The parameter 'hasUserAccount' cannot be null.");
        else if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&";
        if (exceptUserIds === null)
            throw new Error("The parameter 'exceptUserIds' cannot be null.");
        else if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts === null)
            throw new Error("The parameter 'excludeSubContacts' cannot be null.");
        else if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&";
        if (fullAccess === null)
            throw new Error("The parameter 'fullAccess' cannot be null.");
        else if (fullAccess !== undefined)
            url_ += "FullAccess=" + encodeURIComponent("" + fullAccess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityContactInfo[]>;
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(null as any);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param bankAccountIds (optional) 
     * @return Success
     */
    getAccountTotals(instanceType: InstanceType | undefined, instanceId: number | undefined, bankAccountIds: number[] | undefined, currencyId: string): Observable<AccountTotals> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetAccountTotals?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (bankAccountIds === null)
            throw new Error("The parameter 'bankAccountIds' cannot be null.");
        else if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTotals>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTotals>;
        }));
    }

    protected processGetAccountTotals(response: HttpResponseBase): Observable<AccountTotals> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTotals.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTotals>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param bankAccountIds (optional) 
     * @return Success
     */
    getCategorizationStatus(instanceType: InstanceType | undefined, instanceId: number | undefined, currencyId: string, bankAccountIds: number[] | undefined): Observable<CategorizationStatus> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetCategorizationStatus?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (bankAccountIds === null)
            throw new Error("The parameter 'bankAccountIds' cannot be null.");
        else if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategorizationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategorizationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategorizationStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategorizationStatus>;
        }));
    }

    protected processGetCategorizationStatus(response: HttpResponseBase): Observable<CategorizationStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategorizationStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategorizationStatus>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param bankAccountIdsString (optional) 
     * @param startDate (optional) 
     * @return Success
     */
    getDailyBalanceStats(instanceType: InstanceType | undefined, instanceId: number | undefined, bankAccountIdsString: string | undefined, currencyId: string, startDate: moment.Moment | undefined, endDate: moment.Moment): Observable<GetDailyBalanceStatsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetDailyBalanceStats?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (bankAccountIdsString === null)
            throw new Error("The parameter 'bankAccountIdsString' cannot be null.");
        else if (bankAccountIdsString !== undefined)
            url_ += "BankAccountIdsString=" + encodeURIComponent("" + bankAccountIdsString) + "&";
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailyBalanceStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailyBalanceStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDailyBalanceStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDailyBalanceStatsOutput>;
        }));
    }

    protected processGetDailyBalanceStats(response: HttpResponseBase): Observable<GetDailyBalanceStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailyBalanceStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailyBalanceStatsOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param maxCount (optional) 
     * @param bankAccountIdsString (optional) 
     * @param startDate (optional) 
     * @return Success
     */
    getSpendingCategories(instanceType: InstanceType | undefined, instanceId: number | undefined, maxCount: number | undefined, bankAccountIdsString: string | undefined, currencyId: string, startDate: moment.Moment | undefined, endDate: moment.Moment): Observable<GetSpendingCategoriesOutput[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetSpendingCategories?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (maxCount === null)
            throw new Error("The parameter 'maxCount' cannot be null.");
        else if (maxCount !== undefined)
            url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
        if (bankAccountIdsString === null)
            throw new Error("The parameter 'bankAccountIdsString' cannot be null.");
        else if (bankAccountIdsString !== undefined)
            url_ += "BankAccountIdsString=" + encodeURIComponent("" + bankAccountIdsString) + "&";
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpendingCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpendingCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSpendingCategoriesOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSpendingCategoriesOutput[]>;
        }));
    }

    protected processGetSpendingCategories(response: HttpResponseBase): Observable<GetSpendingCategoriesOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSpendingCategoriesOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSpendingCategoriesOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getTotals(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetTotals?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTotalsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTotalsOutput>;
        }));
    }

    protected processGetTotals(response: HttpResponseBase): Observable<GetTotalsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTotalsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTotalsOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param periodCount (optional) 
     * @param isCumulative (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getCustomerAndLeadStats(groupBy: GroupByPeriod, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, periodCount: number | undefined, isCumulative: boolean | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetCustomerAndLeadStatsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetCustomerAndLeadStats?";
        if (groupBy === undefined || groupBy === null)
            throw new Error("The parameter 'groupBy' must be defined and cannot be null.");
        else
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (periodCount === null)
            throw new Error("The parameter 'periodCount' cannot be null.");
        else if (periodCount !== undefined)
            url_ += "PeriodCount=" + encodeURIComponent("" + periodCount) + "&";
        if (isCumulative === null)
            throw new Error("The parameter 'isCumulative' cannot be null.");
        else if (isCumulative !== undefined)
            url_ += "IsCumulative=" + encodeURIComponent("" + isCumulative) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAndLeadStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAndLeadStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCustomerAndLeadStatsOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCustomerAndLeadStatsOutput[]>;
        }));
    }

    protected processGetCustomerAndLeadStats(response: HttpResponseBase): Observable<GetCustomerAndLeadStatsOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCustomerAndLeadStatsOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAndLeadStatsOutput[]>(null as any);
    }

    /**
     * @param periodCount (optional) 
     * @param isCumulative (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactAndLeadStats(groupBy: GroupByPeriod, periodCount: number | undefined, isCumulative: boolean | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetCustomerAndLeadStatsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactAndLeadStats?";
        if (groupBy === undefined || groupBy === null)
            throw new Error("The parameter 'groupBy' must be defined and cannot be null.");
        else
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&";
        if (periodCount === null)
            throw new Error("The parameter 'periodCount' cannot be null.");
        else if (periodCount !== undefined)
            url_ += "PeriodCount=" + encodeURIComponent("" + periodCount) + "&";
        if (isCumulative === null)
            throw new Error("The parameter 'isCumulative' cannot be null.");
        else if (isCumulative !== undefined)
            url_ += "IsCumulative=" + encodeURIComponent("" + isCumulative) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactAndLeadStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactAndLeadStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCustomerAndLeadStatsOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCustomerAndLeadStatsOutput[]>;
        }));
    }

    protected processGetContactAndLeadStats(response: HttpResponseBase): Observable<GetCustomerAndLeadStatsOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCustomerAndLeadStatsOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAndLeadStatsOutput[]>(null as any);
    }

    /**
     * @param topCount (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getRecentlyCreatedCustomers(topCount: number | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetRecentlyCreatedCustomersOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetRecentlyCreatedCustomers?";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyCreatedCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyCreatedCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentlyCreatedCustomersOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentlyCreatedCustomersOutput[]>;
        }));
    }

    protected processGetRecentlyCreatedCustomers(response: HttpResponseBase): Observable<GetRecentlyCreatedCustomersOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetRecentlyCreatedCustomersOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentlyCreatedCustomersOutput[]>(null as any);
    }

    /**
     * @param topCount (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getRecentlyCreatedLeads(topCount: number | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetRecentlyCreatedLeadsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetRecentlyCreatedLeads?";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyCreatedLeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyCreatedLeads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentlyCreatedLeadsOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentlyCreatedLeadsOutput[]>;
        }));
    }

    protected processGetRecentlyCreatedLeads(response: HttpResponseBase): Observable<GetRecentlyCreatedLeadsOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetRecentlyCreatedLeadsOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentlyCreatedLeadsOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByCompanySize(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetContactsByCompanySizeOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByCompanySize?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByCompanySize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByCompanySize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactsByCompanySizeOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactsByCompanySizeOutput[]>;
        }));
    }

    protected processGetContactsByCompanySize(response: HttpResponseBase): Observable<GetContactsByCompanySizeOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetContactsByCompanySizeOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactsByCompanySizeOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByRegion(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetContactsByRegionOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByRegion?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByRegion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByRegion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactsByRegionOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactsByRegionOutput[]>;
        }));
    }

    protected processGetContactsByRegion(response: HttpResponseBase): Observable<GetContactsByRegionOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetContactsByRegionOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactsByRegionOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getLeadsCountByAge(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetCountOutputOfLeadAgeRange[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetLeadsCountByAge?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadsCountByAge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadsCountByAge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountOutputOfLeadAgeRange[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountOutputOfLeadAgeRange[]>;
        }));
    }

    protected processGetLeadsCountByAge(response: HttpResponseBase): Observable<GetCountOutputOfLeadAgeRange[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountOutputOfLeadAgeRange.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutputOfLeadAgeRange[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getLeadsCountByStage(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetLeadsCountByStage?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadsCountByStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadsCountByStage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountOutput[]>;
        }));
    }

    protected processGetLeadsCountByStage(response: HttpResponseBase): Observable<GetCountOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByRating(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByRating?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByRating(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountOutput[]>;
        }));
    }

    protected processGetContactsByRating(response: HttpResponseBase): Observable<GetCountOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByStar(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetCountByStarOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByStar?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByStar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountByStarOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountByStarOutput[]>;
        }));
    }

    protected processGetContactsByStar(response: HttpResponseBase): Observable<GetCountByStarOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountByStarOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountByStarOutput[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactInfoStatsByStar(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<GetContactInfoStatsByStarOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactInfoStatsByStar?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoStatsByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoStatsByStar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactInfoStatsByStarOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactInfoStatsByStarOutput[]>;
        }));
    }

    protected processGetContactInfoStatsByStar(response: HttpResponseBase): Observable<GetContactInfoStatsByStarOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetContactInfoStatsByStarOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactInfoStatsByStarOutput[]>(null as any);
    }

    /**
     * @param starNames (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @param sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactStatsByStar(groupBy: GroupByPeriod, starNames: string[] | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, contactGroupId: string | undefined, sourceContactId: number | undefined, sourceOrganizationUnitIds: number[] | undefined): Observable<ContactsStatsByStarInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactStatsByStar?";
        if (groupBy === undefined || groupBy === null)
            throw new Error("The parameter 'groupBy' must be defined and cannot be null.");
        else
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&";
        if (starNames === null)
            throw new Error("The parameter 'starNames' cannot be null.");
        else if (starNames !== undefined)
            starNames && starNames.forEach(item => { url_ += "StarNames=" + encodeURIComponent("" + item) + "&"; });
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactStatsByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactStatsByStar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactsStatsByStarInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactsStatsByStarInfo[]>;
        }));
    }

    protected processGetContactStatsByStar(response: HttpResponseBase): Observable<ContactsStatsByStarInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactsStatsByStarInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactsStatsByStarInfo[]>(null as any);
    }

    /**
     * @param contactGroupId (optional) 
     * @param sourceContactId (optional) 
     * @return Success
     */
    getStatus(contactGroupId: string | undefined, sourceContactId: number | undefined): Observable<GetCRMStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetStatus?";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (sourceContactId === null)
            throw new Error("The parameter 'sourceContactId' cannot be null.");
        else if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCRMStatusOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCRMStatusOutput>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<GetCRMStatusOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCRMStatusOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCRMStatusOutput>(null as any);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | undefined, application: string | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/GetUserDashboard?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dashboard>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dashboard>;
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dashboard>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddNewPageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddNewPageOutput>;
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddNewPageOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | undefined, dashboardName: string | undefined, application: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/DeletePage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Widget>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Widget>;
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Widget>(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | undefined, application: string | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardOutput>;
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardOutput>(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | undefined, application: string | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetOutput[]>(null as any);
    }

    /**
     * @param application (optional) 
     * @return Success
     */
    getSettingName(application: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/DashboardCustomization/GetSettingName?";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class DepartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getAccessibleDepartments(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Departments/GetAccessibleDepartments?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessibleDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessibleDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAccessibleDepartments(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }
}

@Injectable()
export class DictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPartnerTypes(): Observable<PartnerTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetPartnerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerTypeDto[]>;
        }));
    }

    protected processGetPartnerTypes(response: HttpResponseBase): Observable<PartnerTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PartnerTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getStars(): Observable<ContactStarInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetStars";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactStarInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactStarInfoDto[]>;
        }));
    }

    protected processGetStars(response: HttpResponseBase): Observable<ContactStarInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactStarInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactStarInfoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getTags(): Observable<ContactTagInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactTagInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactTagInfoDto[]>;
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<ContactTagInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactTagInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactTagInfoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getLists(): Observable<ContactListInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactListInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactListInfoDto[]>;
        }));
    }

    protected processGetLists(response: HttpResponseBase): Observable<ContactListInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactListInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListInfoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getOrganizationTypes(): Observable<OrganizationTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetOrganizationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationTypeDto[]>;
        }));
    }

    protected processGetOrganizationTypes(response: HttpResponseBase): Observable<OrganizationTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getInterests(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetInterests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInterests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInterests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetInterests(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @param partnersOnly (optional) 
     * @return Success
     */
    getOrganizationUnits(searchPhrase: string | undefined, topCount: number | undefined, partnersOnly: boolean | undefined): Observable<OrganizationUnitShortDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetOrganizationUnits?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (partnersOnly === null)
            throw new Error("The parameter 'partnersOnly' cannot be null.");
        else if (partnersOnly !== undefined)
            url_ += "PartnersOnly=" + encodeURIComponent("" + partnersOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitShortDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitShortDto[]>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitShortDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitShortDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitShortDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDefaultOrganizationUnit(): Observable<OrganizationUnitShortDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetDefaultOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitShortDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitShortDto>;
        }));
    }

    protected processGetDefaultOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitShortDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitShortDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitShortDto>(null as any);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getAll(contactId: number | undefined): Observable<DocumentInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetAll?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentInfo[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentInfo[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContent(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetContent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetContent(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUrl(id: string | undefined): Observable<GetUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetUrl?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUrlOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUrlOutput>;
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetUrlOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUrlOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUrlOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    upload(body: UploadDocumentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/Upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateType(body: UpdateTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/UpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    copyTemplate(body: CopyTemplateInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/CopyTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCopyTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getViewWopiRequestInfo(documentId: string | undefined): Observable<WopiRequestOutcoming> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetViewWopiRequestInfo?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewWopiRequestInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewWopiRequestInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WopiRequestOutcoming>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WopiRequestOutcoming>;
        }));
    }

    protected processGetViewWopiRequestInfo(response: HttpResponseBase): Observable<WopiRequestOutcoming> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WopiRequestOutcoming.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WopiRequestOutcoming>(null as any);
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getEditWopiRequestInfo(documentId: string | undefined): Observable<WopiRequestOutcoming> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetEditWopiRequestInfo?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditWopiRequestInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditWopiRequestInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WopiRequestOutcoming>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WopiRequestOutcoming>;
        }));
    }

    protected processGetEditWopiRequestInfo(response: HttpResponseBase): Observable<WopiRequestOutcoming> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WopiRequestOutcoming.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WopiRequestOutcoming>(null as any);
    }
}

@Injectable()
export class DocumentTemplatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param folderId (optional) 
     * @param infiniteValidityPeriod (optional) 
     * @return Success
     */
    getUrl(folderId: number | undefined, fileName: string, infiniteValidityPeriod: boolean | undefined): Observable<GetFileUrlDto> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentTemplates/GetUrl?";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (infiniteValidityPeriod === null)
            throw new Error("The parameter 'infiniteValidityPeriod' cannot be null.");
        else if (infiniteValidityPeriod !== undefined)
            url_ += "infiniteValidityPeriod=" + encodeURIComponent("" + infiniteValidityPeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFileUrlDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFileUrlDto>;
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetFileUrlDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFileUrlDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFileUrlDto>(null as any);
    }
}

@Injectable()
export class DocumentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<DocumentTypeInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeInfo[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentTypeInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentTypeInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDocumentTypeInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDocumentTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfEditionListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfEditionListDto>;
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionEditOutput>;
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscribableEditionComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscribableEditionComboboxItemDto[]>;
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class EmailingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    payload(recipientUserId: number, recipientHash: string, emailType: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Emailing/Payload?";
        if (recipientUserId === undefined || recipientUserId === null)
            throw new Error("The parameter 'recipientUserId' must be defined and cannot be null.");
        else
            url_ += "recipientUserId=" + encodeURIComponent("" + recipientUserId) + "&";
        if (recipientHash === undefined || recipientHash === null)
            throw new Error("The parameter 'recipientHash' must be defined and cannot be null.");
        else
            url_ += "recipientHash=" + encodeURIComponent("" + recipientHash) + "&";
        if (emailType === undefined || emailType === null)
            throw new Error("The parameter 'emailType' must be defined and cannot be null.");
        else
            url_ += "emailType=" + encodeURIComponent("" + emailType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPayload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    createIAgeMembers(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Emailing/CreateIAgeMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIAgeMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIAgeMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateIAgeMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EmailSmtpSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/EmailSmtpSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EmailTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getTemplates(type: EmailTemplateType | undefined): Observable<GetTemplatesResponse[]> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/GetTemplates?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTemplatesResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTemplatesResponse[]>;
        }));
    }

    protected processGetTemplates(response: HttpResponseBase): Observable<GetTemplatesResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTemplatesResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTemplatesResponse[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTemplate(id: number | undefined): Observable<GetTemplateReponse> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/GetTemplate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTemplateReponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTemplateReponse>;
        }));
    }

    protected processGetTemplate(response: HttpResponseBase): Observable<GetTemplateReponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTemplateReponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTemplateReponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEmailTemplateRequest | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clone(body: CloneEmailTemplateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEmailTemplateRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSubscriptions(): Observable<EventSubscriptionDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/GetSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSubscriptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSubscriptionDto[]>;
        }));
    }

    protected processGetSubscriptions(response: HttpResponseBase): Observable<EventSubscriptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventSubscriptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventSubscriptionDto[]>(null as any);
    }

    /**
     * @param eventSubscriptionId (optional) 
     * @param searchString (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEventExecutions(eventSubscriptionId: number | undefined, searchString: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<EventJobExecutionDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/GetEventExecutions?";
        if (eventSubscriptionId === null)
            throw new Error("The parameter 'eventSubscriptionId' cannot be null.");
        else if (eventSubscriptionId !== undefined)
            url_ += "EventSubscriptionId=" + encodeURIComponent("" + eventSubscriptionId) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "SearchString=" + encodeURIComponent("" + searchString) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventExecutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventExecutions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventJobExecutionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventJobExecutionDto[]>;
        }));
    }

    protected processGetEventExecutions(response: HttpResponseBase): Observable<EventJobExecutionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventJobExecutionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventJobExecutionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribe(body: SubscribeForEventInput | undefined): Observable<SubscribeForEventOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/Subscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscribeForEventOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscribeForEventOutput>;
        }));
    }

    protected processSubscribe(response: HttpResponseBase): Observable<SubscribeForEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeForEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribeForEventOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    unsubscribe(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/Unsubscribe?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnsubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnsubscribe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnsubscribe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ExtensionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCategories(): Observable<ExtensionCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/HUB/Extension/GetCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExtensionCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExtensionCategoryDto[]>;
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<ExtensionCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExtensionCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtensionCategoryDto[]>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param topCount (optional) 
     * @return Success
     */
    getAll(categoryId: number | undefined, topCount: number | undefined): Observable<ExtensionDto[]> {
        let url_ = this.baseUrl + "/api/services/HUB/Extension/GetAll?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "topCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExtensionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExtensionDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ExtensionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExtensionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtensionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    import(body: ImportExtensionDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/HUB/Extension/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FeatureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<FlatFeatureDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Feature/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlatFeatureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlatFeatureDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FlatFeatureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlatFeatureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatFeatureDto[]>(null as any);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopStatsData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopStatsData>;
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopStatsData>(null as any);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentTenantsOutput>;
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentTenantsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetExpiringTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetExpiringTenantsOutput>;
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpiringTenantsOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIncomeStatisticsDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIncomeStatisticsDataOutput>;
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionTenantStatisticsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionTenantStatisticsOutput>;
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getYTelSettings(): Observable<YTelSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYTelSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<YTelSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<YTelSettingsEditDto>;
        }));
    }

    protected processGetYTelSettings(response: HttpResponseBase): Observable<YTelSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YTelSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YTelSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getTenantManagementSettings(): Observable<TenantManagementSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetTenantManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantManagementSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantManagementSettingsEditDto>;
        }));
    }

    protected processGetTenantManagementSettings(response: HttpResponseBase): Observable<TenantManagementSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantManagementSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantManagementSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getUserManagementSettings(): Observable<HostUserManagementSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostUserManagementSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostUserManagementSettingsEditDto>;
        }));
    }

    protected processGetUserManagementSettings(response: HttpResponseBase): Observable<HostUserManagementSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostUserManagementSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostUserManagementSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getBugsnagSettings(): Observable<BugsnagSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetBugsnagSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBugsnagSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBugsnagSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugsnagSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugsnagSettingsDto>;
        }));
    }

    protected processGetBugsnagSettings(response: HttpResponseBase): Observable<BugsnagSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugsnagSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugsnagSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    getMaintenanceSettings(): Observable<MaintenanceSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetMaintenanceSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintenanceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintenanceSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaintenanceSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaintenanceSettingsDto>;
        }));
    }

    protected processGetMaintenanceSettings(response: HttpResponseBase): Observable<MaintenanceSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaintenanceSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaintenanceSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateYTelSettings(body: YTelSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateYTelSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateYTelSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBugsnagSettings(body: BugsnagSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateBugsnagSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBugsnagSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBugsnagSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBugsnagSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantManagementSettings(body: TenantManagementSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateTenantManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserManagementSettings(body: HostUserManagementSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaintenanceSettings(body: MaintenanceSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateMaintenanceSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaintenanceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaintenanceSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateMaintenanceSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getGeneralSettings(): Observable<GeneralSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSettingsEditDto>;
        }));
    }

    protected processGetGeneralSettings(response: HttpResponseBase): Observable<GeneralSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGeneralSettings(body: GeneralSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateGeneralSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmailSettings(body: EmailSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    import(body: ImportInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStatuses(id: number | undefined): Observable<GetImportStatusOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetStatuses?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetImportStatusOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetImportStatusOutput[]>;
        }));
    }

    protected processGetStatuses(response: HttpResponseBase): Observable<GetImportStatusOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetImportStatusOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImportStatusOutput[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cancel(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Cancel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param importId (optional) 
     * @return Success
     */
    getFileUrl(importId: number | undefined): Observable<GetFileUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetFileUrl?";
        if (importId === null)
            throw new Error("The parameter 'importId' cannot be null.");
        else if (importId !== undefined)
            url_ += "importId=" + encodeURIComponent("" + importId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFileUrlOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFileUrlOutput>;
        }));
    }

    protected processGetFileUrl(response: HttpResponseBase): Observable<GetFileUrlOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFileUrlOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFileUrlOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMappedFields(body: string[] | undefined): Observable<ImportFieldInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetMappedFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappedFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappedFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportFieldInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportFieldInfoDto[]>;
        }));
    }

    protected processGetMappedFields(response: HttpResponseBase): Observable<ImportFieldInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImportFieldInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportFieldInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importContact(body: ImportContactInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/ImportContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processImportContact(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class InstanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param invalidateCache (optional) 
     * @return Success
     */
    getStatus(instanceType: InstanceType | undefined, instanceId: number | undefined, invalidateCache: boolean | undefined): Observable<GetStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetStatus?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (invalidateCache === null)
            throw new Error("The parameter 'invalidateCache' cannot be null.");
        else if (invalidateCache !== undefined)
            url_ += "invalidateCache=" + encodeURIComponent("" + invalidateCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStatusOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStatusOutput>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<GetStatusOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStatusOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStatusOutput>(null as any);
    }

    /**
     * @param accountingTreeType (optional) 
     * @return Success
     */
    setup(instanceType: InstanceType, accountingTreeType: AccountingTreeType | undefined): Observable<SetupOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/Setup?";
        if (instanceType === undefined || instanceType === null)
            throw new Error("The parameter 'instanceType' must be defined and cannot be null.");
        else
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (accountingTreeType === null)
            throw new Error("The parameter 'accountingTreeType' cannot be null.");
        else if (accountingTreeType !== undefined)
            url_ += "accountingTreeType=" + encodeURIComponent("" + accountingTreeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetupOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetupOutput>;
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<SetupOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetupOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetupOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberInput | undefined): Observable<RegisterMemberOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterMemberOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterMemberOutput>;
        }));
    }

    protected processRegisterMember(response: HttpResponseBase): Observable<RegisterMemberOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterMemberOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterMemberOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getUsers(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<GetUsersInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUsers?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUsersInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUsersInfoDto[]>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<GetUsersInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetUsersInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsersInfoDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addUser(instanceType: InstanceType | undefined, instanceId: number | undefined, body: AddUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/AddUser?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    removeUser(instanceType: InstanceType | undefined, instanceId: number | undefined, userId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/RemoveUser?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserInstanceInfo(userId: number | undefined): Observable<GetUserInstanceInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUserInstanceInfo?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInstanceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInstanceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserInstanceInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserInstanceInfoOutput>;
        }));
    }

    protected processGetUserInstanceInfo(response: HttpResponseBase): Observable<GetUserInstanceInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserInstanceInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserInstanceInfoOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getMaxVisibleDate(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetMaxVisibleDate?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaxVisibleDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxVisibleDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<moment.Moment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<moment.Moment>;
        }));
    }

    protected processGetMaxVisibleDate(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<moment.Moment>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param maxVisibleDate (optional) 
     * @return Success
     */
    setMaxVisibleDate(instanceType: InstanceType | undefined, instanceId: number | undefined, maxVisibleDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/SetMaxVisibleDate?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (maxVisibleDate === null)
            throw new Error("The parameter 'maxVisibleDate' cannot be null.");
        else if (maxVisibleDate !== undefined)
            url_ += "maxVisibleDate=" + encodeURIComponent(maxVisibleDate ? "" + maxVisibleDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMaxVisibleDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMaxVisibleDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetMaxVisibleDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getInstanceOwnerEmailAddress(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetInstanceOwnerEmailAddress?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstanceOwnerEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstanceOwnerEmailAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetInstanceOwnerEmailAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param userIds (optional) 
     * @return Success
     */
    getUsersWithInstance(userIds: number[] | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUsersWithInstance?";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersWithInstance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersWithInstance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetUsersWithInstance(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceInfo>;
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateInvoiceInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateInvoiceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStatus(body: UpdateInvoiceStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/UpdateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInvoice(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/DeleteInvoice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteInvoices(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/DeleteInvoices?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getNewInvoiceInfo(): Observable<GetNewInvoiceInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetNewInvoiceInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNewInvoiceInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNewInvoiceInfoOutput>;
        }));
    }

    protected processGetNewInvoiceInfo(response: HttpResponseBase): Observable<GetNewInvoiceInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNewInvoiceInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNewInvoiceInfoOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @param regenerateNew (optional) 
     * @return Success
     */
    generatePdf(id: number | undefined, regenerateNew: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GeneratePdf?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (regenerateNew === null)
            throw new Error("The parameter 'regenerateNew' cannot be null.");
        else if (regenerateNew !== undefined)
            url_ += "regenerateNew=" + encodeURIComponent("" + regenerateNew) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGeneratePdf(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @return Success
     */
    getEmailData(templateId: number | undefined, invoiceId: number): Observable<GetEmailDataOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetEmailData?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&";
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined and cannot be null.");
        else
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmailDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmailDataOutput>;
        }));
    }

    protected processGetEmailData(response: HttpResponseBase): Observable<GetEmailDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmailDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmailDataOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addBankCardPayment(body: AddBankCardPaymentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/AddBankCardPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBankCardPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBankCardPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddBankCardPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    voidBankCardPayment(body: VoidBankCardPaymentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/VoidBankCardPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoidBankCardPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoidBankCardPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVoidBankCardPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getInvoiceAddresses(contactId: number | undefined): Observable<InvoiceAddressInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetInvoiceAddresses?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceAddressInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceAddressInfo[]>;
        }));
    }

    protected processGetInvoiceAddresses(response: HttpResponseBase): Observable<InvoiceAddressInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceAddressInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceAddressInfo[]>(null as any);
    }
}

@Injectable()
export class KBAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestKBA(body: RequestKBAInput | undefined): Observable<RequestKBAOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/KBA/RequestKBA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestKBA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestKBA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestKBAOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestKBAOutput>;
        }));
    }

    protected processRequestKBA(response: HttpResponseBase): Observable<RequestKBAOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestKBAOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestKBAOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    processKBAResponse(body: KBAResult | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/KBA/ProcessKBAResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessKBAResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessKBAResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProcessKBAResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguagesOutput>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguageForEditOutput>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, filterText: string | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LeadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelLead(body: CancelLeadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/CancelLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCancellationReasons(): Observable<ListResultDtoOfLeadCancellationReasonDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetCancellationReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfLeadCancellationReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfLeadCancellationReasonDto>;
        }));
    }

    protected processGetCancellationReasons(response: HttpResponseBase): Observable<ListResultDtoOfLeadCancellationReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLeadCancellationReasonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLeadCancellationReasonDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrUpdateLeadInput | undefined): Observable<CreateOrUpdateLeadOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrUpdateLeadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrUpdateLeadOutput>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateOrUpdateLeadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrUpdateLeadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateLeadOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitTenancyRequest(body: SubmitTenancyRequestInput | undefined): Observable<SubmitTenancyRequestOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitTenancyRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitTenancyRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitTenancyRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitTenancyRequestOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitTenancyRequestOutput>;
        }));
    }

    protected processSubmitTenancyRequest(response: HttpResponseBase): Observable<SubmitTenancyRequestOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitTenancyRequestOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitTenancyRequestOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitFreeTrialRequest(body: SubmitFreeTrialRequestInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitFreeTrialRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitFreeTrialRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitFreeTrialRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSubmitFreeTrialRequest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitClientRequest(body: SubmitClientRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitClientRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitClientRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitClientRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitClientRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLeadStage(body: UpdateLeadStageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadStage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLeadStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLeadStagePoint(body: UpdateLeadStagePointInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadStagePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadStagePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadStagePoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLeadStagePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    processLead(body: ProcessLeadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/ProcessLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProcessLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param leadId (optional) 
     * @return Success
     */
    getLeadInfo(leadId: number | undefined): Observable<LeadInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLeadInfo?";
        if (leadId === null)
            throw new Error("The parameter 'leadId' cannot be null.");
        else if (leadId !== undefined)
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeadInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeadInfoDto>;
        }));
    }

    protected processGetLeadInfo(response: HttpResponseBase): Observable<LeadInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeadInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadInfoDto>(null as any);
    }

    /**
     * @return Success
     */
    getLastLeadInfo(contactGroupId: string, contactId: number): Observable<LeadInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLastLeadInfo?";
        if (contactGroupId === undefined || contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' must be defined and cannot be null.");
        else
            url_ += "contactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastLeadInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeadInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeadInfoDto>;
        }));
    }

    protected processGetLastLeadInfo(response: HttpResponseBase): Observable<LeadInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeadInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLeadInfo(body: UpdateLeadInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLeadInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSourceContact(body: UpdateLeadSourceContactInput | undefined): Observable<UpdateLeadSourceContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLeadSourceContactOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLeadSourceContactOutput>;
        }));
    }

    protected processUpdateSourceContact(response: HttpResponseBase): Observable<UpdateLeadSourceContactOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateLeadSourceContactOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateLeadSourceContactOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSourceContacts(body: UpdateLeadSourceContactsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSourceContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSourceOrganizationUnit(body: UpdateLeadSourceOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSourceOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSourceOrganizationUnits(body: UpdateLeadSourceOrganizationUnitsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSourceOrganizationUnits(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param leadId (optional) 
     * @param forceDelete (optional) 
     * @return Success
     */
    deleteLead(leadId: number | undefined, forceDelete: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/DeleteLead?";
        if (leadId === null)
            throw new Error("The parameter 'leadId' cannot be null.");
        else if (leadId !== undefined)
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&";
        if (forceDelete === null)
            throw new Error("The parameter 'forceDelete' cannot be null.");
        else if (forceDelete !== undefined)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param forceDelete (optional) 
     * @param body (optional) 
     * @return Success
     */
    deleteLeads(forceDelete: boolean | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/DeleteLeads?";
        if (forceDelete === null)
            throw new Error("The parameter 'forceDelete' cannot be null.");
        else if (forceDelete !== undefined)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLeads(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @param hasUserAccount (optional) 
     * @param exceptUserIds (optional) 
     * @param excludeSubContacts (optional) 
     * @param fullAccess (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | undefined, topCount: number | undefined, hasUserAccount: boolean | undefined, exceptUserIds: number[] | undefined, excludeSubContacts: boolean | undefined, fullAccess: boolean | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetAllByPhrase?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (hasUserAccount === null)
            throw new Error("The parameter 'hasUserAccount' cannot be null.");
        else if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&";
        if (exceptUserIds === null)
            throw new Error("The parameter 'exceptUserIds' cannot be null.");
        else if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts === null)
            throw new Error("The parameter 'excludeSubContacts' cannot be null.");
        else if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&";
        if (fullAccess === null)
            throw new Error("The parameter 'fullAccess' cannot be null.");
        else if (fullAccess !== undefined)
            url_ += "FullAccess=" + encodeURIComponent("" + fullAccess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityContactInfo[]>;
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(null as any);
    }

    /**
     * @param stageIds (optional) 
     * @return Success
     */
    getStageChecklistPoints(leadId: number, stageIds: number[] | undefined): Observable<StageChecklistPointInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetStageChecklistPoints?";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined and cannot be null.");
        else
            url_ += "LeadId=" + encodeURIComponent("" + leadId) + "&";
        if (stageIds === null)
            throw new Error("The parameter 'stageIds' cannot be null.");
        else if (stageIds !== undefined)
            stageIds && stageIds.forEach(item => { url_ += "StageIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageChecklistPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageChecklistPoints(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StageChecklistPointInfoOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StageChecklistPointInfoOutput[]>;
        }));
    }

    protected processGetStageChecklistPoints(response: HttpResponseBase): Observable<StageChecklistPointInfoOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageChecklistPointInfoOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageChecklistPointInfoOutput[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDealInfo(body: UpdateLeadDealInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateDealInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDealInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDealInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDealInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LeadTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLeadTypes(): Observable<LeadTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/LeadType/GetLeadTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeadTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeadTypeDto[]>;
        }));
    }

    protected processGetLeadTypes(response: HttpResponseBase): Observable<LeadTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LeadTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadTypeDto[]>(null as any);
    }
}

@Injectable()
export class LearningResourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<LearningResourceGroupInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningResourceGroupInfoOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningResourceGroupInfoOutput[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LearningResourceGroupInfoOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LearningResourceGroupInfoOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LearningResourceGroupInfoOutput[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLearningResourceInput | undefined): Observable<CreateLearningResourceOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateLearningResourceOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateLearningResourceOutput>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateLearningResourceOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateLearningResourceOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLearningResourceOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLearningResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateResourceGroup(body: UpdateResourceGroupInput | undefined): Observable<UpdateResourceGroupOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/UpdateResourceGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResourceGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResourceGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateResourceGroupOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateResourceGroupOutput>;
        }));
    }

    protected processUpdateResourceGroup(response: HttpResponseBase): Observable<UpdateResourceGroupOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateResourceGroupOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateResourceGroupOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setImage(body: SetLearningResourceImageInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/SetImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGroup(body: CreateLearningResourceGroupInput | undefined): Observable<CreateLearningResourceGroupOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/CreateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateLearningResourceGroupOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateLearningResourceGroupOutput>;
        }));
    }

    protected processCreateGroup(response: HttpResponseBase): Observable<CreateLearningResourceGroupOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateLearningResourceGroupOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLearningResourceGroupOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGroup(body: UpdateLearningResourceGroupInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/UpdateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGroupSortOrder(body: UpdateGroupSortOrderInput | undefined): Observable<UpdateGroupSortOrderOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/UpdateGroupSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGroupSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroupSortOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGroupSortOrderOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGroupSortOrderOutput>;
        }));
    }

    protected processUpdateGroupSortOrder(response: HttpResponseBase): Observable<UpdateGroupSortOrderOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGroupSortOrderOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGroupSortOrderOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setGroupImage(body: SetLearningResourceGroupImageInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/SetGroupImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetGroupImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetGroupImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetGroupImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGroup(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/DeleteGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LocalizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param culture (optional) 
     * @param ui_culture (optional) 
     * @return Success
     */
    getLocalizationSource(tenantId: number, sourceName: string, version: string, culture: string | undefined, ui_culture: string | undefined): Observable<LocalizationSourceDto> {
        let url_ = this.baseUrl + "/api/Localization/GetLocalizationSource?";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined and cannot be null.");
        else
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        if (culture === null)
            throw new Error("The parameter 'culture' cannot be null.");
        else if (culture !== undefined)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (ui_culture === null)
            throw new Error("The parameter 'ui_culture' cannot be null.");
        else if (ui_culture !== undefined)
            url_ += "ui-culture=" + encodeURIComponent("" + ui_culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalizationSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalizationSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalizationSourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalizationSourceDto>;
        }));
    }

    protected processGetLocalizationSource(response: HttpResponseBase): Observable<LocalizationSourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalizationSourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationSourceDto>(null as any);
    }

    /**
     * @param sourceName (optional) 
     * @return Success
     */
    loadLocalizationSource(sourceName: string | undefined): Observable<LocalizationSourceDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Localization/LoadLocalizationSource?";
        if (sourceName === null)
            throw new Error("The parameter 'sourceName' cannot be null.");
        else if (sourceName !== undefined)
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadLocalizationSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadLocalizationSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalizationSourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalizationSourceDto>;
        }));
    }

    protected processLoadLocalizationSource(response: HttpResponseBase): Observable<LocalizationSourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalizationSourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationSourceDto>(null as any);
    }
}

@Injectable()
export class ManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    reScheduleApplications(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Manage/ReScheduleApplications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReScheduleApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReScheduleApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReScheduleApplications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param packageId (optional) 
     * @return Success
     */
    selectPackage(packageId: number | undefined): Observable<SelectPackageResponseDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/SelectPackage?";
        if (packageId === null)
            throw new Error("The parameter 'packageId' cannot be null.");
        else if (packageId !== undefined)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectPackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectPackageResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectPackageResponseDto>;
        }));
    }

    protected processSelectPackage(response: HttpResponseBase): Observable<SelectPackageResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectPackageResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectPackageResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitMemberInfo(body: MemberInfoDto | undefined): Observable<SubmitMemberInfoResultDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/SubmitMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMemberInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitMemberInfoResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitMemberInfoResultDto>;
        }));
    }

    protected processSubmitMemberInfo(response: HttpResponseBase): Observable<SubmitMemberInfoResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitMemberInfoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitMemberInfoResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paymentAuthorize(body: MemberPaymentAuthorizeRequestDto | undefined): Observable<PaymentAuthorizeResponseDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/PaymentAuthorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentAuthorize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAuthorizeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAuthorizeResponseDto>;
        }));
    }

    protected processPaymentAuthorize(response: HttpResponseBase): Observable<PaymentAuthorizeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAuthorizeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAuthorizeResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    cancelMembership(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/CancelMembership";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelMembership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelMembership(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelMembership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MemberServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeDeactivated (optional) 
     * @return Success
     */
    getAll(includeDeactivated: boolean | undefined): Observable<MemberServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/GetAll?";
        if (includeDeactivated === null)
            throw new Error("The parameter 'includeDeactivated' cannot be null.");
        else if (includeDeactivated !== undefined)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberServiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberServiceDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MemberServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberServiceDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSystemTypes(): Observable<SystemTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/GetSystemTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SystemTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SystemTypeDto[]>;
        }));
    }

    protected processGetSystemTypes(response: HttpResponseBase): Observable<SystemTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SystemTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSystemFeatures(systemType: string): Observable<FlatFeatureDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/GetSystemFeatures?";
        if (systemType === undefined || systemType === null)
            throw new Error("The parameter 'systemType' must be defined and cannot be null.");
        else
            url_ += "systemType=" + encodeURIComponent("" + systemType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlatFeatureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlatFeatureDto[]>;
        }));
    }

    protected processGetSystemFeatures(response: HttpResponseBase): Observable<FlatFeatureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlatFeatureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatFeatureDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: MemberServiceDto | undefined): Observable<CreateOrUpdateMemberServiceOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrUpdateMemberServiceOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrUpdateMemberServiceOutput>;
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<CreateOrUpdateMemberServiceOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrUpdateMemberServiceOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateMemberServiceOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ServiceProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeDeactivated (optional) 
     * @return Success
     * @deprecated
     */
    getAll(includeDeactivated: boolean | undefined): Observable<MemberServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ServiceProduct/GetAll?";
        if (includeDeactivated === null)
            throw new Error("The parameter 'includeDeactivated' cannot be null.");
        else if (includeDeactivated !== undefined)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberServiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberServiceDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MemberServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberServiceDto[]>(null as any);
    }
}

@Injectable()
export class MemberSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAffiliateCode(body: UpdateUserAffiliateCodeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberSettings/UpdateAffiliateCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAffiliateCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBANKCode(body: UpdateUserBANKCodeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberSettings/UpdateBANKCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBANKCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBANKCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBANKCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MemberSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param serviceType (optional) 
     * @param serviceTypeId (optional) 
     * @return Success
     */
    getMemberInfo(systemType: string, serviceType: string | undefined, serviceTypeId: string | undefined): Observable<GetMemberInfoOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/MemberSubscription/GetMemberInfo?";
        if (systemType === undefined || systemType === null)
            throw new Error("The parameter 'systemType' must be defined and cannot be null.");
        else
            url_ += "SystemType=" + encodeURIComponent("" + systemType) + "&";
        if (serviceType === null)
            throw new Error("The parameter 'serviceType' cannot be null.");
        else if (serviceType !== undefined)
            url_ += "ServiceType=" + encodeURIComponent("" + serviceType) + "&";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberInfoOutput>;
        }));
    }

    protected processGetMemberInfo(response: HttpResponseBase): Observable<GetMemberInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberInfoOutput>(null as any);
    }
}

@Injectable()
export class NotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactIds (optional) 
     * @param ascendingSorting (optional) 
     * @return Success
     */
    getNotes(contactIds: number[] | undefined, ascendingSorting: boolean | undefined): Observable<NoteInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/GetNotes?";
        if (contactIds === null)
            throw new Error("The parameter 'contactIds' cannot be null.");
        else if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "contactIds=" + encodeURIComponent("" + item) + "&"; });
        if (ascendingSorting === null)
            throw new Error("The parameter 'ascendingSorting' cannot be null.");
        else if (ascendingSorting !== undefined)
            url_ += "ascendingSorting=" + encodeURIComponent("" + ascendingSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoteInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoteInfoDto[]>;
        }));
    }

    protected processGetNotes(response: HttpResponseBase): Observable<NoteInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NoteInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoteInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNote(body: CreateNoteInput | undefined): Observable<CreateNoteOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/CreateNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateNoteOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateNoteOutput>;
        }));
    }

    protected processCreateNote(response: HttpResponseBase): Observable<CreateNoteOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateNoteOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateNoteOutput>(null as any);
    }

    /**
     * @return Success
     */
    deleteNote(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/DeleteNote?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNote(body: UpdateNoteInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/UpdateNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pinNote(body: PinNoteInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/PinNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPinNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPinNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPinNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unpinNote(body: UnpinNoteInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/UnpinNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpinNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpinNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnpinNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationsOutput>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(null as any);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getUserNotificationCount(state: UserNotificationState | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetUserNotificationCount?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetUserNotificationCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationSettingsOutput>;
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OfferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: GetAllInput | undefined): Observable<OfferDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OfferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OfferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDetails(testMode: boolean, campaignId: number): Observable<OfferDetailsDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetDetails?";
        if (testMode === undefined || testMode === null)
            throw new Error("The parameter 'testMode' must be defined and cannot be null.");
        else
            url_ += "TestMode=" + encodeURIComponent("" + testMode) + "&";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined and cannot be null.");
        else
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDetailsDto>;
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<OfferDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    getApplicationDetails(): Observable<GetApplicationDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetApplicationDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetApplicationDetailsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetApplicationDetailsOutput>;
        }));
    }

    protected processGetApplicationDetails(response: HttpResponseBase): Observable<GetApplicationDetailsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApplicationDetailsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationDetailsOutput>(null as any);
    }

    /**
     * @param campaignId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @return Success
     */
    getOffersStats(groupByPeriod: GroupByPeriod, campaignId: number | undefined, from: moment.Moment | undefined, to: moment.Moment | undefined): Observable<OfferApplicationGroup[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetOffersStats?";
        if (groupByPeriod === undefined || groupByPeriod === null)
            throw new Error("The parameter 'groupByPeriod' must be defined and cannot be null.");
        else
            url_ += "GroupByPeriod=" + encodeURIComponent("" + groupByPeriod) + "&";
        if (campaignId === null)
            throw new Error("The parameter 'campaignId' cannot be null.");
        else if (campaignId !== undefined)
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOffersStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOffersStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferApplicationGroup[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferApplicationGroup[]>;
        }));
    }

    protected processGetOffersStats(response: HttpResponseBase): Observable<OfferApplicationGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OfferApplicationGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferApplicationGroup[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitRequest(body: SubmitRequestInput | undefined): Observable<SubmitRequestOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/SubmitRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitRequestOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitRequestOutput>;
        }));
    }

    protected processSubmitRequest(response: HttpResponseBase): Observable<SubmitRequestOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitRequestOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitRequestOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitApplication(body: SubmitApplicationInput | undefined): Observable<SubmitApplicationOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/SubmitApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitApplicationOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitApplicationOutput>;
        }));
    }

    protected processSubmitApplication(response: HttpResponseBase): Observable<SubmitApplicationOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitApplicationOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitApplicationOutput>(null as any);
    }

    /**
     * @param applicationId (optional) 
     * @return Success
     */
    startFinalizeApplication(applicationId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/StartFinalizeApplication?";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartFinalizeApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartFinalizeApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStartFinalizeApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param applicationId (optional) 
     * @return Success
     */
    getFinalizeApplicationStatus(applicationId: number | undefined): Observable<FinalizeApplicationResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetFinalizeApplicationStatus?";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinalizeApplicationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinalizeApplicationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinalizeApplicationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinalizeApplicationResponse>;
        }));
    }

    protected processGetFinalizeApplicationStatus(response: HttpResponseBase): Observable<FinalizeApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinalizeApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FinalizeApplicationResponse>(null as any);
    }

    /**
     * @return Success
     */
    getMemberInfo(): Observable<GetMemberInfoResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberInfoResponse>;
        }));
    }

    protected processGetMemberInfo(response: HttpResponseBase): Observable<GetMemberInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberInfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberInfoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rank(body: RankRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/Rank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRank(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRank(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPostDeclineOffers(): Observable<OfferDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetPostDeclineOffers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostDeclineOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostDeclineOffers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDto[]>;
        }));
    }

    protected processGetPostDeclineOffers(response: HttpResponseBase): Observable<OfferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OfferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDto[]>(null as any);
    }
}

@Injectable()
export class OfferAnnouncementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAnnouncement(body: SendAnnouncementRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferAnnouncement/SendAnnouncement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAnnouncement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAnnouncement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendAnnouncement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OfferManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param fetchAll (optional) 
     * @return Success
     */
    pull(fetchAll: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/Pull?";
        if (fetchAll === null)
            throw new Error("The parameter 'fetchAll' cannot be null.");
        else if (fetchAll !== undefined)
            url_ += "fetchAll=" + encodeURIComponent("" + fetchAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPull(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPull(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPull(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getDetailsForEdit(campaignId: number): Observable<OfferDetailsForEditDto> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/GetDetailsForEdit?";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined and cannot be null.");
        else
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDetailsForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDetailsForEditDto>;
        }));
    }

    protected processGetDetailsForEdit(response: HttpResponseBase): Observable<OfferDetailsForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDetailsForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDetailsForEditDto>(null as any);
    }

    /**
     * @param campaignId (optional) 
     * @param body (optional) 
     * @return Success
     */
    extend(campaignId: number | undefined, body: ExtendOfferDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/Extend?";
        if (campaignId === null)
            throw new Error("The parameter 'campaignId' cannot be null.");
        else if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExtend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    setAttribute(offerAttribute: OfferAttributeType, value: string | undefined, body: OfferFilter): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/SetAttribute?";
        if (offerAttribute === undefined || offerAttribute === null)
            throw new Error("The parameter 'offerAttribute' must be defined and cannot be null.");
        else
            url_ += "offerAttribute=" + encodeURIComponent("" + offerAttribute) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSetAttribute(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    setFlag(offerFlag: OfferFlagType, value: boolean | undefined, body: OfferFilter): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/SetFlag?";
        if (offerFlag === undefined || offerFlag === null)
            throw new Error("The parameter 'offerFlag' must be defined and cannot be null.");
        else
            url_ += "offerFlag=" + encodeURIComponent("" + offerFlag) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFlag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFlag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSetFlag(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extendFromCSV(body: string | undefined): Observable<ExtendFromCSVOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/ExtendFromCSV";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendFromCSV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendFromCSV(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExtendFromCSVOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExtendFromCSVOutput>;
        }));
    }

    protected processExtendFromCSV(response: HttpResponseBase): Observable<ExtendFromCSVOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExtendFromCSVOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtendFromCSVOutput>(null as any);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @param hasUserAccount (optional) 
     * @param exceptUserIds (optional) 
     * @param excludeSubContacts (optional) 
     * @param fullAccess (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | undefined, topCount: number | undefined, hasUserAccount: boolean | undefined, exceptUserIds: number[] | undefined, excludeSubContacts: boolean | undefined, fullAccess: boolean | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetAllByPhrase?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (hasUserAccount === null)
            throw new Error("The parameter 'hasUserAccount' cannot be null.");
        else if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&";
        if (exceptUserIds === null)
            throw new Error("The parameter 'exceptUserIds' cannot be null.");
        else if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts === null)
            throw new Error("The parameter 'excludeSubContacts' cannot be null.");
        else if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&";
        if (fullAccess === null)
            throw new Error("The parameter 'fullAccess' cannot be null.");
        else if (fullAccess !== undefined)
            url_ += "FullAccess=" + encodeURIComponent("" + fullAccess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityContactInfo[]>;
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHistory(id: number | undefined): Observable<OrderHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetHistory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderHistoryInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderHistoryInfo[]>;
        }));
    }

    protected processGetHistory(response: HttpResponseBase): Observable<OrderHistoryInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderHistoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderHistoryInfo[]>(null as any);
    }

    /**
     * @param stageIds (optional) 
     * @return Success
     */
    getStageChecklistPoints(orderId: number, stageIds: number[] | undefined): Observable<StageChecklistPointInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetStageChecklistPoints?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (stageIds === null)
            throw new Error("The parameter 'stageIds' cannot be null.");
        else if (stageIds !== undefined)
            stageIds && stageIds.forEach(item => { url_ += "StageIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageChecklistPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageChecklistPoints(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StageChecklistPointInfoOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StageChecklistPointInfoOutput[]>;
        }));
    }

    protected processGetStageChecklistPoints(response: HttpResponseBase): Observable<StageChecklistPointInfoOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageChecklistPointInfoOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageChecklistPointInfoOutput[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setAmount(body: SetAmountInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/SetAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStage(body: UpdateOrderStageInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStagePoint(body: UpdateOrderStagePointInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateStagePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStagePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStagePoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStagePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAffiliateContact(body: UpdateOrderAffiliateContactInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateAffiliateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAffiliateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    process(body: ProcessOrderInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Process";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancel(body: CancelOrderInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param forceDelete (optional) 
     * @return Success
     */
    delete(id: number | undefined, forceDelete: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (forceDelete === null)
            throw new Error("The parameter 'forceDelete' cannot be null.");
        else if (forceDelete !== undefined)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OrderSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getSubscriptionHistory(contactId: number | undefined): Observable<OrderSubscriptionDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/GetSubscriptionHistory?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderSubscriptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderSubscriptionDto[]>;
        }));
    }

    protected processGetSubscriptionHistory(response: HttpResponseBase): Observable<OrderSubscriptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderSubscriptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderSubscriptionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOrderSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePeriod(body: UpdateOrderSubscriptionPeriodInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/UpdatePeriod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancel(body: CancelOrderSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelAll(body: CancelAllInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/CancelAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param isCaptured (optional) 
     * @return Success
     */
    completeManualSubscriptionPayment(trackingCode: string, isCaptured: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/CompleteManualSubscriptionPayment?";
        if (trackingCode === undefined || trackingCode === null)
            throw new Error("The parameter 'trackingCode' must be defined and cannot be null.");
        else
            url_ += "trackingCode=" + encodeURIComponent("" + trackingCode) + "&";
        if (isCaptured === null)
            throw new Error("The parameter 'isCaptured' cannot be null.");
        else if (isCaptured !== undefined)
            url_ += "isCaptured=" + encodeURIComponent("" + isCaptured) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteManualSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteManualSubscriptionPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompleteManualSubscriptionPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OrganizationContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getOrganizationContactInfo(contactId: number | undefined): Observable<OrganizationContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/GetOrganizationContactInfo?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationContactInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationContactInfoDto>;
        }));
    }

    protected processGetOrganizationContactInfo(response: HttpResponseBase): Observable<OrganizationContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationContactInfoDto>(null as any);
    }

    /**
     * @param searchString (optional) 
     * @param topCount (optional) 
     * @return Success
     */
    getOrganizations(searchString: string | undefined, topCount: number | undefined): Observable<OrganizationShortInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/GetOrganizations?";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "topCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationShortInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationShortInfo[]>;
        }));
    }

    protected processGetOrganizations(response: HttpResponseBase): Observable<OrganizationShortInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationShortInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationShortInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganization(body: CreateOrganizationInput | undefined): Observable<CreateOrganizationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/CreateOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrganizationOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrganizationOutput>;
        }));
    }

    protected processCreateOrganization(response: HttpResponseBase): Observable<CreateOrganizationOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrganizationOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrganizationOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrgUnitForOrganization(body: CreateOrgUnitForOrganizationInput | undefined): Observable<CreateOrgUnitForOrganizationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/CreateOrgUnitForOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrgUnitForOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrgUnitForOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrgUnitForOrganizationOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrgUnitForOrganizationOutput>;
        }));
    }

    protected processCreateOrgUnitForOrganization(response: HttpResponseBase): Observable<CreateOrgUnitForOrganizationOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrgUnitForOrganizationOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrgUnitForOrganizationOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationInfo(body: UpdateOrganizationInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/UpdateOrganizationInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOrganizationInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete(id: number, currentPersonOrgRelationId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (currentPersonOrgRelationId === undefined || currentPersonOrgRelationId === null)
            throw new Error("The parameter 'currentPersonOrgRelationId' must be defined and cannot be null.");
        else
            url_ += "CurrentPersonOrgRelationId=" + encodeURIComponent("" + currentPersonOrgRelationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    mergeOrganizations(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/MergeOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeOrganizations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMergeOrganizations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(null as any);
    }
}

@Injectable()
export class PackageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfPackageDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Package/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfPackageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfPackageDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfPackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfPackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPackageDto>(null as any);
    }

    /**
     * @param module (optional) 
     * @return Success
     */
    getPackagesConfig(module: ModuleType | undefined): Observable<GetPackagesConfigOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Package/GetPackagesConfig?";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "Module=" + encodeURIComponent("" + module) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackagesConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackagesConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPackagesConfigOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPackagesConfigOutput>;
        }));
    }

    protected processGetPackagesConfig(response: HttpResponseBase): Observable<GetPackagesConfigOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPackagesConfigOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPackagesConfigOutput>(null as any);
    }
}

@Injectable()
export class PartnerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PartnerInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PartnerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartnerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateType(body: UpdatePartnerTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/UpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkUpdateType(body: BulkUpdatePartnerTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/BulkUpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUpdateType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @param hasUserAccount (optional) 
     * @param exceptUserIds (optional) 
     * @param excludeSubContacts (optional) 
     * @param fullAccess (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | undefined, topCount: number | undefined, hasUserAccount: boolean | undefined, exceptUserIds: number[] | undefined, excludeSubContacts: boolean | undefined, fullAccess: boolean | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/GetAllByPhrase?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        if (hasUserAccount === null)
            throw new Error("The parameter 'hasUserAccount' cannot be null.");
        else if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&";
        if (exceptUserIds === null)
            throw new Error("The parameter 'exceptUserIds' cannot be null.");
        else if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts === null)
            throw new Error("The parameter 'excludeSubContacts' cannot be null.");
        else if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&";
        if (fullAccess === null)
            throw new Error("The parameter 'fullAccess' cannot be null.");
        else if (fullAccess !== undefined)
            url_ += "FullAccess=" + encodeURIComponent("" + fullAccess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityContactInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityContactInfo[]>;
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityContactInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(null as any);
    }
}

@Injectable()
export class PartnerTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rename(body: RenamePartnerTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PartnerType/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param moveToTypeId (optional) 
     * @param deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number | undefined, moveToTypeId: number | undefined, deleteAllReferences: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PartnerType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moveToTypeId === null)
            throw new Error("The parameter 'moveToTypeId' cannot be null.");
        else if (moveToTypeId !== undefined)
            url_ += "MoveToTypeId=" + encodeURIComponent("" + moveToTypeId) + "&";
        if (deleteAllReferences === null)
            throw new Error("The parameter 'deleteAllReferences' cannot be null.");
        else if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getPayments(contactId: number | undefined): Observable<GetPaymentsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPayments?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPaymentsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPaymentsDto>;
        }));
    }

    protected processGetPayments(response: HttpResponseBase): Observable<GetPaymentsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPaymentsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPaymentsDto>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getPaymentMethods(contactId: number | undefined): Observable<PaymentMethodInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPaymentMethods?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMethodInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMethodInfo[]>;
        }));
    }

    protected processGetPaymentMethods(response: HttpResponseBase): Observable<PaymentMethodInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentMethodInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodInfo[]>(null as any);
    }

    /**
     * @return Success
     */
    getTransactionTypes(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetTransactionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetTransactionTypes(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @return Success
     */
    getPaymentProviders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPaymentProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetPaymentProviders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeIrrelevant (optional) 
     * @return Success
     */
    getAllPermissions(includeIrrelevant: boolean | undefined): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Permission/GetAllPermissions?";
        if (includeIrrelevant === null)
            throw new Error("The parameter 'includeIrrelevant' cannot be null.");
        else if (includeIrrelevant !== undefined)
            url_ += "includeIrrelevant=" + encodeURIComponent("" + includeIrrelevant) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(null as any);
    }
}

@Injectable()
export class PersonContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePersonInfo(body: UpdatePersonInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePersonInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePersonBANKCode(body: UpdatePersonBANKCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonBANKCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonBANKCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonBANKCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePersonBANKCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePersonName(body: UpdatePersonNameInput | undefined): Observable<UpdatePersonNameOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePersonNameOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePersonNameOutput>;
        }));
    }

    protected processUpdatePersonName(response: HttpResponseBase): Observable<UpdatePersonNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePersonNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdatePersonNameOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUserForContact(body: CreateUserForContactInput | undefined): Observable<CreateUserForContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/CreateUserForContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserForContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUserForContactOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUserForContactOutput>;
        }));
    }

    protected processCreateUserForContact(response: HttpResponseBase): Observable<CreateUserForContactOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUserForContactOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUserForContactOutput>(null as any);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    getPersonHistory(personId: number | undefined): Observable<PersonHistoryDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/GetPersonHistory?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonHistoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonHistoryDto[]>;
        }));
    }

    protected processGetPersonHistory(response: HttpResponseBase): Observable<PersonHistoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PersonHistoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonHistoryDto[]>(null as any);
    }
}

@Injectable()
export class PersonOrgRelationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePersonOrgRelationInput | undefined): Observable<CreatePersonOrgRelationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreatePersonOrgRelationOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreatePersonOrgRelationOutput>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreatePersonOrgRelationOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatePersonOrgRelationOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreatePersonOrgRelationOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePersonOrgRelationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    setPrimaryOrgRelation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/SetPrimaryOrgRelation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPrimaryOrgRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPrimaryOrgRelation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPrimaryOrgRelation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PipelineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPipelineDefinition(id: number | undefined): Observable<PipelineDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelineDefinition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPipelineDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPipelineDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PipelineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PipelineDto>;
        }));
    }

    protected processGetPipelineDefinition(response: HttpResponseBase): Observable<PipelineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PipelineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PipelineDto>(null as any);
    }

    /**
     * @param purposeId (optional) 
     * @param contactGroupId (optional) 
     * @return Success
     */
    getPipelineDefinitions(purposeId: string | undefined, contactGroupId: string | undefined): Observable<PipelineDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelineDefinitions?";
        if (purposeId === null)
            throw new Error("The parameter 'purposeId' cannot be null.");
        else if (purposeId !== undefined)
            url_ += "purposeId=" + encodeURIComponent("" + purposeId) + "&";
        if (contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' cannot be null.");
        else if (contactGroupId !== undefined)
            url_ += "contactGroupId=" + encodeURIComponent("" + contactGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPipelineDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPipelineDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PipelineDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PipelineDto[]>;
        }));
    }

    protected processGetPipelineDefinitions(response: HttpResponseBase): Observable<PipelineDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PipelineDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PipelineDto[]>(null as any);
    }

    /**
     * @param pipelineId (optional) 
     * @param entityId (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    updateEntitySortOrder(pipelineId: number | undefined, entityId: number | undefined, sortOrder: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/UpdateEntitySortOrder?";
        if (pipelineId === null)
            throw new Error("The parameter 'pipelineId' cannot be null.");
        else if (pipelineId !== undefined)
            url_ += "pipelineId=" + encodeURIComponent("" + pipelineId) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEntitySortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntitySortOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEntitySortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePipelineSortOrder(body: UpdateSortOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/UpdatePipelineSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePipelineSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePipelineSortOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePipelineSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PipelineCreateInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rename(body: PipelineRenameInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductInfo(id: number | undefined): Observable<ProductInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetProductInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductInfo>;
        }));
    }

    protected processGetProductInfo(response: HttpResponseBase): Observable<ProductInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductInfo>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getProducts(type: ProductType | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetProducts?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto[]>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param searchPhrase (optional) 
     * @param code (optional) 
     * @param topCount (optional) 
     * @return Success
     */
    getProductsByPhrase(contactId: number | undefined, searchPhrase: string | undefined, code: string | undefined, topCount: number | undefined): Observable<ProductPaymentOptionsInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetProductsByPhrase?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPaymentOptionsInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPaymentOptionsInfo[]>;
        }));
    }

    protected processGetProductsByPhrase(response: HttpResponseBase): Observable<ProductPaymentOptionsInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductPaymentOptionsInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPaymentOptionsInfo[]>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param searchPhrase (optional) 
     * @param code (optional) 
     * @param topCount (optional) 
     * @return Success
     */
    getInvoiceProductsByPhrase(contactId: number | undefined, searchPhrase: string | undefined, code: string | undefined, topCount: number | undefined): Observable<ProductShortInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetInvoiceProductsByPhrase?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceProductsByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceProductsByPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductShortInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductShortInfo[]>;
        }));
    }

    protected processGetInvoiceProductsByPhrase(response: HttpResponseBase): Observable<ProductShortInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductShortInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductShortInfo[]>(null as any);
    }

    /**
     * @return Success
     */
    getSubscriptionProductsByGroupName(groupName: string): Observable<ProductInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetSubscriptionProductsByGroupName?";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined and cannot be null.");
        else
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionProductsByGroupName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionProductsByGroupName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductInfo[]>;
        }));
    }

    protected processGetSubscriptionProductsByGroupName(response: HttpResponseBase): Observable<ProductInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: CreateProductInput | undefined): Observable<CreateProductOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/CreateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateProductOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateProductOutput>;
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<CreateProductOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateProductOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateProductOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProduct(body: UpdateProductInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/UpdateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setProductImage(body: SetProductImageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/SetProductImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProductImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetProductImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    synchronizeSubscriptions(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/SynchronizeSubscriptions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchronizeSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronizeSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSynchronizeSubscriptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProduct(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/DeleteProduct?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductGroups(body: UpdateProductGroupInput[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/UpdateProductGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProductGroups(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProductGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProductGroups(): Observable<ProductGroupInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProductGroup/GetProductGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductGroupInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductGroupInfo[]>;
        }));
    }

    protected processGetProductGroups(response: HttpResponseBase): Observable<ProductGroupInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductGroupInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductGroupInfo[]>(null as any);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<GetCurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentUserProfileEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentUserProfileEditDto>;
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<GetCurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentUserProfileEditDto>(null as any);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(null as any);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    clearProfilePicture(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ClearProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    downloadPicture(body: DownloadPictureInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/DownloadPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDownloadPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPasswordComplexitySettingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPasswordComplexitySettingOutput>;
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(null as any);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getProfilePictureByUserName(username: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePictureByUserName?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePicture(userId: number | undefined, tenantId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetFriendProfilePicture?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePictureByUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMonthlyGoal(body: UpdateMonthlyGoalInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateMonthlyGoal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMonthlyGoal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMonthlyGoal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateMonthlyGoal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getEmailSettings(): Observable<UserEmailSettings> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserEmailSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserEmailSettings>;
        }));
    }

    protected processGetEmailSettings(response: HttpResponseBase): Observable<UserEmailSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEmailSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEmailSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmailSettings(body: UserEmailSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProfileContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getContactBase(): Observable<ProfileContactBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileContact/GetContactBase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactBase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactBase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileContactBaseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileContactBaseDto>;
        }));
    }

    protected processGetContactBase(response: HttpResponseBase): Observable<ProfileContactBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileContactBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileContactBaseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactBase(body: ProfileContactBaseDto | undefined): Observable<ProfileContactBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileContact/UpdateContactBase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactBase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactBase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileContactBaseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileContactBaseDto>;
        }));
    }

    protected processUpdateContactBase(response: HttpResponseBase): Observable<ProfileContactBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileContactBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileContactBaseDto>(null as any);
    }
}

@Injectable()
export class ProfileLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLinks(): Observable<LinkDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/GetLinks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LinkDto[]>;
        }));
    }

    protected processGetLinks(response: HttpResponseBase): Observable<LinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createLink(body: CreateLinkInput | undefined): Observable<CreateLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/CreateLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateLinkOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateLinkOutput>;
        }));
    }

    protected processCreateLink(response: HttpResponseBase): Observable<CreateLinkOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateLinkOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLinkOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLink(body: UpdateLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/UpdateLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    deleteLink(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/DeleteLink?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLinks(body: UpdateLinksInput | undefined): Observable<LinkDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/UpdateLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LinkDto[]>;
        }));
    }

    protected processUpdateLinks(response: HttpResponseBase): Observable<LinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkDto[]>(null as any);
    }
}

@Injectable()
export class ProfilePersonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPersonInfo(): Observable<PersonInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePerson/GetPersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonInfo>;
        }));
    }

    protected processGetPersonInfo(response: HttpResponseBase): Observable<PersonInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePersonInfo(body: PersonInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePerson/UpdatePersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePersonInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getProfileSummary(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePerson/GetProfileSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfileSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfileSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetProfileSummary(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfileSummary(input: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePerson/UpdateProfileSummary?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfileSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfileSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProfileSummary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProfilePhotoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPhotos(): Observable<ProfilePhotoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/GetPhotos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhotos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhotos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilePhotoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilePhotoDto[]>;
        }));
    }

    protected processGetPhotos(response: HttpResponseBase): Observable<ProfilePhotoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProfilePhotoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilePhotoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPhoto(body: CreateProfilePhotoInput | undefined): Observable<ProfilePhotoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/CreatePhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilePhotoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilePhotoDto>;
        }));
    }

    protected processCreatePhoto(response: HttpResponseBase): Observable<ProfilePhotoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilePhotoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilePhotoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePhoto(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/DeletePhoto?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getFilestackSettings(): Observable<FilestackSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/GetFilestackSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilestackSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilestackSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilestackSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilestackSettingsDto>;
        }));
    }

    protected processGetFilestackSettings(response: HttpResponseBase): Observable<FilestackSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilestackSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FilestackSettingsDto>(null as any);
    }
}

@Injectable()
export class ProfilePublishServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getPublicProfileInfo(name: string | undefined): Observable<PublishedProfileDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/GetPublicProfileInfo?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PublishedProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PublishedProfileDto>;
        }));
    }

    protected processGetPublicProfileInfo(response: HttpResponseBase): Observable<PublishedProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PublishedProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublishedProfileDto>(null as any);
    }

    /**
     * @return Success
     */
    getCurrentPublishedProfile(): Observable<PublishedProfileBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/GetCurrentPublishedProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentPublishedProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentPublishedProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PublishedProfileBaseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PublishedProfileBaseDto>;
        }));
    }

    protected processGetCurrentPublishedProfile(response: HttpResponseBase): Observable<PublishedProfileBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PublishedProfileBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublishedProfileBaseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkNameIsAvailable(body: NameInput | undefined): Observable<NameIsAvailableDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/CheckNameIsAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckNameIsAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckNameIsAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameIsAvailableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameIsAvailableDto>;
        }));
    }

    protected processCheckNameIsAvailable(response: HttpResponseBase): Observable<NameIsAvailableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NameIsAvailableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameIsAvailableDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishProfile(body: PublishProfileInput | undefined): Observable<PublishedProfileBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/PublishProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PublishedProfileBaseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PublishedProfileBaseDto>;
        }));
    }

    protected processPublishProfile(response: HttpResponseBase): Observable<PublishedProfileBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PublishedProfileBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublishedProfileBaseDto>(null as any);
    }
}

@Injectable()
export class PropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPropertyDetails(id: number | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetPropertyDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyDto>;
        }));
    }

    protected processGetPropertyDetails(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPropertyAcquisitionDetails(id: number | undefined): Observable<PropertyAcquisitionDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetPropertyAcquisitionDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyAcquisitionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyAcquisitionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyAcquisitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyAcquisitionDto>;
        }));
    }

    protected processGetPropertyAcquisitionDetails(response: HttpResponseBase): Observable<PropertyAcquisitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyAcquisitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyAcquisitionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPropertyInvestmentDetails(id: number | undefined): Observable<PropertyInvestmentDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetPropertyInvestmentDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyInvestmentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyInvestmentDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyInvestmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyInvestmentDto>;
        }));
    }

    protected processGetPropertyInvestmentDetails(response: HttpResponseBase): Observable<PropertyInvestmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyInvestmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyInvestmentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePropertyDetails(body: PropertyBaseDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/UpdatePropertyDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePropertyDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePropertyAcquisitionDetails(body: PropertyAcquisitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/UpdatePropertyAcquisitionDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyAcquisitionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyAcquisitionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePropertyAcquisitionDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePropertyInvestmentDetails(body: PropertyInvestmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/UpdatePropertyInvestmentDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyInvestmentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyInvestmentDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePropertyInvestmentDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param propertyId (optional) 
     * @return Success
     */
    getDeals(propertyId: number | undefined): Observable<PropertyDealInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetDeals?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyDealInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyDealInfo[]>;
        }));
    }

    protected processGetDeals(response: HttpResponseBase): Observable<PropertyDealInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyDealInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDealInfo[]>(null as any);
    }

    /**
     * @param propertyId (optional) 
     * @return Success
     */
    generateInvestmentPdf(propertyId: number | undefined): Observable<GetUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GenerateInvestmentPdf?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateInvestmentPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateInvestmentPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUrlOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUrlOutput>;
        }));
    }

    protected processGenerateInvestmentPdf(response: HttpResponseBase): Observable<GetUrlOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUrlOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUrlOutput>(null as any);
    }
}

@Injectable()
export class QuestionnaireServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param moduleName (optional) 
     * @param identifier (optional) 
     * @return Success
     */
    get(moduleName: string | undefined, identifier: string | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/Get?";
        if (moduleName === null)
            throw new Error("The parameter 'moduleName' cannot be null.");
        else if (moduleName !== undefined)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&";
        if (identifier === null)
            throw new Error("The parameter 'identifier' cannot be null.");
        else if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionnaireDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionnaireDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionnaireDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(null as any);
    }

    /**
     * @param moduleName (optional) 
     * @param identifier (optional) 
     * @return Success
     */
    getInternal(moduleName: string | undefined, identifier: string | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/GetInternal?";
        if (moduleName === null)
            throw new Error("The parameter 'moduleName' cannot be null.");
        else if (moduleName !== undefined)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&";
        if (identifier === null)
            throw new Error("The parameter 'identifier' cannot be null.");
        else if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionnaireDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionnaireDto>;
        }));
    }

    protected processGetInternal(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionnaireDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitResponse(body: QuestionnaireResponseDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitResponseInternal(body: QuestionnaireResponseDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitResponseInternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitResponseInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitResponseInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitResponseInternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitQuestionsAndAnswers(body: SubmitQuestionsAndAnswersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitQuestionsAndAnswers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitQuestionsAndAnswers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitQuestionsAndAnswers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitQuestionsAndAnswers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RapidServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClients(): Observable<GetRapidClientsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetClients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRapidClientsOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRapidClientsOutput[]>;
        }));
    }

    protected processGetClients(response: HttpResponseBase): Observable<GetRapidClientsOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetRapidClientsOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRapidClientsOutput[]>(null as any);
    }

    /**
     * @return Success
     */
    getTokenForCurrentUser(): Observable<GetRapidTokenOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetTokenForCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTokenForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTokenForCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRapidTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRapidTokenOutput>;
        }));
    }

    protected processGetTokenForCurrentUser(response: HttpResponseBase): Observable<GetRapidTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRapidTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRapidTokenOutput>(null as any);
    }

    /**
     * @param contactIds (optional) 
     * @return Success
     */
    getTokenForContacts(contactIds: number[] | undefined): Observable<GetRapidTokenOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetTokenForContacts?";
        if (contactIds === null)
            throw new Error("The parameter 'contactIds' cannot be null.");
        else if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "contactIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTokenForContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTokenForContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRapidTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRapidTokenOutput>;
        }));
    }

    protected processGetTokenForContacts(response: HttpResponseBase): Observable<GetRapidTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRapidTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRapidTokenOutput>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getKonnectiveData(contactId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetKonnectiveData?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKonnectiveData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKonnectiveData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetKonnectiveData(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getRefundsAndCancellationsForCurrentUser(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetRefundsAndCancellationsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetRefundsAndCancellationsForCurrentUser?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundsAndCancellationsForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundsAndCancellationsForCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRefundsAndCancellationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRefundsAndCancellationsOutput>;
        }));
    }

    protected processGetRefundsAndCancellationsForCurrentUser(response: HttpResponseBase): Observable<GetRefundsAndCancellationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundsAndCancellationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundsAndCancellationsOutput>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getRefundsAndCancellationsForContact(contactId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetRefundsAndCancellationsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetRefundsAndCancellationsForContact?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundsAndCancellationsForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundsAndCancellationsForContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRefundsAndCancellationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRefundsAndCancellationsOutput>;
        }));
    }

    protected processGetRefundsAndCancellationsForContact(response: HttpResponseBase): Observable<GetRefundsAndCancellationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundsAndCancellationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundsAndCancellationsOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactAgents(body: CreateContactAgentsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/CreateContactAgents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactAgents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactAgents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateContactAgents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sourceOrganizationUnitIds (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getSubscriberDailyStatsReport(sourceOrganizationUnitIds: number[] | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<SubscriberDailyStatsReportInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Report/GetSubscriberDailyStatsReport?";
        if (sourceOrganizationUnitIds === null)
            throw new Error("The parameter 'sourceOrganizationUnitIds' cannot be null.");
        else if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriberDailyStatsReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriberDailyStatsReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriberDailyStatsReportInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriberDailyStatsReportInfo[]>;
        }));
    }

    protected processGetSubscriberDailyStatsReport(response: HttpResponseBase): Observable<SubscriberDailyStatsReportInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriberDailyStatsReportInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriberDailyStatsReportInfo[]>(null as any);
    }
}

@Injectable()
export class ReportingCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getReportingAndCoACategorization(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CFO/ReportingCategory/GetReportingAndCoACategorization?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportingAndCoACategorization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportingAndCoACategorization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetReportingAndCoACategorization(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getUrl(instanceType: InstanceType | undefined, instanceId: number | undefined, id: string | undefined): Observable<GetReportUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GetUrl?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetReportUrlOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetReportUrlOutput>;
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetReportUrlOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportUrlOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportUrlOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    generate(instanceType: InstanceType | undefined, instanceId: number | undefined, body: GenerateInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/Generate?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    generateBalanceSheetReport(instanceType: InstanceType | undefined, instanceId: number | undefined, body: GenerateBalanceSheetReportInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GenerateBalanceSheetReport?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBalanceSheetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBalanceSheetReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateBalanceSheetReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    generateIncomeStatementByEntityReport(instanceType: InstanceType | undefined, instanceId: number | undefined, body: GenerateIncomeStatementByEntityReportInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GenerateIncomeStatementByEntityReport?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateIncomeStatementByEntityReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateIncomeStatementByEntityReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateIncomeStatementByEntityReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param id (optional) 
     * @return Success
     */
    delete(instanceType: InstanceType | undefined, instanceId: number | undefined, id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/Delete?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendReportNotification(instanceType: InstanceType | undefined, instanceId: number | undefined, body: SendReportNotificationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/SendReportNotification?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReportNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReportNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendReportNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRoles(body: GetRolesInput | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfRoleListDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SalesTalkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLead(leadId: number): Observable<SalesTalkLeadInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/SalesTalk/GetLead?";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined and cannot be null.");
        else
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesTalkLeadInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesTalkLeadInfo>;
        }));
    }

    protected processGetLead(response: HttpResponseBase): Observable<SalesTalkLeadInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesTalkLeadInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesTalkLeadInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLead(body: SalesTalkUpdateLeadInfo | undefined): Observable<SalesTalkUpdateLeadOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/SalesTalk/UpdateLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesTalkUpdateLeadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesTalkUpdateLeadOutput>;
        }));
    }

    protected processUpdateLead(response: HttpResponseBase): Observable<SalesTalkUpdateLeadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesTalkUpdateLeadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesTalkUpdateLeadOutput>(null as any);
    }
}

@Injectable()
export class SecurityManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param bankAccountId (optional) 
     * @param userId (optional) 
     * @param body (optional) 
     * @return Success
     */
    grantBankAccountPermissions(instanceType: InstanceType | undefined, instanceId: number | undefined, bankAccountId: number | undefined, userId: number | undefined, body: Permissions | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/GrantBankAccountPermissions?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' cannot be null.");
        else if (bankAccountId !== undefined)
            url_ += "bankAccountId=" + encodeURIComponent("" + bankAccountId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantBankAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantBankAccountPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGrantBankAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param userId (optional) 
     * @param body (optional) 
     * @return Success
     */
    revokeBankAccountPermissions(instanceType: InstanceType | undefined, instanceId: number | undefined, userId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/RevokeBankAccountPermissions?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeBankAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeBankAccountPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRevokeBankAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getBankAccountAssignedUsers(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<BankAccountUsers[]> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/GetBankAccountAssignedUsers?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccountAssignedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccountAssignedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountUsers[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountUsers[]>;
        }));
    }

    protected processGetBankAccountAssignedUsers(response: HttpResponseBase): Observable<BankAccountUsers[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountUsers.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountUsers[]>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateUserSignInTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateUserSignInTokenOutput>;
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(null as any);
    }

    /**
     * @return Success
     */
    authTest(): Observable<AuthTestOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/AuthTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthTestOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthTestOutput>;
        }));
    }

    protected processAuthTest(response: HttpResponseBase): Observable<AuthTestOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthTestOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTestOutput>(null as any);
    }
}

@Injectable()
export class StageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStage(body: CreateStageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/CreateStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renameStage(body: RenameStageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/RenameStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameStage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenameStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeStages(body: MergeStagesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/MergeStages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeStages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMergeStages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStageSortOrder(body: UpdateSortOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/UpdateStageSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStageSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStageSortOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStageSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class StageChecklistServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param stageId (optional) 
     * @return Success
     */
    getPoints(stageId: number | undefined): Observable<StageChecklistPointDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/GetPoints?";
        if (stageId === null)
            throw new Error("The parameter 'stageId' cannot be null.");
        else if (stageId !== undefined)
            url_ += "stageId=" + encodeURIComponent("" + stageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoints(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StageChecklistPointDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StageChecklistPointDto[]>;
        }));
    }

    protected processGetPoints(response: HttpResponseBase): Observable<StageChecklistPointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageChecklistPointDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageChecklistPointDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPoint(body: CreateStageChecklistPointInput | undefined): Observable<CreatePointInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/CreatePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreatePointInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreatePointInfoOutput>;
        }));
    }

    protected processCreatePoint(response: HttpResponseBase): Observable<CreatePointInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatePointInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreatePointInfoOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePoint(body: RenameStageChecklistPointInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/RenamePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenamePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePointSortOrder(body: UpdateStageChecklistPointSortOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/UpdatePointSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePointSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePointSortOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePointSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    deletePoint(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/DeletePoint?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    setupSyncUserApplication(instanceType: InstanceType | undefined, instanceId: number | undefined, body: SetupSyncUserApplicationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SetupSyncUserApplication?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupSyncUserApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupSyncUserApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetupSyncUserApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    requestConnection(instanceType: InstanceType | undefined, instanceId: number | undefined, body: RequestConnectionInput | undefined): Observable<RequestConnectionOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/RequestConnection?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestConnection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestConnectionOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestConnectionOutput>;
        }));
    }

    protected processRequestConnection(response: HttpResponseBase): Observable<RequestConnectionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestConnectionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestConnectionOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param forcedSync (optional) 
     * @param syncType (optional) 
     * @return Success
     */
    syncAllAccounts(instanceType: InstanceType | undefined, instanceId: number | undefined, forcedSync: boolean | undefined, syncType: string | undefined): Observable<SyncAllAccountsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SyncAllAccounts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (forcedSync === null)
            throw new Error("The parameter 'forcedSync' cannot be null.");
        else if (forcedSync !== undefined)
            url_ += "forcedSync=" + encodeURIComponent("" + forcedSync) + "&";
        if (syncType === null)
            throw new Error("The parameter 'syncType' cannot be null.");
        else if (syncType !== undefined)
            url_ += "syncType=" + encodeURIComponent("" + syncType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SyncAllAccountsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SyncAllAccountsOutput>;
        }));
    }

    protected processSyncAllAccounts(response: HttpResponseBase): Observable<SyncAllAccountsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SyncAllAccountsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAllAccountsOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param syncAccountId (optional) 
     * @param fullResync (optional) 
     * @return Success
     */
    syncAccount(instanceType: InstanceType | undefined, instanceId: number | undefined, syncAccountId: number | undefined, fullResync: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SyncAccount?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (syncAccountId === null)
            throw new Error("The parameter 'syncAccountId' cannot be null.");
        else if (syncAccountId !== undefined)
            url_ += "syncAccountId=" + encodeURIComponent("" + syncAccountId) + "&";
        if (fullResync === null)
            throw new Error("The parameter 'fullResync' cannot be null.");
        else if (fullResync !== undefined)
            url_ += "fullResync=" + encodeURIComponent("" + fullResync) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSyncAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param fullResync (optional) 
     * @param body (optional) 
     * @return Success
     */
    requestSyncForAccounts(instanceType: InstanceType | undefined, instanceId: number | undefined, fullResync: boolean | undefined, body: number[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/RequestSyncForAccounts?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (fullResync === null)
            throw new Error("The parameter 'fullResync' cannot be null.");
        else if (fullResync !== undefined)
            url_ += "fullResync=" + encodeURIComponent("" + fullResync) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestSyncForAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestSyncForAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRequestSyncForAccounts(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getSyncProgress(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<SyncProgressOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/GetSyncProgress?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSyncProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSyncProgress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SyncProgressOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SyncProgressOutput>;
        }));
    }

    protected processGetSyncProgress(response: HttpResponseBase): Observable<SyncProgressOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SyncProgressOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncProgressOutput>(null as any);
    }
}

@Injectable()
export class SyncAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param syncTypeId (optional) 
     * @return Success
     */
    getActive(instanceType: InstanceType | undefined, instanceId: number | undefined, syncTypeId: string | undefined): Observable<SyncAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/GetActive?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (syncTypeId === null)
            throw new Error("The parameter 'syncTypeId' cannot be null.");
        else if (syncTypeId !== undefined)
            url_ += "syncTypeId=" + encodeURIComponent("" + syncTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SyncAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SyncAccountDto[]>;
        }));
    }

    protected processGetActive(response: HttpResponseBase): Observable<SyncAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SyncAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAccountDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(instanceType: InstanceType | undefined, instanceId: number | undefined, body: CreateSyncAccountInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Create?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    rename(instanceType: InstanceType | undefined, instanceId: number | undefined, body: RenameSyncAccountInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Rename?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeAutoSyncTime(instanceType: InstanceType | undefined, instanceId: number | undefined, body: ChangeAutoSyncInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/ChangeAutoSyncTime?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAutoSyncTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAutoSyncTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeAutoSyncTime(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param syncAccountId (optional) 
     * @return Success
     */
    delete(instanceType: InstanceType | undefined, instanceId: number | undefined, syncAccountId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Delete?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (syncAccountId === null)
            throw new Error("The parameter 'syncAccountId' cannot be null.");
        else if (syncAccountId !== undefined)
            url_ += "syncAccountId=" + encodeURIComponent("" + syncAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    createIsAllowed(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/CreateIsAllowed?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIsAllowed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIsAllowed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateIsAllowed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | undefined, creationDateStart: moment.Moment | undefined, creationDateEnd: moment.Moment | undefined, editionId: number | undefined, editionIdSpecified: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (creationDateStart === null)
            throw new Error("The parameter 'creationDateStart' cannot be null.");
        else if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toISOString() : "") + "&";
        if (creationDateEnd === null)
            throw new Error("The parameter 'creationDateEnd' cannot be null.");
        else if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toISOString() : "") + "&";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTenantListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTenantListDto>;
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantEditDto>;
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTenantFeaturesEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTenantFeaturesEditOutput>;
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantCRMIntegrationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSalesTalkSettings(): Observable<SalesTalkSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantCRMIntegrationSettings/GetSalesTalkSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesTalkSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesTalkSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesTalkSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesTalkSettings>;
        }));
    }

    protected processGetSalesTalkSettings(response: HttpResponseBase): Observable<SalesTalkSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesTalkSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesTalkSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSalesTalkSettings(body: SalesTalkSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantCRMIntegrationSettings/UpdateSalesTalkSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSalesTalkSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSalesTalkSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSalesTalkSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCustomCss(body: CustomCssType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearCustomPrivacyPolicyDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomPrivacyPolicyDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomPrivacyPolicyDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomPrivacyPolicyDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomPrivacyPolicyDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearCustomToSDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomToSDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomToSDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomToSDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomToSDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearFavicons(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearFavicons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearFavicons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearFavicons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearFavicons(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setCustomLayout(body: LayoutType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/SetCustomLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCustomLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCustomLayout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetCustomLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateCustomLayout(body: LayoutType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ValidateCustomLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCustomLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCustomLayout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateCustomLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberActivityOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberActivityOutput>;
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(null as any);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDashboardDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDashboardDataOutput>;
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(null as any);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTopStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTopStatsOutput>;
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTopStatsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfitShareOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfitShareOutput>;
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfitShareOutput>(null as any);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDailySalesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDailySalesOutput>;
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailySalesOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSalesSummaryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSalesSummaryOutput>;
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(null as any);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegionalStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegionalStatsOutput>;
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralStatsOutput>;
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(null as any);
    }
}

@Injectable()
export class TenantHostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantAppHost(): Observable<TenantAppHostOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetTenantAppHost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantAppHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantAppHost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantAppHostOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantAppHostOutput>;
        }));
    }

    protected processGetTenantAppHost(response: HttpResponseBase): Observable<TenantAppHostOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantAppHostOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantAppHostOutput>(null as any);
    }

    /**
     * @param appUi (optional) 
     * @return Success
     */
    getPlatformAppUrl(appUi: boolean | undefined): Observable<GetPlatformAppUrlOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetPlatformAppUrl?";
        if (appUi === null)
            throw new Error("The parameter 'appUi' cannot be null.");
        else if (appUi !== undefined)
            url_ += "appUi=" + encodeURIComponent("" + appUi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlatformAppUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlatformAppUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPlatformAppUrlOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPlatformAppUrlOutput>;
        }));
    }

    protected processGetPlatformAppUrl(response: HttpResponseBase): Observable<GetPlatformAppUrlOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPlatformAppUrlOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPlatformAppUrlOutput>(null as any);
    }

    /**
     * @return Success
     */
    getMemberPortalUrl(): Observable<GetMemberPortalUrlOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetMemberPortalUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPortalUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPortalUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberPortalUrlOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberPortalUrlOutput>;
        }));
    }

    protected processGetMemberPortalUrl(response: HttpResponseBase): Observable<GetMemberPortalUrlOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberPortalUrlOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberPortalUrlOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkHostNameDnsMapping(body: CheckHostNameDnsMappingInput | undefined): Observable<CheckHostNameDnsMappingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/CheckHostNameDnsMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckHostNameDnsMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckHostNameDnsMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckHostNameDnsMappingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckHostNameDnsMappingOutput>;
        }));
    }

    protected processCheckHostNameDnsMapping(response: HttpResponseBase): Observable<CheckHostNameDnsMappingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckHostNameDnsMappingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckHostNameDnsMappingOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSslBindings(): Observable<TenantSslBindingInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetSslBindings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSslBindings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSslBindings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSslBindingInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSslBindingInfo[]>;
        }));
    }

    protected processGetSslBindings(response: HttpResponseBase): Observable<TenantSslBindingInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantSslBindingInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslBindingInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSslBinding(body: AddSslBindingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/AddSslBinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSslBinding(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSslBinding(body: UpdateSslBindingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/UpdateSslBinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSslBinding(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    deleteSslBinding(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/DeleteSslBinding?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSslBinding(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantIntegrationsSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIntegrationsSettings(): Observable<IntegrationsSettings> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/GetIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIntegrationsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIntegrationsSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegrationsSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegrationsSettings>;
        }));
    }

    protected processGetIntegrationsSettings(response: HttpResponseBase): Observable<IntegrationsSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegrationsSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntegrationsSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateIntegrationsSettings(body: IntegrationsSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/UpdateIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIntegrationsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIntegrationsSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateIntegrationsSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantOfferProviderSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEPCVIPOfferProviderSettings(): Observable<EPCVIPOfferProviderSettings> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantOfferProviderSettings/GetEPCVIPOfferProviderSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCVIPOfferProviderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCVIPOfferProviderSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EPCVIPOfferProviderSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EPCVIPOfferProviderSettings>;
        }));
    }

    protected processGetEPCVIPOfferProviderSettings(response: HttpResponseBase): Observable<EPCVIPOfferProviderSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EPCVIPOfferProviderSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EPCVIPOfferProviderSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEPCVIPOfferProviderSettings(body: EPCVIPOfferProviderSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantOfferProviderSettings/UpdateEPCVIPOfferProviderSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEPCVIPOfferProviderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEPCVIPOfferProviderSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEPCVIPOfferProviderSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantPaymentSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBaseCommercePaymentSettings(): Observable<BaseCommercePaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBaseCommercePaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBaseCommercePaymentSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BaseCommercePaymentSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BaseCommercePaymentSettings>;
        }));
    }

    protected processGetBaseCommercePaymentSettings(response: HttpResponseBase): Observable<BaseCommercePaymentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseCommercePaymentSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaseCommercePaymentSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBaseCommercePaymentSettings(body: BaseCommercePaymentSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBaseCommercePaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBaseCommercePaymentSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBaseCommercePaymentSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getACHWorksSettings(): Observable<ACHWorksSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetACHWorksSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetACHWorksSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetACHWorksSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACHWorksSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACHWorksSettings>;
        }));
    }

    protected processGetACHWorksSettings(response: HttpResponseBase): Observable<ACHWorksSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ACHWorksSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ACHWorksSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateACHWorksSettings(body: ACHWorksSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateACHWorksSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateACHWorksSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateACHWorksSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateACHWorksSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRecurlyPaymentSettings(): Observable<RecurlyPaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetRecurlyPaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecurlyPaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecurlyPaymentSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecurlyPaymentSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecurlyPaymentSettings>;
        }));
    }

    protected processGetRecurlyPaymentSettings(response: HttpResponseBase): Observable<RecurlyPaymentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecurlyPaymentSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurlyPaymentSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRecurlyPaymentSettings(body: RecurlyPaymentSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateRecurlyPaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRecurlyPaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRecurlyPaymentSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRecurlyPaymentSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPayPalSettings(): Observable<PayPalSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetPayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayPalSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayPalSettings>;
        }));
    }

    protected processGetPayPalSettings(response: HttpResponseBase): Observable<PayPalSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePayPalSettings(body: PayPalSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdatePayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePayPalSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePayPalSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBankTransferSettings(): Observable<BankTransferSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankTransferSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankTransferSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankTransferSettings>;
        }));
    }

    protected processGetBankTransferSettings(response: HttpResponseBase): Observable<BankTransferSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankTransferSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankTransferSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBankTransferSettings(body: BankTransferSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankTransferSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBankTransferSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getStripeSettings(): Observable<StripeSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetStripeSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStripeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStripeSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripeSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripeSettings>;
        }));
    }

    protected processGetStripeSettings(response: HttpResponseBase): Observable<StripeSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStripeSettings(body: StripeSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateStripeSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStripeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStripeSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStripeSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param includeAdvisorDetails (optional) 
     * @return Success
     */
    getInvoiceSettings(includeAdvisorDetails: boolean | undefined): Observable<InvoiceSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetInvoiceSettings?";
        if (includeAdvisorDetails === null)
            throw new Error("The parameter 'includeAdvisorDetails' cannot be null.");
        else if (includeAdvisorDetails !== undefined)
            url_ += "includeAdvisorDetails=" + encodeURIComponent("" + includeAdvisorDetails) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceSettingsDto>;
        }));
    }

    protected processGetInvoiceSettings(response: HttpResponseBase): Observable<InvoiceSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvoiceSettings(body: InvoiceSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateInvoiceSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvoiceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvoiceSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateInvoiceSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getEPCVIPMailerSettings(): Observable<EPCVIPMailerSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetEPCVIPMailerSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCVIPMailerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCVIPMailerSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EPCVIPMailerSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EPCVIPMailerSettingsEditDto>;
        }));
    }

    protected processGetEPCVIPMailerSettings(response: HttpResponseBase): Observable<EPCVIPMailerSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EPCVIPMailerSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EPCVIPMailerSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getOngageSettings(): Observable<OngageSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetOngageSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOngageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOngageSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OngageSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OngageSettingsEditDto>;
        }));
    }

    protected processGetOngageSettings(response: HttpResponseBase): Observable<OngageSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OngageSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OngageSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getIAgeSettings(): Observable<IAgeSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetIAgeSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIAgeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIAgeSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAgeSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAgeSettingsEditDto>;
        }));
    }

    protected processGetIAgeSettings(response: HttpResponseBase): Observable<IAgeSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IAgeSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IAgeSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getSendGridSettings(): Observable<SendGridSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetSendGridSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSendGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSendGridSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendGridSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendGridSettingsDto>;
        }));
    }

    protected processGetSendGridSettings(response: HttpResponseBase): Observable<SendGridSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendGridSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendGridSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    getYTelSettings(): Observable<YTelSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYTelSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<YTelSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<YTelSettingsEditDto>;
        }));
    }

    protected processGetYTelSettings(response: HttpResponseBase): Observable<YTelSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YTelSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YTelSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getRapidSettings(): Observable<RapidSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetRapidSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRapidSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRapidSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RapidSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RapidSettingsDto>;
        }));
    }

    protected processGetRapidSettings(response: HttpResponseBase): Observable<RapidSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RapidSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RapidSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    getFilestackSettings(): Observable<FilestackSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetFilestackSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilestackSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilestackSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilestackSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilestackSettingsDto>;
        }));
    }

    protected processGetFilestackSettings(response: HttpResponseBase): Observable<FilestackSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilestackSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FilestackSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    getLdapSettings(): Observable<LdapSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetLdapSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLdapSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLdapSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LdapSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LdapSettingsEditDto>;
        }));
    }

    protected processGetLdapSettings(response: HttpResponseBase): Observable<LdapSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LdapSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LdapSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getEmailSettings(): Observable<EmailSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailSettingsEditDto>;
        }));
    }

    protected processGetEmailSettings(response: HttpResponseBase): Observable<EmailSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getUserManagementSettings(): Observable<TenantUserManagementSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantUserManagementSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantUserManagementSettingsEditDto>;
        }));
    }

    protected processGetUserManagementSettings(response: HttpResponseBase): Observable<TenantUserManagementSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantUserManagementSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantUserManagementSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySettings(): Observable<PasswordComplexitySettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetPasswordComplexitySettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PasswordComplexitySettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PasswordComplexitySettingsEditDto>;
        }));
    }

    protected processGetPasswordComplexitySettings(response: HttpResponseBase): Observable<PasswordComplexitySettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PasswordComplexitySettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PasswordComplexitySettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getUserLockOutSettings(): Observable<UserLockOutSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetUserLockOutSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLockOutSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLockOutSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLockOutSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLockOutSettingsEditDto>;
        }));
    }

    protected processGetUserLockOutSettings(response: HttpResponseBase): Observable<UserLockOutSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLockOutSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLockOutSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getTwoFactorLoginSettings(): Observable<TwoFactorLoginSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetTwoFactorLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTwoFactorLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTwoFactorLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwoFactorLoginSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwoFactorLoginSettingsEditDto>;
        }));
    }

    protected processGetTwoFactorLoginSettings(response: HttpResponseBase): Observable<TwoFactorLoginSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorLoginSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwoFactorLoginSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getMemberPortalSettings(): Observable<MemberPortalSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetMemberPortalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPortalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPortalSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberPortalSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberPortalSettingsDto>;
        }));
    }

    protected processGetMemberPortalSettings(response: HttpResponseBase): Observable<MemberPortalSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberPortalSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberPortalSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEPCVIPMailerSettings(body: EPCVIPMailerSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateEPCVIPMailerSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEPCVIPMailerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEPCVIPMailerSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEPCVIPMailerSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOngageSettings(body: OngageSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateOngageSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOngageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOngageSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOngageSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateIAgeSettings(body: IAgeSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateIAgeSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIAgeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIAgeSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateIAgeSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSendGridSettings(body: SendGridSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateSendGridSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSendGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSendGridSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSendGridSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateYTelSettings(body: YTelSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateYTelSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateYTelSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRapidSettings(body: RapidSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateRapidSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRapidSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRapidSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRapidSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFilestackSettings(body: FilestackSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateFilestackSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFilestackSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFilestackSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateFilestackSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLdapSettings(body: LdapSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateLdapSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLdapSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLdapSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLdapSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserManagementSettings(body: TenantUserManagementSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePasswordComplexitySettings(body: PasswordComplexitySetting | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdatePasswordComplexitySettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordComplexitySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordComplexitySettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePasswordComplexitySettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserLockOutSettings(body: UserLockOutSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateUserLockOutSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserLockOutSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserLockOutSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserLockOutSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTwoFactorLoginSettings(body: TwoFactorLoginSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateTwoFactorLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTwoFactorLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTwoFactorLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTwoFactorLoginSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMemberPortalSettings(body: MemberPortalSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateMemberPortalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberPortalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberPortalSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateMemberPortalSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getGeneralSettings(): Observable<GeneralSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSettingsEditDto>;
        }));
    }

    protected processGetGeneralSettings(response: HttpResponseBase): Observable<GeneralSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSettingsEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGeneralSettings(body: GeneralSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateGeneralSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmailSettings(body: EmailSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantSettingsCreditReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIdcsSettings(): Observable<IdcsSettings> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantSettingsCreditReport/GetIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdcsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdcsSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdcsSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdcsSettings>;
        }));
    }

    protected processGetIdcsSettings(response: HttpResponseBase): Observable<IdcsSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdcsSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdcsSettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateIdcsSettings(body: IdcsSettings | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantSettingsCreditReport/UpdateIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdcsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdcsSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateIdcsSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantSslCertificateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantSslCertificates(): Observable<TenantSslCertificateInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/GetTenantSslCertificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantSslCertificates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantSslCertificates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSslCertificateInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSslCertificateInfo[]>;
        }));
    }

    protected processGetTenantSslCertificates(response: HttpResponseBase): Observable<TenantSslCertificateInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantSslCertificateInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslCertificateInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTenantSslCertificate(body: AddTenantSslCertificateInput | undefined): Observable<TenantSslCertificateInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/AddTenantSslCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTenantSslCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTenantSslCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSslCertificateInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSslCertificateInfo>;
        }));
    }

    protected processAddTenantSslCertificate(response: HttpResponseBase): Observable<TenantSslCertificateInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSslCertificateInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslCertificateInfo>(null as any);
    }

    /**
     * @return Success
     */
    deleteTenantSslCertificate(sslCertificateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/DeleteTenantSslCertificate?";
        if (sslCertificateId === undefined || sslCertificateId === null)
            throw new Error("The parameter 'sslCertificateId' must be defined and cannot be null.");
        else
            url_ += "SslCertificateId=" + encodeURIComponent("" + sslCertificateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenantSslCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenantSslCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTenantSslCertificate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPaymentInfo(body: PaymentRequestInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/AddPaymentInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPaymentInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddPaymentInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setupSubscription(body: SetupSubscriptionInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/SetupSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetupSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestPayment(body: RequestPaymentDto | undefined): Observable<RequestPaymentResult> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RequestPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestPaymentResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestPaymentResult>;
        }));
    }

    protected processRequestPayment(response: HttpResponseBase): Observable<RequestPaymentResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestPaymentResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestPaymentResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeSubscriptionPayment(body: PaymentRequestInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/CompleteSubscriptionPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteSubscriptionPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompleteSubscriptionPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectPendingPayment(body: ModuleType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RejectPendingPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectPendingPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectPendingPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRejectPendingPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestStripePayment(body: RequestStripePaymentInput | undefined): Observable<RequestStripePaymentOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RequestStripePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestStripePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestStripePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestStripePaymentOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestStripePaymentOutput>;
        }));
    }

    protected processRequestStripePayment(response: HttpResponseBase): Observable<RequestStripePaymentOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestStripePaymentOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStripePaymentOutput>(null as any);
    }

    /**
     * @return Success
     */
    requestStripePaymentForInvoice(invoiceId: number): Observable<RequestStripePaymentOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RequestStripePaymentForInvoice?";
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined and cannot be null.");
        else
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestStripePaymentForInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestStripePaymentForInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestStripePaymentOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestStripePaymentOutput>;
        }));
    }

    protected processRequestStripePaymentForInvoice(response: HttpResponseBase): Observable<RequestStripePaymentOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestStripePaymentOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStripePaymentOutput>(null as any);
    }

    /**
     * @return Success
     */
    getModuleSubscriptions(): Observable<ModuleSubscriptionInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetModuleSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleSubscriptionInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleSubscriptionInfoDto[]>;
        }));
    }

    protected processGetModuleSubscriptions(response: HttpResponseBase): Observable<ModuleSubscriptionInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleSubscriptionInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleSubscriptionInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeTenantRegistration(body: CompleteTenantRegistrationInput | undefined): Observable<CompleteTenantRegistrationOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/CompleteTenantRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTenantRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTenantRegistration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompleteTenantRegistrationOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompleteTenantRegistrationOutput>;
        }));
    }

    protected processCompleteTenantRegistration(response: HttpResponseBase): Observable<CompleteTenantRegistrationOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompleteTenantRegistrationOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompleteTenantRegistrationOutput>(null as any);
    }

    /**
     * @return Success
     */
    getBankTransferSettings(): Observable<BankTransferSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankTransferSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankTransferSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankTransferSettingsDto>;
        }));
    }

    protected processGetBankTransferSettings(response: HttpResponseBase): Observable<BankTransferSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankTransferSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankTransferSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    getPayPalSettings(): Observable<PayPalSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetPayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayPalSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayPalSettingsDto>;
        }));
    }

    protected processGetPayPalSettings(response: HttpResponseBase): Observable<PayPalSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalSettingsDto>(null as any);
    }
}

@Injectable()
export class TestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param strings (optional) 
     * @return Success
     */
    getCommonPhrases(strings: string[] | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetCommonPhrases?";
        if (strings === null)
            throw new Error("The parameter 'strings' cannot be null.");
        else if (strings !== undefined)
            strings && strings.forEach(item => { url_ += "strings=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommonPhrases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommonPhrases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCommonPhrases(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param text (optional) 
     * @return Success
     */
    getKeywords(text: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetKeywords?";
        if (text === null)
            throw new Error("The parameter 'text' cannot be null.");
        else if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeywords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeywords(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetKeywords(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfNameValueDto>;
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(null as any);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateByCode(body: AuthenticateByCodeModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticateByCode(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @param rememberClient (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string, rememberClient: boolean | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken === undefined || refreshToken === null)
            throw new Error("The parameter 'refreshToken' must be defined and cannot be null.");
        else
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        if (rememberClient === null)
            throw new Error("The parameter 'rememberClient' cannot be null.");
        else if (rememberClient !== undefined)
            url_ += "rememberClient=" + encodeURIComponent("" + rememberClient) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenResult>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(null as any);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param secureId (optional) 
     * @return Success
     */
    impersonatedAuthenticate(secureId: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (secureId === null)
            throw new Error("The parameter 'secureId' cannot be null.");
        else if (secureId !== undefined)
            url_ += "secureId=" + encodeURIComponent("" + secureId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(null as any);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(null as any);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchedAccountAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchedAccountAuthenticateResultModel>;
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | undefined, severity: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity === null)
            throw new Error("The parameter 'severity' cannot be null.");
        else if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TransactionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getFiltersInitialData(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<FiltersInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetFiltersInitialData?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFiltersInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiltersInitialData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FiltersInitialData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FiltersInitialData>;
        }));
    }

    protected processGetFiltersInitialData(response: HttpResponseBase): Observable<FiltersInitialData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FiltersInitialData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiltersInitialData>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getCounterparties(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetCounterparties?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounterparties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounterparties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto[]>;
        }));
    }

    protected processGetCounterparties(response: HttpResponseBase): Observable<CounterpartyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CounterpartyDto[]>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param currencyId (optional) 
     * @param accountIds (optional) 
     * @param businessEntityIds (optional) 
     * @return Success
     */
    getStartingBalance(instanceType: InstanceType | undefined, instanceId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, currencyId: string | undefined, accountIds: number[] | undefined, businessEntityIds: number[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetStartingBalance?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (accountIds === null)
            throw new Error("The parameter 'accountIds' cannot be null.");
        else if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (businessEntityIds === null)
            throw new Error("The parameter 'businessEntityIds' cannot be null.");
        else if (businessEntityIds !== undefined)
            businessEntityIds && businessEntityIds.forEach(item => { url_ += "BusinessEntityIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStartingBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStartingBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetStartingBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getTransactionAttributeTypes(instanceType: InstanceType | undefined, instanceId: number | undefined): Observable<GetTransactionAttributeTypesOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionAttributeTypes?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionAttributeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionAttributeTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransactionAttributeTypesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransactionAttributeTypesOutput>;
        }));
    }

    protected processGetTransactionAttributeTypes(response: HttpResponseBase): Observable<GetTransactionAttributeTypesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransactionAttributeTypesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTransactionAttributeTypesOutput>(null as any);
    }

    /**
     * @param instanceType (optional) 
     * @param instanceId (optional) 
     * @return Success
     */
    getTransactionDetails(instanceType: InstanceType | undefined, instanceId: number | undefined, transactionId: number): Observable<GetTransactionDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionDetails?";
        if (instanceType === null)
            throw new Error("The parameter 'instanceType' cannot be null.");
        else if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&";
        if (instanceId === null)
            throw new Error("The parameter 'instanceId' cannot be null.");
        else if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransactionDetailsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransactionDetailsOutput>;
        }));
    }

    protected processGetTransactionDetails(response: HttpResponseBase): Observable<GetTransactionDetailsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransactionDetailsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTransactionDetailsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getTransactionTypesAndCategories(): Observable<TransactionTypesAndCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionTypesAndCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypesAndCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypesAndCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionTypesAndCategoriesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionTypesAndCategoriesDto>;
        }));
    }

    protected processGetTransactionTypesAndCategories(response: HttpResponseBase): Observable<TransactionTypesAndCategoriesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionTypesAndCategoriesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionTypesAndCategoriesDto>(null as any);
    }
}

@Injectable()
export class TwitterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRequestToken(): Observable<TwitterGetRequestTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetRequestTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetRequestTokenResponse>;
        }));
    }

    protected processGetRequestToken(response: HttpResponseBase): Observable<TwitterGetRequestTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetRequestTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetRequestTokenResponse>(null as any);
    }

    /**
     * @param token (optional) 
     * @param verifier (optional) 
     * @return Success
     */
    getAccessToken(token: string | undefined, verifier: string | undefined): Observable<TwitterGetAccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetAccessToken?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (verifier === null)
            throw new Error("The parameter 'verifier' cannot be null.");
        else if (verifier !== undefined)
            url_ += "verifier=" + encodeURIComponent("" + verifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetAccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetAccessTokenResponse>;
        }));
    }

    protected processGetAccessToken(response: HttpResponseBase): Observable<TwitterGetAccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetAccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetAccessTokenResponse>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param group (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | undefined, permissions: string[] | undefined, role: number | undefined, onlyLockedUsers: boolean | undefined, group: UserGroup | undefined, isActive: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ListResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUsers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "Group=" + encodeURIComponent("" + group) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfUserListDto>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<ListResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserListDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param group (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getUserCount(filter: string | undefined, permissions: string[] | undefined, role: number | undefined, onlyLockedUsers: boolean | undefined, group: UserGroup | undefined, isActive: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserCount?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "Group=" + encodeURIComponent("" + group) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetUserCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserForEditOutput>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserPermissionsForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserPermissionsForEditOutput>;
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPicture(body: UpdateUserPictureInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateUserPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    clearUserPicture(userId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ClearUserPicture?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUserPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearUserPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inviteUsers(body: InviteUserInput[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/InviteUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInviteUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInviteUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param notifyUser (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined, notifyUser: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (notifyUser === null)
            throw new Error("The parameter 'notifyUser' cannot be null.");
        else if (notifyUser !== undefined)
            url_ += "NotifyUser=" + encodeURIComponent("" + notifyUser) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmail(body: UpdateUserEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePhone(body: UpdateUserPhoneDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdatePhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetUserPasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOptions(body: UpdateUserOptionsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateOptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    grantPermission(body: GrantPermissionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GrantPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGrantPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prohibitPermission(body: ProhibitPermissionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ProhibitPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProhibitPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProhibitPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProhibitPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addToRole(body: UpdateUserRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/AddToRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddToRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeFromRole(id: number | undefined, roleName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/RemoveFromRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined and cannot be null.");
        else
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveFromRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAvailableUserCount(moduleType: ModuleType): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetAvailableUserCount?";
        if (moduleType === undefined || moduleType === null)
            throw new Error("The parameter 'moduleType' must be defined and cannot be null.");
        else
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableUserCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetAvailableUserCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAutoLoginLink(userId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetAutoLoginLink?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutoLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutoLoginLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAutoLoginLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class UserAssignmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchPhrase (optional) 
     * @param topCount (optional) 
     * @return Success
     */
    getAllowedAssignableUsersForActivity(searchPhrase: string | undefined, topCount: number | undefined): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/UserAssignment/GetAllowedAssignableUsersForActivity?";
        if (searchPhrase === null)
            throw new Error("The parameter 'searchPhrase' cannot be null.");
        else if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (topCount === null)
            throw new Error("The parameter 'topCount' cannot be null.");
        else if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedAssignableUsersForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedAssignableUsersForActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoDto[]>;
        }));
    }

    protected processGetAllowedAssignableUsersForActivity(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(null as any);
    }
}

@Injectable()
export class UserCommissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @return Success
     */
    getLedger(startDate: moment.Moment | undefined): Observable<GetLedgerOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/UserCommission/GetLedger?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLedger(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLedgerOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLedgerOutput>;
        }));
    }

    protected processGetLedger(response: HttpResponseBase): Observable<GetLedgerOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLedgerOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLedgerOutput>(null as any);
    }

    /**
     * @param amount (optional) 
     * @return Success
     */
    requestWithdrawal(amount: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/UserCommission/RequestWithdrawal?";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestWithdrawal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestWithdrawal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestWithdrawal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getTotals(): Observable<GetLedgerTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/UserCommission/GetTotals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLedgerTotalsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLedgerTotalsOutput>;
        }));
    }

    protected processGetTotals(response: HttpResponseBase): Observable<GetLedgerTotalsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLedgerTotalsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLedgerTotalsOutput>(null as any);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserDelegationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserDelegationDto>;
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDelegationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDelegationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDelegationDto[]>;
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDelegationDto[]>(null as any);
    }
}

@Injectable()
export class UserInvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param payerOrganizationUnitId (optional) 
     * @return Success
     */
    generatePdf(id: number | undefined, payerOrganizationUnitId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/UserInvoice/GeneratePdf?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (payerOrganizationUnitId === null)
            throw new Error("The parameter 'payerOrganizationUnitId' cannot be null.");
        else if (payerOrganizationUnitId !== undefined)
            url_ += "payerOrganizationUnitId=" + encodeURIComponent("" + payerOrganizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGeneratePdf(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getInvoiceReceiptInfo(tenantId: number, publicId: string): Observable<GetInvoiceReceiptInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/UserInvoice/GetInvoiceReceiptInfo?";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined and cannot be null.");
        else
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (publicId === undefined || publicId === null)
            throw new Error("The parameter 'publicId' must be defined and cannot be null.");
        else
            url_ += "publicId=" + encodeURIComponent("" + publicId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceReceiptInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceReceiptInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvoiceReceiptInfoOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvoiceReceiptInfoOutput>;
        }));
    }

    protected processGetInvoiceReceiptInfo(response: HttpResponseBase): Observable<GetInvoiceReceiptInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceReceiptInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoiceReceiptInfoOutput>(null as any);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(null as any);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param result (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserLoginAttempts(filter: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, result: AbpLoginResultType | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetUserLoginAttempts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (result === null)
            throw new Error("The parameter 'result' cannot be null.");
        else if (result !== undefined)
            url_ += "Result=" + encodeURIComponent("" + result) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetUserLoginAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserLoginAttemptDto>(null as any);
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRecentLoginAttemptsForOtherUser(userId: number | undefined): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentLoginAttemptsForOtherUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentLoginAttemptsForOtherUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentLoginAttemptsForOtherUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetRecentLoginAttemptsForOtherUser(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(null as any);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLatestWebLogsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLatestWebLogsOutput>;
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(null as any);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable()
export class WorkflowEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRule(body: AddWorkflowRuleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/AddRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editRule(body: EditWorkflowRuleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/EditRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param ruleId (optional) 
     * @return Success
     */
    deleteRule(ruleId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/DeleteRule?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRules(): Observable<WorkflowRuleDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/GetRules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowRuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowRuleDto[]>;
        }));
    }

    protected processGetRules(response: HttpResponseBase): Observable<WorkflowRuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowRuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowRuleDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getTriggers(): Observable<WorkflowTriggerDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/GetTriggers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTriggers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTriggers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTriggerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTriggerDto[]>;
        }));
    }

    protected processGetTriggers(response: HttpResponseBase): Observable<WorkflowTriggerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowTriggerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTriggerDto[]>(null as any);
    }

    /**
     * @param ruleId (optional) 
     * @return Success
     */
    triggerRule(ruleId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/TriggerRule?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTriggerRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export enum AbpLoginResultType {
    Success = 1,
    InvalidUserNameOrEmailAddress = 2,
    InvalidPassword = 3,
    UserIsNotActive = 4,
    InvalidTenancyName = 5,
    TenantIsNotActive = 6,
    UserEmailIsNotConfirmed = 7,
    UnknownExternalLogin = 8,
    LockedOut = 9,
    UserPhoneNumberIsNotConfirmed = 10,
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value!: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class AccountCreditHistoryDto implements IAccountCreditHistoryDto {
    year!: number;
    month!: number;
    status!: string | undefined;
    readonly isPositiveStatus!: boolean;
    readonly statusType!: AccountCreditHistoryStatusDto;

    constructor(data?: IAccountCreditHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.status = _data["status"];
            (<any>this).isPositiveStatus = _data["isPositiveStatus"];
            (<any>this).statusType = _data["statusType"];
        }
    }

    static fromJS(data: any): AccountCreditHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCreditHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["status"] = this.status;
        data["isPositiveStatus"] = this.isPositiveStatus;
        data["statusType"] = this.statusType;
        return data;
    }
}

export interface IAccountCreditHistoryDto {
    year: number;
    month: number;
    status: string | undefined;
    isPositiveStatus: boolean;
    statusType: AccountCreditHistoryStatusDto;
}

export enum AccountCreditHistoryStatusDto {
    Other = 0,
    NotOpened = 1,
    Unknown = 2,
    Ok = 3,
    L30 = 4,
    L60 = 5,
    L90 = 6,
    L120 = 7,
    L150 = 8,
    PP = 9,
    RF = 10,
    CC = 11,
}

export class AccountDto implements IAccountDto {
    accountIds!: number[] | undefined;
    accountName!: string | undefined;
    state!: AccountState;
    creditLimit!: number;
    readonly availableCredit!: number;
    outstandingBalance!: number;
    readonly ratio!: number;
    dateOpened!: moment.Moment | undefined;
    accountDetails!: AccountInfoDto[] | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            this.accountName = _data["accountName"];
            this.state = _data["state"];
            this.creditLimit = _data["creditLimit"];
            (<any>this).availableCredit = _data["availableCredit"];
            this.outstandingBalance = _data["outstandingBalance"];
            (<any>this).ratio = _data["ratio"];
            this.dateOpened = _data["dateOpened"] ? moment(_data["dateOpened"].toString()) : <any>undefined;
            if (Array.isArray(_data["accountDetails"])) {
                this.accountDetails = [] as any;
                for (let item of _data["accountDetails"])
                    this.accountDetails!.push(AccountInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        data["creditLimit"] = this.creditLimit;
        data["availableCredit"] = this.availableCredit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["ratio"] = this.ratio;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        if (Array.isArray(this.accountDetails)) {
            data["accountDetails"] = [];
            for (let item of this.accountDetails)
                data["accountDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAccountDto {
    accountIds: number[] | undefined;
    accountName: string | undefined;
    state: AccountState;
    creditLimit: number;
    availableCredit: number;
    outstandingBalance: number;
    ratio: number;
    dateOpened: moment.Moment | undefined;
    accountDetails: AccountInfoDto[] | undefined;
}

export class AccountInfoDto implements IAccountInfoDto {
    bureau!: Bureau | undefined;
    status!: AccountStatus;
    totalCreditLimit!: number | undefined;
    readonly availableCredit!: number | undefined;
    readonly creditUtilization!: number | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    balance!: number | undefined;
    pastDue!: number | undefined;
    dateOpened!: moment.Moment | undefined;
    moPayment!: number | undefined;
    paymentStatus!: string | undefined;
    terms!: string | undefined;
    comment!: string | undefined;
    maxAccountHistoryDate!: moment.Moment | undefined;
    twoYearHistory!: AccountCreditHistoryDto[] | undefined;

    constructor(data?: IAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bureau = _data["bureau"];
            this.status = _data["status"];
            this.totalCreditLimit = _data["totalCreditLimit"];
            (<any>this).availableCredit = _data["availableCredit"];
            (<any>this).creditUtilization = _data["creditUtilization"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.balance = _data["balance"];
            this.pastDue = _data["pastDue"];
            this.dateOpened = _data["dateOpened"] ? moment(_data["dateOpened"].toString()) : <any>undefined;
            this.moPayment = _data["moPayment"];
            this.paymentStatus = _data["paymentStatus"];
            this.terms = _data["terms"];
            this.comment = _data["comment"];
            this.maxAccountHistoryDate = _data["maxAccountHistoryDate"] ? moment(_data["maxAccountHistoryDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["twoYearHistory"])) {
                this.twoYearHistory = [] as any;
                for (let item of _data["twoYearHistory"])
                    this.twoYearHistory!.push(AccountCreditHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["status"] = this.status;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["availableCredit"] = this.availableCredit;
        data["creditUtilization"] = this.creditUtilization;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["balance"] = this.balance;
        data["pastDue"] = this.pastDue;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["moPayment"] = this.moPayment;
        data["paymentStatus"] = this.paymentStatus;
        data["terms"] = this.terms;
        data["comment"] = this.comment;
        data["maxAccountHistoryDate"] = this.maxAccountHistoryDate ? this.maxAccountHistoryDate.toISOString() : <any>undefined;
        if (Array.isArray(this.twoYearHistory)) {
            data["twoYearHistory"] = [];
            for (let item of this.twoYearHistory)
                data["twoYearHistory"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAccountInfoDto {
    bureau: Bureau | undefined;
    status: AccountStatus;
    totalCreditLimit: number | undefined;
    availableCredit: number | undefined;
    creditUtilization: number | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    balance: number | undefined;
    pastDue: number | undefined;
    dateOpened: moment.Moment | undefined;
    moPayment: number | undefined;
    paymentStatus: string | undefined;
    terms: string | undefined;
    comment: string | undefined;
    maxAccountHistoryDate: moment.Moment | undefined;
    twoYearHistory: AccountCreditHistoryDto[] | undefined;
}

export class AccountingCategoryDto implements IAccountingCategoryDto {
    id!: string | undefined;
    name!: string;
    parentId!: string | undefined;
    coAID!: string | undefined;
    isActive!: boolean | undefined;
    cashType!: string | undefined;
    accountingType!: string;
    sortId!: number | undefined;
    reportingCategoryCode!: string | undefined;
    reportingCategoryName!: string | undefined;

    constructor(data?: IAccountingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.coAID = _data["coAID"];
            this.isActive = _data["isActive"];
            this.cashType = _data["cashType"];
            this.accountingType = _data["accountingType"];
            this.sortId = _data["sortId"];
            this.reportingCategoryCode = _data["reportingCategoryCode"];
            this.reportingCategoryName = _data["reportingCategoryName"];
        }
    }

    static fromJS(data: any): AccountingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["isActive"] = this.isActive;
        data["cashType"] = this.cashType;
        data["accountingType"] = this.accountingType;
        data["sortId"] = this.sortId;
        data["reportingCategoryCode"] = this.reportingCategoryCode;
        data["reportingCategoryName"] = this.reportingCategoryName;
        return data;
    }
}

export interface IAccountingCategoryDto {
    id: string | undefined;
    name: string;
    parentId: string | undefined;
    coAID: string | undefined;
    isActive: boolean | undefined;
    cashType: string | undefined;
    accountingType: string;
    sortId: number | undefined;
    reportingCategoryCode: string | undefined;
    reportingCategoryName: string | undefined;
}

export enum AccountingTreeType {
    Simple = "Simple",
    Standard = "Standard",
}

export class AccountingTypeDto implements IAccountingTypeDto {
    typeId!: string | undefined;
    name!: string | undefined;
    isSystem!: boolean;

    constructor(data?: IAccountingTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.name = _data["name"];
            this.isSystem = _data["isSystem"];
        }
    }

    static fromJS(data: any): AccountingTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["isSystem"] = this.isSystem;
        return data;
    }
}

export interface IAccountingTypeDto {
    typeId: string | undefined;
    name: string | undefined;
    isSystem: boolean;
}

export enum AccountState {
    Active = 0,
    Closed = 1,
}

export enum AccountStatus {
    Open = 0,
    Closed = 1,
}

export class AccountTotals implements IAccountTotals {
    bankAccountCount!: number;
    totalNetWorth!: number;
    totalPending!: number;

    constructor(data?: IAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountCount = _data["bankAccountCount"];
            this.totalNetWorth = _data["totalNetWorth"];
            this.totalPending = _data["totalPending"];
        }
    }

    static fromJS(data: any): AccountTotals {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountCount"] = this.bankAccountCount;
        data["totalNetWorth"] = this.totalNetWorth;
        data["totalPending"] = this.totalPending;
        return data;
    }
}

export interface IAccountTotals {
    bankAccountCount: number;
    totalNetWorth: number;
    totalPending: number;
}

export class ACHCustomerDto implements IACHCustomerDto {
    customerRoutingNo!: string;
    customerAcctNo!: string;

    constructor(data?: IACHCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerRoutingNo = _data["customerRoutingNo"];
            this.customerAcctNo = _data["customerAcctNo"];
        }
    }

    static fromJS(data: any): ACHCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerRoutingNo"] = this.customerRoutingNo;
        data["customerAcctNo"] = this.customerAcctNo;
        return data;
    }
}

export interface IACHCustomerDto {
    customerRoutingNo: string;
    customerAcctNo: string;
}

export class ACHCustomerInfoDto implements IACHCustomerInfoDto {
    customerRoutingNo!: string | undefined;
    customerAcctNo!: string | undefined;

    constructor(data?: IACHCustomerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerRoutingNo = _data["customerRoutingNo"];
            this.customerAcctNo = _data["customerAcctNo"];
        }
    }

    static fromJS(data: any): ACHCustomerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerRoutingNo"] = this.customerRoutingNo;
        data["customerAcctNo"] = this.customerAcctNo;
        return data;
    }
}

export interface IACHCustomerInfoDto {
    customerRoutingNo: string | undefined;
    customerAcctNo: string | undefined;
}

export class ACHCustomerShortInfo implements IACHCustomerShortInfo {
    firstName!: string | undefined;
    lastName!: string | undefined;
    customerAcctType!: CustomerAccountingType;

    constructor(data?: IACHCustomerShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.customerAcctType = _data["customerAcctType"];
        }
    }

    static fromJS(data: any): ACHCustomerShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["customerAcctType"] = this.customerAcctType;
        return data;
    }
}

export interface IACHCustomerShortInfo {
    firstName: string | undefined;
    lastName: string | undefined;
    customerAcctType: CustomerAccountingType;
}

export class ACHWorksSettings implements IACHWorksSettings {
    sss!: string | undefined;
    locID!: string | undefined;
    soapUser!: string | undefined;
    soapKey!: string | undefined;

    constructor(data?: IACHWorksSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sss = _data["sss"];
            this.locID = _data["locID"];
            this.soapUser = _data["soapUser"];
            this.soapKey = _data["soapKey"];
        }
    }

    static fromJS(data: any): ACHWorksSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ACHWorksSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sss"] = this.sss;
        data["locID"] = this.locID;
        data["soapUser"] = this.soapUser;
        data["soapKey"] = this.soapKey;
        return data;
    }
}

export interface IACHWorksSettings {
    sss: string | undefined;
    locID: string | undefined;
    soapUser: string | undefined;
    soapKey: string | undefined;
}

export class ActionDto implements IActionDto {
    id!: number;
    name!: string | undefined;
    sysId!: string | undefined;
    targetStageId!: number | undefined;

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sysId = _data["sysId"];
            this.targetStageId = _data["targetStageId"];
        }
    }

    static fromJS(data: any): ActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        data["targetStageId"] = this.targetStageId;
        return data;
    }
}

export interface IActionDto {
    id: number;
    name: string | undefined;
    sysId: string | undefined;
    targetStageId: number | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ActivityDto implements IActivityDto {
    id!: number;
    creatorUserId!: number | undefined;
    type!: ActivityType;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["assignedUserIds"])) {
                this.assignedUserIds = [] as any;
                for (let item of _data["assignedUserIds"])
                    this.assignedUserIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.allDay = _data["allDay"];
            this.stageId = _data["stageId"];
            this.leadId = _data["leadId"];
            this.contactId = _data["contactId"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): ActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.assignedUserIds)) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IActivityDto {
    id: number;
    creatorUserId: number | undefined;
    type: ActivityType;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export enum ActivityType {
    Task = "Task",
    Event = "Event",
}

export class AddBankCardPaymentInput implements IAddBankCardPaymentInput {
    invoiceId!: number | undefined;
    invoiceNumber!: string | undefined;
    date!: moment.Moment | undefined;
    description!: string | undefined;
    orderStage!: string | undefined;
    amount!: number;
    gatewayName!: string | undefined;
    gatewayTransactionId!: string | undefined;
    gatewayOriginTransactionId!: string | undefined;
    authorizationCode!: string | undefined;
    transactionType!: PaymentTransactionType | undefined;
    bankCardInfo!: BankCardInput | undefined;
    hasRecurringBilling!: boolean | undefined;

    constructor(data?: IAddBankCardPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.orderStage = _data["orderStage"];
            this.amount = _data["amount"];
            this.gatewayName = _data["gatewayName"];
            this.gatewayTransactionId = _data["gatewayTransactionId"];
            this.gatewayOriginTransactionId = _data["gatewayOriginTransactionId"];
            this.authorizationCode = _data["authorizationCode"];
            this.transactionType = _data["transactionType"];
            this.bankCardInfo = _data["bankCardInfo"] ? BankCardInput.fromJS(_data["bankCardInfo"]) : <any>undefined;
            this.hasRecurringBilling = _data["hasRecurringBilling"];
        }
    }

    static fromJS(data: any): AddBankCardPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddBankCardPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["orderStage"] = this.orderStage;
        data["amount"] = this.amount;
        data["gatewayName"] = this.gatewayName;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["gatewayOriginTransactionId"] = this.gatewayOriginTransactionId;
        data["authorizationCode"] = this.authorizationCode;
        data["transactionType"] = this.transactionType;
        data["bankCardInfo"] = this.bankCardInfo ? this.bankCardInfo.toJSON() : <any>undefined;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        return data;
    }
}

export interface IAddBankCardPaymentInput {
    invoiceId: number | undefined;
    invoiceNumber: string | undefined;
    date: moment.Moment | undefined;
    description: string | undefined;
    orderStage: string | undefined;
    amount: number;
    gatewayName: string | undefined;
    gatewayTransactionId: string | undefined;
    gatewayOriginTransactionId: string | undefined;
    authorizationCode: string | undefined;
    transactionType: PaymentTransactionType | undefined;
    bankCardInfo: BankCardInput | undefined;
    hasRecurringBilling: boolean | undefined;
}

export class AddContactsToListsInput implements IAddContactsToListsInput {
    contactIds!: number[] | undefined;
    lists!: ContactListInput[] | undefined;

    constructor(data?: IAddContactsToListsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ContactListInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddContactsToListsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactsToListsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddContactsToListsInput {
    contactIds: number[] | undefined;
    lists: ContactListInput[] | undefined;
}

export class AddForecastInput implements IAddForecastInput {
    forecastModelId!: number;
    bankAccountId!: number;
    date!: moment.Moment;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    cashFlowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    currencyId!: string;
    amount!: number;
    description!: string | undefined;

    constructor(data?: IAddForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.forecastModelId = _data["forecastModelId"];
            this.bankAccountId = _data["bankAccountId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.cashFlowTypeId = _data["cashFlowTypeId"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.currencyId = _data["currencyId"];
            this.amount = _data["amount"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AddForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["bankAccountId"] = this.bankAccountId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddForecastInput {
    forecastModelId: number;
    bankAccountId: number;
    date: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    cashFlowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    currencyId: string;
    amount: number;
    description: string | undefined;
}

export class AddMappingDto implements IAddMappingDto {
    oldName!: string;
    newName!: string;

    constructor(data?: IAddMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldName = _data["oldName"];
            this.newName = _data["newName"];
        }
    }

    static fromJS(data: any): AddMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldName"] = this.oldName;
        data["newName"] = this.newName;
        return data;
    }
}

export interface IAddMappingDto {
    oldName: string;
    newName: string;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data;
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddressDto implements IAddressDto {
    line1!: string | undefined;
    line2!: string | undefined;
    line3!: string | undefined;
    line4!: string | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.line3 = _data["line3"];
            this.line4 = _data["line4"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        return data;
    }
}

export interface IAddressDto {
    line1: string | undefined;
    line2: string | undefined;
    line3: string | undefined;
    line4: string | undefined;
}

export class AddressOwnershipTypeDto implements IAddressOwnershipTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IAddressOwnershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddressOwnershipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressOwnershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAddressOwnershipTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class AddressUsageTypeDto implements IAddressUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean;

    constructor(data?: IAddressUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isCompany = _data["isCompany"];
        }
    }

    static fromJS(data: any): AddressUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data;
    }
}

export interface IAddressUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean;
}

export class AddSslBindingInput implements IAddSslBindingInput {
    tenantHostType!: TenantHostType;
    domainName!: string | undefined;
    sslCertificateId!: number | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IAddSslBindingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantHostType = _data["tenantHostType"];
            this.domainName = _data["domainName"];
            this.sslCertificateId = _data["sslCertificateId"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): AddSslBindingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSslBindingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["domainName"] = this.domainName;
        data["sslCertificateId"] = this.sslCertificateId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IAddSslBindingInput {
    tenantHostType: TenantHostType;
    domainName: string | undefined;
    sslCertificateId: number | undefined;
    organizationUnitId: number | undefined;
}

export class AddTenantSslCertificateInput implements IAddTenantSslCertificateInput {
    base64EncodedCertificate!: string;
    password!: string | undefined;

    constructor(data?: IAddTenantSslCertificateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64EncodedCertificate = _data["base64EncodedCertificate"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AddTenantSslCertificateInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddTenantSslCertificateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64EncodedCertificate"] = this.base64EncodedCertificate;
        data["password"] = this.password;
        return data;
    }
}

export interface IAddTenantSslCertificateInput {
    base64EncodedCertificate: string;
    password: string | undefined;
}

export class AddUserInput implements IAddUserInput {
    userId!: number;
    sendInvitationEmail!: boolean;

    constructor(data?: IAddUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.sendInvitationEmail = _data["sendInvitationEmail"];
        }
    }

    static fromJS(data: any): AddUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["sendInvitationEmail"] = this.sendInvitationEmail;
        return data;
    }
}

export interface IAddUserInput {
    userId: number;
    sendInvitationEmail: boolean;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class AddWorkflowRuleDto implements IAddWorkflowRuleDto {
    triggerIdentifier!: string;
    actionIdentifier!: string;
    configurationOptions!: string;
    isActive!: boolean;

    constructor(data?: IAddWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.triggerIdentifier = _data["triggerIdentifier"];
            this.actionIdentifier = _data["actionIdentifier"];
            this.configurationOptions = _data["configurationOptions"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AddWorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddWorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IAddWorkflowRuleDto {
    triggerIdentifier: string;
    actionIdentifier: string;
    configurationOptions: string;
    isActive: boolean;
}

export enum AdjustmentType {
    StartingBalance = 0,
    BalanceDiscrepancy = 1,
    StartDateBalance = 2,
}

export class AdvisorLinkInfo implements IAdvisorLinkInfo {
    linkTypeId!: string | undefined;
    url!: string | undefined;

    constructor(data?: IAdvisorLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkTypeId = _data["linkTypeId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): AdvisorLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AdvisorLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        return data;
    }
}

export interface IAdvisorLinkInfo {
    linkTypeId: string | undefined;
    url: string | undefined;
}

export class AffiliateInfoHistoryInfo implements IAffiliateInfoHistoryInfo {
    affiliateContactId!: number | undefined;
    affiliateContactName!: string | undefined;
    affiliateContactAffiliateCode!: string | undefined;
    affiliateContactPhotoPublicId!: string | undefined;
    affiliateCode!: string | undefined;
    affiliateRate!: number | undefined;
    affiliateRateTier2!: number | undefined;
    dateTime!: moment.Moment;
    userId!: number | undefined;
    userName!: string | undefined;
    userPhotoPublicId!: string | undefined;

    constructor(data?: IAffiliateInfoHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affiliateContactId = _data["affiliateContactId"];
            this.affiliateContactName = _data["affiliateContactName"];
            this.affiliateContactAffiliateCode = _data["affiliateContactAffiliateCode"];
            this.affiliateContactPhotoPublicId = _data["affiliateContactPhotoPublicId"];
            this.affiliateCode = _data["affiliateCode"];
            this.affiliateRate = _data["affiliateRate"];
            this.affiliateRateTier2 = _data["affiliateRateTier2"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userPhotoPublicId = _data["userPhotoPublicId"];
        }
    }

    static fromJS(data: any): AffiliateInfoHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AffiliateInfoHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affiliateContactId"] = this.affiliateContactId;
        data["affiliateContactName"] = this.affiliateContactName;
        data["affiliateContactAffiliateCode"] = this.affiliateContactAffiliateCode;
        data["affiliateContactPhotoPublicId"] = this.affiliateContactPhotoPublicId;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateRate"] = this.affiliateRate;
        data["affiliateRateTier2"] = this.affiliateRateTier2;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userPhotoPublicId"] = this.userPhotoPublicId;
        return data;
    }
}

export interface IAffiliateInfoHistoryInfo {
    affiliateContactId: number | undefined;
    affiliateContactName: string | undefined;
    affiliateContactAffiliateCode: string | undefined;
    affiliateContactPhotoPublicId: string | undefined;
    affiliateCode: string | undefined;
    affiliateRate: number | undefined;
    affiliateRateTier2: number | undefined;
    dateTime: moment.Moment;
    userId: number | undefined;
    userName: string | undefined;
    userPhotoPublicId: string | undefined;
}

export class AffiliateLinkInfo implements IAffiliateLinkInfo {
    id!: number;
    category!: string | undefined;
    companyName!: string | undefined;
    phoneNumber!: string | undefined;
    url!: string | undefined;
    suggestedCopy!: string | undefined;
    imageUrl!: string | undefined;

    constructor(data?: IAffiliateLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"];
            this.companyName = _data["companyName"];
            this.phoneNumber = _data["phoneNumber"];
            this.url = _data["url"];
            this.suggestedCopy = _data["suggestedCopy"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): AffiliateLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AffiliateLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category;
        data["companyName"] = this.companyName;
        data["phoneNumber"] = this.phoneNumber;
        data["url"] = this.url;
        data["suggestedCopy"] = this.suggestedCopy;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IAffiliateLinkInfo {
    id: number;
    category: string | undefined;
    companyName: string | undefined;
    phoneNumber: string | undefined;
    url: string | undefined;
    suggestedCopy: string | undefined;
    imageUrl: string | undefined;
}

export enum AffiliateServiceStatus {
    Unavailable = "Unavailable",
    Available = "Available",
    FullAccess = "FullAccess",
}

export enum AgentDataSource {
    Sticky = "Sticky",
    Konnective = "Konnective",
}

export class AlertDto implements IAlertDto {
    type!: AlertType;
    bureau!: Bureau | undefined;
    date!: moment.Moment;
    text!: string | undefined;

    constructor(data?: IAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.bureau = _data["bureau"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): AlertDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["text"] = this.text;
        return data;
    }
}

export interface IAlertDto {
    type: AlertType;
    bureau: Bureau | undefined;
    date: moment.Moment;
    text: string | undefined;
}

export enum AlertType {
    BalancePositive = 0,
    BalanceNegative = 1,
    Security = 2,
}

export enum AmountFormat {
    Debits = "Debits",
    Credits = "Credits",
}

export class AnswerDto implements IAnswerDto {
    questionId!: number;
    options!: number[] | undefined;

    constructor(data?: IAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        return data;
    }
}

export interface IAnswerDto {
    questionId: number;
    options: number[] | undefined;
}

export class ApiKeyInfo implements IApiKeyInfo {
    id!: number;
    name!: string | undefined;
    key!: string | undefined;
    expirationDate!: moment.Moment | undefined;
    creationTime!: moment.Moment;
    userId!: number;
    userName!: string | undefined;
    paths!: string | undefined;

    constructor(data?: IApiKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.key = _data["key"];
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.paths = _data["paths"];
        }
    }

    static fromJS(data: any): ApiKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["key"] = this.key;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["paths"] = this.paths;
        return data;
    }
}

export interface IApiKeyInfo {
    id: number;
    name: string | undefined;
    key: string | undefined;
    expirationDate: moment.Moment | undefined;
    creationTime: moment.Moment;
    userId: number;
    userName: string | undefined;
    paths: string | undefined;
}

export enum Appliances {
    Dishwasher = 1,
    Dryer = 2,
    Fridge = 4,
    Microwave = 8,
    Stove = 16,
    Washer = 32,
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment;
    currency!: string | undefined;
    currencySign!: string | undefined;
    userDelegationIsEnabled!: boolean;
    twoFactorCodeExpireSeconds!: number;
    features!: { [key: string]: AbpStringValueDto; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            this.twoFactorCodeExpireSeconds = _data["twoFactorCodeExpireSeconds"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key] ? AbpStringValueDto.fromJS(_data["features"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        data["twoFactorCodeExpireSeconds"] = this.twoFactorCodeExpireSeconds;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key] ? this.features[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    currency: string | undefined;
    currencySign: string | undefined;
    userDelegationIsEnabled: boolean;
    twoFactorCodeExpireSeconds: number;
    features: { [key: string]: AbpStringValueDto; } | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum ApplyToTransactionsOption {
    None = "None",
    MatchedAndUnclassified = "MatchedAndUnclassified",
    SelectedOnly = "SelectedOnly",
    AllExisting = "AllExisting",
}

export class AssignActivityUserDto implements IAssignActivityUserDto {
    id!: number;
    assignedUserIds!: number[] | undefined;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: IAssignActivityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["assignedUserIds"])) {
                this.assignedUserIds = [] as any;
                for (let item of _data["assignedUserIds"])
                    this.assignedUserIds!.push(item);
            }
            this.sortOrder = _data["sortOrder"];
            this.stageId = _data["stageId"];
        }
    }

    static fromJS(data: any): AssignActivityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignActivityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.assignedUserIds)) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data;
    }
}

export interface IAssignActivityUserDto {
    id: number;
    assignedUserIds: number[] | undefined;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class AssignUserForEachInput implements IAssignUserForEachInput {
    ids!: number[];
    userId!: number | undefined;

    constructor(data?: IAssignUserForEachInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AssignUserForEachInput {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserForEachInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAssignUserForEachInput {
    ids: number[];
    userId: number | undefined;
}

export class AssignUserInput implements IAssignUserInput {
    id!: number;
    userId!: number | undefined;

    constructor(data?: IAssignUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AssignUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAssignUserInput {
    id: number;
    userId: number | undefined;
}

export class Attachment implements IAttachment {
    id!: string;
    size!: number;
    name!: string | undefined;
    url!: string | undefined;

    constructor(data?: IAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.size = _data["size"];
            this.name = _data["name"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Attachment {
        data = typeof data === 'object' ? data : {};
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["size"] = this.size;
        data["name"] = this.name;
        data["url"] = this.url;
        return data;
    }
}

export interface IAttachment {
    id: string;
    size: number;
    name: string | undefined;
    url: string | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    name!: string | undefined;
    size!: number;
    fileId!: string;
    id!: string;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.size = _data["size"];
            this.fileId = _data["fileId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["size"] = this.size;
        data["fileId"] = this.fileId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAttachmentDto {
    name: string | undefined;
    size: number;
    fileId: string;
    id: string;
}

export class AttributeValuesDto implements IAttributeValuesDto {
    attributeTypeId!: string | undefined;
    attributeValues!: string[] | undefined;

    constructor(data?: IAttributeValuesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeTypeId = _data["attributeTypeId"];
            if (Array.isArray(_data["attributeValues"])) {
                this.attributeValues = [] as any;
                for (let item of _data["attributeValues"])
                    this.attributeValues!.push(item);
            }
        }
    }

    static fromJS(data: any): AttributeValuesDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeValuesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        if (Array.isArray(this.attributeValues)) {
            data["attributeValues"] = [];
            for (let item of this.attributeValues)
                data["attributeValues"].push(item);
        }
        return data;
    }
}

export interface IAttributeValuesDto {
    attributeTypeId: string | undefined;
    attributeValues: string[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class AuthenticateByCodeModel implements IAuthenticateByCodeModel {
    emailAddress!: string;
    code!: string;

    constructor(data?: IAuthenticateByCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AuthenticateByCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateByCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["code"] = this.code;
        return data;
    }
}

export interface IAuthenticateByCodeModel {
    emailAddress: string;
    code: string;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    autoDetectTenancy!: boolean;
    features!: string[] | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.autoDetectTenancy = _data["autoDetectTenancy"] !== undefined ? _data["autoDetectTenancy"] : false;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(item);
            }
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    autoDetectTenancy: boolean;
    features: string[] | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    detectedTenancies!: TenantModel[] | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            if (Array.isArray(_data["detectedTenancies"])) {
                this.detectedTenancies = [] as any;
                for (let item of _data["detectedTenancies"])
                    this.detectedTenancies!.push(TenantModel.fromJS(item));
            }
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (Array.isArray(this.detectedTenancies)) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    detectedTenancies: TenantModel[] | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class AuthTestOutput implements IAuthTestOutput {
    tenantName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IAuthTestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): AuthTestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IAuthTestOutput {
    tenantName: string | undefined;
    userName: string | undefined;
}

export class AutoClassifyDto implements IAutoClassifyDto {
    bankAccountIds!: number[] | undefined;

    constructor(data?: IAutoClassifyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bankAccountIds"])) {
                this.bankAccountIds = [] as any;
                for (let item of _data["bankAccountIds"])
                    this.bankAccountIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AutoClassifyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoClassifyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bankAccountIds)) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        return data;
    }
}

export interface IAutoClassifyDto {
    bankAccountIds: number[] | undefined;
}

export class BankAccountBalanceDto implements IBankAccountBalanceDto {
    bankAccountId!: number;
    currencyId!: string | undefined;
    balance!: number;
    balanceDate!: moment.Moment | undefined;
    isActive!: boolean;

    constructor(data?: IBankAccountBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountId = _data["bankAccountId"];
            this.currencyId = _data["currencyId"];
            this.balance = _data["balance"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BankAccountBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["currencyId"] = this.currencyId;
        data["balance"] = this.balance;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IBankAccountBalanceDto {
    bankAccountId: number;
    currencyId: string | undefined;
    balance: number;
    balanceDate: moment.Moment | undefined;
    isActive: boolean;
}

export class BankAccountDailyStatDto implements IBankAccountDailyStatDto {
    date!: moment.Moment;
    startingBalance!: number | undefined;
    startingBalanceAdjustments!: number | undefined;
    inflows!: number | undefined;
    outflows!: number | undefined;
    adjustments!: number | undefined;
    endingBalance!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    averageDailyBalance!: number | undefined;
    creditCount!: number;
    debitCount!: number;
    period!: GroupByPeriod;
    isForecast!: boolean;

    constructor(data?: IBankAccountDailyStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startingBalance = _data["startingBalance"];
            this.startingBalanceAdjustments = _data["startingBalanceAdjustments"];
            this.inflows = _data["inflows"];
            this.outflows = _data["outflows"];
            this.adjustments = _data["adjustments"];
            this.endingBalance = _data["endingBalance"];
            this.debit = _data["debit"];
            this.credit = _data["credit"];
            this.averageDailyBalance = _data["averageDailyBalance"];
            this.creditCount = _data["creditCount"];
            this.debitCount = _data["debitCount"];
            this.period = _data["period"];
            this.isForecast = _data["isForecast"];
        }
    }

    static fromJS(data: any): BankAccountDailyStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDailyStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startingBalance"] = this.startingBalance;
        data["startingBalanceAdjustments"] = this.startingBalanceAdjustments;
        data["inflows"] = this.inflows;
        data["outflows"] = this.outflows;
        data["adjustments"] = this.adjustments;
        data["endingBalance"] = this.endingBalance;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["averageDailyBalance"] = this.averageDailyBalance;
        data["creditCount"] = this.creditCount;
        data["debitCount"] = this.debitCount;
        data["period"] = this.period;
        data["isForecast"] = this.isForecast;
        return data;
    }
}

export interface IBankAccountDailyStatDto {
    date: moment.Moment;
    startingBalance: number | undefined;
    startingBalanceAdjustments: number | undefined;
    inflows: number | undefined;
    outflows: number | undefined;
    adjustments: number | undefined;
    endingBalance: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
    averageDailyBalance: number | undefined;
    creditCount: number;
    debitCount: number;
    period: GroupByPeriod;
    isForecast: boolean;
}

export class BankAccountDto implements IBankAccountDto {
    id!: number;
    typeId!: string | undefined;
    typeName!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    businessEntityName!: string | undefined;
    businessEntityId!: number | undefined;
    isActive!: boolean;
    balance!: number | undefined;
    totalCreditLine!: number | undefined;
    readonly availableBalance!: number | undefined;
    readonly utilized!: number | undefined;
    syncAccountId!: number;
    isUsed!: boolean;
    lastSyncDate!: moment.Moment | undefined;
    lastGoodSyncDate!: moment.Moment | undefined;
    syncStatus!: SyncProgressStatus;

    constructor(data?: IBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.typeName = _data["typeName"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.businessEntityName = _data["businessEntityName"];
            this.businessEntityId = _data["businessEntityId"];
            this.isActive = _data["isActive"];
            this.balance = _data["balance"];
            this.totalCreditLine = _data["totalCreditLine"];
            (<any>this).availableBalance = _data["availableBalance"];
            (<any>this).utilized = _data["utilized"];
            this.syncAccountId = _data["syncAccountId"];
            this.isUsed = _data["isUsed"];
            this.lastSyncDate = _data["lastSyncDate"] ? moment(_data["lastSyncDate"].toString()) : <any>undefined;
            this.lastGoodSyncDate = _data["lastGoodSyncDate"] ? moment(_data["lastGoodSyncDate"].toString()) : <any>undefined;
            this.syncStatus = _data["syncStatus"];
        }
    }

    static fromJS(data: any): BankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["businessEntityName"] = this.businessEntityName;
        data["businessEntityId"] = this.businessEntityId;
        data["isActive"] = this.isActive;
        data["balance"] = this.balance;
        data["totalCreditLine"] = this.totalCreditLine;
        data["availableBalance"] = this.availableBalance;
        data["utilized"] = this.utilized;
        data["syncAccountId"] = this.syncAccountId;
        data["isUsed"] = this.isUsed;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["lastGoodSyncDate"] = this.lastGoodSyncDate ? this.lastGoodSyncDate.toISOString() : <any>undefined;
        data["syncStatus"] = this.syncStatus;
        return data;
    }
}

export interface IBankAccountDto {
    id: number;
    typeId: string | undefined;
    typeName: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    businessEntityName: string | undefined;
    businessEntityId: number | undefined;
    isActive: boolean;
    balance: number | undefined;
    totalCreditLine: number | undefined;
    availableBalance: number | undefined;
    utilized: number | undefined;
    syncAccountId: number;
    isUsed: boolean;
    lastSyncDate: moment.Moment | undefined;
    lastGoodSyncDate: moment.Moment | undefined;
    syncStatus: SyncProgressStatus;
}

export class BankAccountProgress implements IBankAccountProgress {
    id!: number;
    syncStatus!: SyncProgressStatus;
    lastSyncDate!: moment.Moment | undefined;
    lastGoodSyncDate!: moment.Moment | undefined;

    constructor(data?: IBankAccountProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.syncStatus = _data["syncStatus"];
            this.lastSyncDate = _data["lastSyncDate"] ? moment(_data["lastSyncDate"].toString()) : <any>undefined;
            this.lastGoodSyncDate = _data["lastGoodSyncDate"] ? moment(_data["lastGoodSyncDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccountProgress {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["syncStatus"] = this.syncStatus;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["lastGoodSyncDate"] = this.lastGoodSyncDate ? this.lastGoodSyncDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBankAccountProgress {
    id: number;
    syncStatus: SyncProgressStatus;
    lastSyncDate: moment.Moment | undefined;
    lastGoodSyncDate: moment.Moment | undefined;
}

export enum BankAccountType {
    Checking = "Checking",
    Savings = "Savings",
}

export class BankAccountUsers implements IBankAccountUsers {
    bankAccountId!: number;
    userIds!: number[] | undefined;

    constructor(data?: IBankAccountUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountId = _data["bankAccountId"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BankAccountUsers {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface IBankAccountUsers {
    bankAccountId: number;
    userIds: number[] | undefined;
}

export class BankCardDto implements IBankCardDto {
    holderName!: string;
    cardNumber!: string;
    expirationMonth!: string;
    expirationYear!: string;
    cvv!: string;
    billingAddress!: string;
    billingZip!: string;
    billingCity!: string;
    billingStateCode!: string | undefined;
    billingState!: string | undefined;
    billingCountryCode!: string;
    billingCountry!: string | undefined;

    constructor(data?: IBankCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holderName = _data["holderName"];
            this.cardNumber = _data["cardNumber"];
            this.expirationMonth = _data["expirationMonth"];
            this.expirationYear = _data["expirationYear"];
            this.cvv = _data["cvv"];
            this.billingAddress = _data["billingAddress"];
            this.billingZip = _data["billingZip"];
            this.billingCity = _data["billingCity"];
            this.billingStateCode = _data["billingStateCode"];
            this.billingState = _data["billingState"];
            this.billingCountryCode = _data["billingCountryCode"];
            this.billingCountry = _data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data;
    }
}

export interface IBankCardDto {
    holderName: string;
    cardNumber: string;
    expirationMonth: string;
    expirationYear: string;
    cvv: string;
    billingAddress: string;
    billingZip: string;
    billingCity: string;
    billingStateCode: string | undefined;
    billingState: string | undefined;
    billingCountryCode: string;
    billingCountry: string | undefined;
}

export class BankCardInfoDto implements IBankCardInfoDto {
    holderName!: string | undefined;
    cardNumber!: string | undefined;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;
    cvv!: string | undefined;
    billingAddress!: string | undefined;
    billingZip!: string | undefined;
    billingCity!: string | undefined;
    billingStateCode!: string | undefined;
    billingState!: string | undefined;
    billingCountryCode!: string | undefined;
    billingCountry!: string | undefined;

    constructor(data?: IBankCardInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holderName = _data["holderName"];
            this.cardNumber = _data["cardNumber"];
            this.expirationMonth = _data["expirationMonth"];
            this.expirationYear = _data["expirationYear"];
            this.cvv = _data["cvv"];
            this.billingAddress = _data["billingAddress"];
            this.billingZip = _data["billingZip"];
            this.billingCity = _data["billingCity"];
            this.billingStateCode = _data["billingStateCode"];
            this.billingState = _data["billingState"];
            this.billingCountryCode = _data["billingCountryCode"];
            this.billingCountry = _data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data;
    }
}

export interface IBankCardInfoDto {
    holderName: string | undefined;
    cardNumber: string | undefined;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
    cvv: string | undefined;
    billingAddress: string | undefined;
    billingZip: string | undefined;
    billingCity: string | undefined;
    billingStateCode: string | undefined;
    billingState: string | undefined;
    billingCountryCode: string | undefined;
    billingCountry: string | undefined;
}

export class BankCardInput implements IBankCardInput {
    holderName!: string | undefined;
    cardNumber!: string;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;
    billingAddress!: string | undefined;
    billingZip!: string | undefined;
    billingCity!: string | undefined;
    billingStateCode!: string | undefined;
    billingCountryCode!: string | undefined;

    constructor(data?: IBankCardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holderName = _data["holderName"];
            this.cardNumber = _data["cardNumber"];
            this.expirationMonth = _data["expirationMonth"];
            this.expirationYear = _data["expirationYear"];
            this.billingAddress = _data["billingAddress"];
            this.billingZip = _data["billingZip"];
            this.billingCity = _data["billingCity"];
            this.billingStateCode = _data["billingStateCode"];
            this.billingCountryCode = _data["billingCountryCode"];
        }
    }

    static fromJS(data: any): BankCardInput {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingCountryCode"] = this.billingCountryCode;
        return data;
    }
}

export interface IBankCardInput {
    holderName: string | undefined;
    cardNumber: string;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
    billingAddress: string | undefined;
    billingZip: string | undefined;
    billingCity: string | undefined;
    billingStateCode: string | undefined;
    billingCountryCode: string | undefined;
}

export class BankCardShortInfo implements IBankCardShortInfo {
    cardNumber!: string | undefined;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;

    constructor(data?: IBankCardShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cardNumber = _data["cardNumber"];
            this.expirationMonth = _data["expirationMonth"];
            this.expirationYear = _data["expirationYear"];
        }
    }

    static fromJS(data: any): BankCardShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        return data;
    }
}

export interface IBankCardShortInfo {
    cardNumber: string | undefined;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
}

export class BankCodeHistoryInfo implements IBankCodeHistoryInfo {
    bankCode!: string | undefined;
    source!: string | undefined;
    overridden!: boolean;
    selfAssessmentB!: number | undefined;
    selfAssessmentA!: number | undefined;
    selfAssessmentN!: number | undefined;
    selfAssessmentK!: number | undefined;
    dateTime!: moment.Moment;
    userId!: number | undefined;
    userName!: string | undefined;
    userPhotoPublicId!: string | undefined;

    constructor(data?: IBankCodeHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.source = _data["source"];
            this.overridden = _data["overridden"];
            this.selfAssessmentB = _data["selfAssessmentB"];
            this.selfAssessmentA = _data["selfAssessmentA"];
            this.selfAssessmentN = _data["selfAssessmentN"];
            this.selfAssessmentK = _data["selfAssessmentK"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userPhotoPublicId = _data["userPhotoPublicId"];
        }
    }

    static fromJS(data: any): BankCodeHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCodeHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["source"] = this.source;
        data["overridden"] = this.overridden;
        data["selfAssessmentB"] = this.selfAssessmentB;
        data["selfAssessmentA"] = this.selfAssessmentA;
        data["selfAssessmentN"] = this.selfAssessmentN;
        data["selfAssessmentK"] = this.selfAssessmentK;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userPhotoPublicId"] = this.userPhotoPublicId;
        return data;
    }
}

export interface IBankCodeHistoryInfo {
    bankCode: string | undefined;
    source: string | undefined;
    overridden: boolean;
    selfAssessmentB: number | undefined;
    selfAssessmentA: number | undefined;
    selfAssessmentN: number | undefined;
    selfAssessmentK: number | undefined;
    dateTime: moment.Moment;
    userId: number | undefined;
    userName: string | undefined;
    userPhotoPublicId: string | undefined;
}

export class BANKCodeSelfAssessmentDto implements IBANKCodeSelfAssessmentDto {
    b!: number;
    a!: number;
    n!: number;
    k!: number;

    constructor(data?: IBANKCodeSelfAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.b = _data["b"];
            this.a = _data["a"];
            this.n = _data["n"];
            this.k = _data["k"];
        }
    }

    static fromJS(data: any): BANKCodeSelfAssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BANKCodeSelfAssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["b"] = this.b;
        data["a"] = this.a;
        data["n"] = this.n;
        data["k"] = this.k;
        return data;
    }
}

export interface IBANKCodeSelfAssessmentDto {
    b: number;
    a: number;
    n: number;
    k: number;
}

export class BANKCodeUserSettings implements IBANKCodeUserSettings {
    isSetupWizardEnabled!: boolean;
    isWelcomeVideoWatched!: boolean;

    constructor(data?: IBANKCodeUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSetupWizardEnabled = _data["isSetupWizardEnabled"];
            this.isWelcomeVideoWatched = _data["isWelcomeVideoWatched"];
        }
    }

    static fromJS(data: any): BANKCodeUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BANKCodeUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSetupWizardEnabled"] = this.isSetupWizardEnabled;
        data["isWelcomeVideoWatched"] = this.isWelcomeVideoWatched;
        return data;
    }
}

export interface IBANKCodeUserSettings {
    isSetupWizardEnabled: boolean;
    isWelcomeVideoWatched: boolean;
}

export class BankDto implements IBankDto {
    id!: number;
    name!: string | undefined;
    bankAccounts!: BankAccountDto[] | undefined;

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["bankAccounts"])) {
                this.bankAccounts = [] as any;
                for (let item of _data["bankAccounts"])
                    this.bankAccounts!.push(BankAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.bankAccounts)) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBankDto {
    id: number;
    name: string | undefined;
    bankAccounts: BankAccountDto[] | undefined;
}

export class BankInformation implements IBankInformation {
    bankAccountType!: BankAccountType | undefined;
    bankName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankABA!: string | undefined;
    bankPhone!: string | undefined;
    isDirectDeposit!: boolean | undefined;
    monthsAtBank!: number | undefined;

    constructor(data?: IBankInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountType = _data["bankAccountType"];
            this.bankName = _data["bankName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankABA = _data["bankABA"];
            this.bankPhone = _data["bankPhone"];
            this.isDirectDeposit = _data["isDirectDeposit"];
            this.monthsAtBank = _data["monthsAtBank"];
        }
    }

    static fromJS(data: any): BankInformation {
        data = typeof data === 'object' ? data : {};
        let result = new BankInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountType"] = this.bankAccountType;
        data["bankName"] = this.bankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankABA"] = this.bankABA;
        data["bankPhone"] = this.bankPhone;
        data["isDirectDeposit"] = this.isDirectDeposit;
        data["monthsAtBank"] = this.monthsAtBank;
        return data;
    }
}

export interface IBankInformation {
    bankAccountType: BankAccountType | undefined;
    bankName: string | undefined;
    bankAccountNumber: string | undefined;
    bankABA: string | undefined;
    bankPhone: string | undefined;
    isDirectDeposit: boolean | undefined;
    monthsAtBank: number | undefined;
}

export class BankTransferSettings implements IBankTransferSettings {
    beneficiaryInfo!: BeneficiaryInfo | undefined;
    beneficiaryBank!: BeneficiaryInfo | undefined;
    bankAccountNumber!: string | undefined;
    bankRoutingNumberForACH!: string | undefined;
    bankRoutingNumber!: string | undefined;
    swiftCodeForUSDollar!: string | undefined;
    swiftCode!: string | undefined;

    constructor(data?: IBankTransferSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beneficiaryInfo = _data["beneficiaryInfo"] ? BeneficiaryInfo.fromJS(_data["beneficiaryInfo"]) : <any>undefined;
            this.beneficiaryBank = _data["beneficiaryBank"] ? BeneficiaryInfo.fromJS(_data["beneficiaryBank"]) : <any>undefined;
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankRoutingNumberForACH = _data["bankRoutingNumberForACH"];
            this.bankRoutingNumber = _data["bankRoutingNumber"];
            this.swiftCodeForUSDollar = _data["swiftCodeForUSDollar"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static fromJS(data: any): BankTransferSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransferSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryInfo"] = this.beneficiaryInfo ? this.beneficiaryInfo.toJSON() : <any>undefined;
        data["beneficiaryBank"] = this.beneficiaryBank ? this.beneficiaryBank.toJSON() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankRoutingNumberForACH"] = this.bankRoutingNumberForACH;
        data["bankRoutingNumber"] = this.bankRoutingNumber;
        data["swiftCodeForUSDollar"] = this.swiftCodeForUSDollar;
        data["swiftCode"] = this.swiftCode;
        return data;
    }
}

export interface IBankTransferSettings {
    beneficiaryInfo: BeneficiaryInfo | undefined;
    beneficiaryBank: BeneficiaryInfo | undefined;
    bankAccountNumber: string | undefined;
    bankRoutingNumberForACH: string | undefined;
    bankRoutingNumber: string | undefined;
    swiftCodeForUSDollar: string | undefined;
    swiftCode: string | undefined;
}

export class BankTransferSettingsDto implements IBankTransferSettingsDto {
    beneficiaryInfo!: BeneficiaryInfoDto | undefined;
    beneficiaryBank!: BeneficiaryInfoDto | undefined;
    bankAccountNumber!: string | undefined;
    bankRoutingNumberForACH!: string | undefined;
    bankRoutingNumber!: string | undefined;
    swiftCodeForUSDollar!: string | undefined;
    swiftCode!: string | undefined;

    constructor(data?: IBankTransferSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beneficiaryInfo = _data["beneficiaryInfo"] ? BeneficiaryInfoDto.fromJS(_data["beneficiaryInfo"]) : <any>undefined;
            this.beneficiaryBank = _data["beneficiaryBank"] ? BeneficiaryInfoDto.fromJS(_data["beneficiaryBank"]) : <any>undefined;
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankRoutingNumberForACH = _data["bankRoutingNumberForACH"];
            this.bankRoutingNumber = _data["bankRoutingNumber"];
            this.swiftCodeForUSDollar = _data["swiftCodeForUSDollar"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static fromJS(data: any): BankTransferSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransferSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryInfo"] = this.beneficiaryInfo ? this.beneficiaryInfo.toJSON() : <any>undefined;
        data["beneficiaryBank"] = this.beneficiaryBank ? this.beneficiaryBank.toJSON() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankRoutingNumberForACH"] = this.bankRoutingNumberForACH;
        data["bankRoutingNumber"] = this.bankRoutingNumber;
        data["swiftCodeForUSDollar"] = this.swiftCodeForUSDollar;
        data["swiftCode"] = this.swiftCode;
        return data;
    }
}

export interface IBankTransferSettingsDto {
    beneficiaryInfo: BeneficiaryInfoDto | undefined;
    beneficiaryBank: BeneficiaryInfoDto | undefined;
    bankAccountNumber: string | undefined;
    bankRoutingNumberForACH: string | undefined;
    bankRoutingNumber: string | undefined;
    swiftCodeForUSDollar: string | undefined;
    swiftCode: string | undefined;
}

export class BaseCommercePaymentSettings implements IBaseCommercePaymentSettings {
    userName!: string | undefined;
    password!: string | undefined;
    key!: string | undefined;
    sandBox!: boolean;

    constructor(data?: IBaseCommercePaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.key = _data["key"];
            this.sandBox = _data["sandBox"];
        }
    }

    static fromJS(data: any): BaseCommercePaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCommercePaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["key"] = this.key;
        data["sandBox"] = this.sandBox;
        return data;
    }
}

export interface IBaseCommercePaymentSettings {
    userName: string | undefined;
    password: string | undefined;
    key: string | undefined;
    sandBox: boolean;
}

export enum BasementStatus {
    Finished = "Finished",
    PartiallyFinished = "PartiallyFinished",
    Unfinished = "Unfinished",
}

export class BeneficiaryInfo implements IBeneficiaryInfo {
    name!: string | undefined;
    streetAddress!: string | undefined;
    cityAddress!: string | undefined;

    constructor(data?: IBeneficiaryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.streetAddress = _data["streetAddress"];
            this.cityAddress = _data["cityAddress"];
        }
    }

    static fromJS(data: any): BeneficiaryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["streetAddress"] = this.streetAddress;
        data["cityAddress"] = this.cityAddress;
        return data;
    }
}

export interface IBeneficiaryInfo {
    name: string | undefined;
    streetAddress: string | undefined;
    cityAddress: string | undefined;
}

export class BeneficiaryInfoDto implements IBeneficiaryInfoDto {
    name!: string | undefined;
    streetAddress!: string | undefined;
    cityAddress!: string | undefined;

    constructor(data?: IBeneficiaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.streetAddress = _data["streetAddress"];
            this.cityAddress = _data["cityAddress"];
        }
    }

    static fromJS(data: any): BeneficiaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["streetAddress"] = this.streetAddress;
        data["cityAddress"] = this.cityAddress;
        return data;
    }
}

export interface IBeneficiaryInfoDto {
    name: string | undefined;
    streetAddress: string | undefined;
    cityAddress: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class BudgetDto implements IBudgetDto {
    businessEntityId!: number;
    categoryId!: number;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    amount!: number;

    constructor(data?: IBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessEntityId = _data["businessEntityId"];
            this.categoryId = _data["categoryId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): BudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        data["categoryId"] = this.categoryId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IBudgetDto {
    businessEntityId: number;
    categoryId: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    amount: number;
}

export class BudgetImportInput implements IBudgetImportInput {
    year!: number;
    businessEntityId!: number;
    currencyId!: string;
    excelFile!: string | undefined;
    override!: boolean;

    constructor(data?: IBudgetImportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.businessEntityId = _data["businessEntityId"];
            this.currencyId = _data["currencyId"];
            this.excelFile = _data["excelFile"];
            this.override = _data["override"];
        }
    }

    static fromJS(data: any): BudgetImportInput {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetImportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["businessEntityId"] = this.businessEntityId;
        data["currencyId"] = this.currencyId;
        data["excelFile"] = this.excelFile;
        data["override"] = this.override;
        return data;
    }
}

export interface IBudgetImportInput {
    year: number;
    businessEntityId: number;
    currencyId: string;
    excelFile: string | undefined;
    override: boolean;
}

export class BugsnagSettingsDto implements IBugsnagSettingsDto {
    appApiKey!: string | undefined;
    uiApiKey!: string | undefined;

    constructor(data?: IBugsnagSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appApiKey = _data["appApiKey"];
            this.uiApiKey = _data["uiApiKey"];
        }
    }

    static fromJS(data: any): BugsnagSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugsnagSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appApiKey"] = this.appApiKey;
        data["uiApiKey"] = this.uiApiKey;
        return data;
    }
}

export interface IBugsnagSettingsDto {
    appApiKey: string | undefined;
    uiApiKey: string | undefined;
}

export class BulkSendEmailInput implements IBulkSendEmailInput {
    contactIds!: number[] | undefined;
    emailSettingsSource!: EmailSettingsSource;
    subject!: string;
    previewText!: string | undefined;
    saveAttachmentsToDocuments!: boolean;
    attachments!: FileInfo[] | undefined;
    replyTo!: string[] | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string;

    constructor(data?: IBulkSendEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            this.emailSettingsSource = _data["emailSettingsSource"];
            this.subject = _data["subject"];
            this.previewText = _data["previewText"];
            this.saveAttachmentsToDocuments = _data["saveAttachmentsToDocuments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(FileInfo.fromJS(item));
            }
            if (Array.isArray(_data["replyTo"])) {
                this.replyTo = [] as any;
                for (let item of _data["replyTo"])
                    this.replyTo!.push(item);
            }
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): BulkSendEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new BulkSendEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["emailSettingsSource"] = this.emailSettingsSource;
        data["subject"] = this.subject;
        data["previewText"] = this.previewText;
        data["saveAttachmentsToDocuments"] = this.saveAttachmentsToDocuments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.replyTo)) {
            data["replyTo"] = [];
            for (let item of this.replyTo)
                data["replyTo"].push(item);
        }
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        return data;
    }
}

export interface IBulkSendEmailInput {
    contactIds: number[] | undefined;
    emailSettingsSource: EmailSettingsSource;
    subject: string;
    previewText: string | undefined;
    saveAttachmentsToDocuments: boolean;
    attachments: FileInfo[] | undefined;
    replyTo: string[] | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string;
}

export class BulkUpdatePartnerTypeInput implements IBulkUpdatePartnerTypeInput {
    partnerIds!: number[];
    typeName!: string | undefined;

    constructor(data?: IBulkUpdatePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.partnerIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["partnerIds"])) {
                this.partnerIds = [] as any;
                for (let item of _data["partnerIds"])
                    this.partnerIds!.push(item);
            }
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): BulkUpdatePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdatePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.partnerIds)) {
            data["partnerIds"] = [];
            for (let item of this.partnerIds)
                data["partnerIds"].push(item);
        }
        data["typeName"] = this.typeName;
        return data;
    }
}

export interface IBulkUpdatePartnerTypeInput {
    partnerIds: number[];
    typeName: string | undefined;
}

export enum Bureau {
    TransUnion = "TransUnion",
    Experian = "Experian",
    Equifax = "Equifax",
}

export class BusinessEntityBankAccountDto implements IBusinessEntityBankAccountDto {
    readonly bankAccountId!: number;
    readonly bankName!: string | undefined;
    readonly accountName!: string | undefined;
    readonly accountNumber!: string | undefined;
    isLinked!: boolean;
    isUsed!: boolean;

    constructor(data?: IBusinessEntityBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).bankAccountId = _data["bankAccountId"];
            (<any>this).bankName = _data["bankName"];
            (<any>this).accountName = _data["accountName"];
            (<any>this).accountNumber = _data["accountNumber"];
            this.isLinked = _data["isLinked"];
            this.isUsed = _data["isUsed"];
        }
    }

    static fromJS(data: any): BusinessEntityBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["bankName"] = this.bankName;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["isLinked"] = this.isLinked;
        data["isUsed"] = this.isUsed;
        return data;
    }
}

export interface IBusinessEntityBankAccountDto {
    bankAccountId: number;
    bankName: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    isLinked: boolean;
    isUsed: boolean;
}

export class BusinessEntityDto implements IBusinessEntityDto {
    id!: number;
    name!: string | undefined;
    isDefault!: boolean;
    parentId!: number | undefined;
    hasChildren!: boolean;

    constructor(data?: IBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.parentId = _data["parentId"];
            this.hasChildren = _data["hasChildren"];
        }
    }

    static fromJS(data: any): BusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["parentId"] = this.parentId;
        data["hasChildren"] = this.hasChildren;
        return data;
    }
}

export interface IBusinessEntityDto {
    id: number;
    name: string | undefined;
    isDefault: boolean;
    parentId: number | undefined;
    hasChildren: boolean;
}

export class BusinessEntityInfoDto implements IBusinessEntityInfoDto {
    name!: string | undefined;
    parentId!: number | undefined;
    industry!: string | undefined;
    type!: BusinessEntityType | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    streetAddress!: string | undefined;
    status!: BusinessEntityStatus;
    isDefault!: boolean;
    id!: number;

    constructor(data?: IBusinessEntityInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.industry = _data["industry"];
            this.type = _data["type"];
            this.taxNumber = _data["taxNumber"];
            this.dateOpened = _data["dateOpened"] ? moment(_data["dateOpened"].toString()) : <any>undefined;
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.alternativeEmail = _data["alternativeEmail"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.streetAddress = _data["streetAddress"];
            this.status = _data["status"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessEntityInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["status"] = this.status;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessEntityInfoDto {
    name: string | undefined;
    parentId: number | undefined;
    industry: string | undefined;
    type: BusinessEntityType | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    streetAddress: string | undefined;
    status: BusinessEntityStatus;
    isDefault: boolean;
    id: number;
}

export enum BusinessEntityStatus {
    Active = "Active",
    Inactive = "Inactive",
}

export enum BusinessEntityType {
    Other = "Other",
    LLC = "LLC",
    SoleProprietership = "Sole Proprietership",
    LLP = "LLP",
    LLLP = "LLLP",
    Corp = "Corp",
    Trust = "Trust",
    LP = "LP",
    Inc = "Inc",
    Partnership = "Partnership",
}

export class BusinessEntityTypeDto implements IBusinessEntityTypeDto {
    readonly id!: BusinessEntityType;
    readonly name!: string | undefined;

    constructor(data?: IBusinessEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): BusinessEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IBusinessEntityTypeDto {
    id: BusinessEntityType;
    name: string | undefined;
}

export class BusinessEntityUpdateBankAccountsInput implements IBusinessEntityUpdateBankAccountsInput {
    businessEntityId!: number;
    bankAccountIds!: number[];
    isLinked!: boolean;

    constructor(data?: IBusinessEntityUpdateBankAccountsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bankAccountIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessEntityId = _data["businessEntityId"];
            if (Array.isArray(_data["bankAccountIds"])) {
                this.bankAccountIds = [] as any;
                for (let item of _data["bankAccountIds"])
                    this.bankAccountIds!.push(item);
            }
            this.isLinked = _data["isLinked"];
        }
    }

    static fromJS(data: any): BusinessEntityUpdateBankAccountsInput {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityUpdateBankAccountsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        if (Array.isArray(this.bankAccountIds)) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["isLinked"] = this.isLinked;
        return data;
    }
}

export interface IBusinessEntityUpdateBankAccountsInput {
    businessEntityId: number;
    bankAccountIds: number[];
    isLinked: boolean;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export enum CampaignCategory {
    PaydayLoans = "PaydayLoans",
    PersonalLoans = "PersonalLoans",
    Beauty = "Beauty",
    InstallmentLoans = "InstallmentLoans",
    AutoLoans = "AutoLoans",
    Legal = "Legal",
    CreditRepair = "CreditRepair",
    CreditScore = "CreditScore",
    Travel = "Travel",
    Jobs = "Jobs",
    BusinessLoans = "BusinessLoans",
    DebtConsolidation = "DebtConsolidation",
    CreditCards = "CreditCards",
    MerchantServices = "MerchantServices",
    Dating = "Dating",
    Miscellaneous = "Miscellaneous",
    Crypto = "Crypto",
    CreditMonitoring = "CreditMonitoring",
}

export enum CampaignProviderType {
    CreditLand = "CreditLand",
}

export enum CampaignStatus {
    PendingReview = "PendingReview",
    Active = "Active",
    Denied = "Denied",
    Suspended = "Suspended",
    SuspendedRisk = "SuspendedRisk",
    Inactive = "Inactive",
    Dormant = "Dormant",
    Deleted = "Deleted",
}

export enum CampaignTrafficSource {
    PPC_Default = "PPC_Default",
    Email = "Email",
    SEO = "SEO",
    SMS = "SMS",
    Decline = "Decline",
    Reject = "Reject",
    Display = "Display",
    Mixed = "Mixed",
    TypeIn = "TypeIn",
    QualityControl = "QualityControl",
    PPC_Email = "PPC_Email",
    PPC_SEO = "PPC_SEO",
    PPC_Decline = "PPC_Decline",
    PPC_Reject = "PPC_Reject",
    PPC_Display = "PPC_Display",
}

export enum CampaignType {
    MultiOfferSinglePage = "MultiOfferSinglePage",
    TrafficDistribution = "TrafficDistribution",
    DirectPost = "DirectPost",
    Carrier = "Carrier",
}

export class CancelAllInput implements ICancelAllInput {
    contactId!: number;
    productCodes!: string[] | undefined;
    serviceCodes!: string[] | undefined;
    cancelationReason!: string | undefined;

    constructor(data?: ICancelAllInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            if (Array.isArray(_data["productCodes"])) {
                this.productCodes = [] as any;
                for (let item of _data["productCodes"])
                    this.productCodes!.push(item);
            }
            if (Array.isArray(_data["serviceCodes"])) {
                this.serviceCodes = [] as any;
                for (let item of _data["serviceCodes"])
                    this.serviceCodes!.push(item);
            }
            this.cancelationReason = _data["cancelationReason"];
        }
    }

    static fromJS(data: any): CancelAllInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelAllInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (Array.isArray(this.productCodes)) {
            data["productCodes"] = [];
            for (let item of this.productCodes)
                data["productCodes"].push(item);
        }
        if (Array.isArray(this.serviceCodes)) {
            data["serviceCodes"] = [];
            for (let item of this.serviceCodes)
                data["serviceCodes"].push(item);
        }
        data["cancelationReason"] = this.cancelationReason;
        return data;
    }
}

export interface ICancelAllInput {
    contactId: number;
    productCodes: string[] | undefined;
    serviceCodes: string[] | undefined;
    cancelationReason: string | undefined;
}

export class CancelLeadInput implements ICancelLeadInput {
    leadId!: number;
    cancellationReasonId!: string;
    comment!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ICancelLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.cancellationReasonId = _data["cancellationReasonId"];
            this.comment = _data["comment"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CancelLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["cancellationReasonId"] = this.cancellationReasonId;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICancelLeadInput {
    leadId: number;
    cancellationReasonId: string;
    comment: string | undefined;
    sortOrder: number | undefined;
}

export class CancelOrderInfo implements ICancelOrderInfo {
    orderId!: number;
    comment!: string;
    sortOrder!: number | undefined;

    constructor(data?: ICancelOrderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.comment = _data["comment"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CancelOrderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICancelOrderInfo {
    orderId: number;
    comment: string;
    sortOrder: number | undefined;
}

export class CancelOrderSubscriptionInput implements ICancelOrderSubscriptionInput {
    subscriptionId!: number;
    cancelationReason!: string | undefined;

    constructor(data?: ICancelOrderSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.cancelationReason = _data["cancelationReason"];
        }
    }

    static fromJS(data: any): CancelOrderSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["cancelationReason"] = this.cancelationReason;
        return data;
    }
}

export interface ICancelOrderSubscriptionInput {
    subscriptionId: number;
    cancelationReason: string | undefined;
}

export enum CardNetwork {
    AmEx = "AmEx",
    Discover = "Discover",
    Mastercard = "Mastercard",
    Visa = "Visa",
    Store = "Store",
}

export enum CardType {
    Credit = "Credit",
    Debit = "Debit",
}

export enum CashFlowAmountFormat {
    Unspecified = "Unspecified",
    Debits = "Debits",
    Credits = "Credits",
}

export class CashFlowCommentThreadDto implements ICashFlowCommentThreadDto {
    threadId!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    cashFlowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    readonly accountId!: number | undefined;
    categorization!: { [key: string]: string; } | undefined;

    constructor(data?: ICashFlowCommentThreadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.threadId = _data["threadId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.cashFlowTypeId = _data["cashFlowTypeId"];
            this.accountingTypeId = _data["accountingTypeId"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            (<any>this).accountId = _data["accountId"];
            if (_data["categorization"]) {
                this.categorization = {} as any;
                for (let key in _data["categorization"]) {
                    if (_data["categorization"].hasOwnProperty(key))
                        (<any>this.categorization)![key] = _data["categorization"][key];
                }
            }
        }
    }

    static fromJS(data: any): CashFlowCommentThreadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowCommentThreadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        if (this.categorization) {
            data["categorization"] = {};
            for (let key in this.categorization) {
                if (this.categorization.hasOwnProperty(key))
                    (<any>data["categorization"])[key] = this.categorization[key];
            }
        }
        return data;
    }
}

export interface ICashFlowCommentThreadDto {
    threadId: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    cashFlowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    accountId: number | undefined;
    categorization: { [key: string]: string; } | undefined;
}

export class CashflowGridGeneralSettingsDto implements ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals!: number;
    hideZeroValuesInCells!: number;
    showNegativeValuesInRed!: number;
    showColumnsWithZeroActivity!: PeriodScope;
    showNetChangeRow!: boolean;
    showBalanceDiscrepancy!: boolean;
    splitMonthType!: MonthPeriodScope;

    constructor(data?: ICashflowGridGeneralSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showAmountsWithDecimals = _data["showAmountsWithDecimals"];
            this.hideZeroValuesInCells = _data["hideZeroValuesInCells"];
            this.showNegativeValuesInRed = _data["showNegativeValuesInRed"];
            this.showColumnsWithZeroActivity = _data["showColumnsWithZeroActivity"];
            this.showNetChangeRow = _data["showNetChangeRow"];
            this.showBalanceDiscrepancy = _data["showBalanceDiscrepancy"];
            this.splitMonthType = _data["splitMonthType"];
        }
    }

    static fromJS(data: any): CashflowGridGeneralSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowGridGeneralSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showAmountsWithDecimals"] = this.showAmountsWithDecimals;
        data["hideZeroValuesInCells"] = this.hideZeroValuesInCells;
        data["showNegativeValuesInRed"] = this.showNegativeValuesInRed;
        data["showColumnsWithZeroActivity"] = this.showColumnsWithZeroActivity;
        data["showNetChangeRow"] = this.showNetChangeRow;
        data["showBalanceDiscrepancy"] = this.showBalanceDiscrepancy;
        data["splitMonthType"] = this.splitMonthType;
        return data;
    }
}

export interface ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals: number;
    hideZeroValuesInCells: number;
    showNegativeValuesInRed: number;
    showColumnsWithZeroActivity: PeriodScope;
    showNetChangeRow: boolean;
    showBalanceDiscrepancy: boolean;
    splitMonthType: MonthPeriodScope;
}

export class CashFlowGridSettingsDto implements ICashFlowGridSettingsDto {
    general!: CashflowGridGeneralSettingsDto;
    visualPreferences!: CashflowGridVisualSettingsDto;
    localizationAndCurrency!: LocalizationAndCurrencyDto;

    constructor(data?: ICashFlowGridSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new CashflowGridGeneralSettingsDto();
            this.visualPreferences = new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = new LocalizationAndCurrencyDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? CashflowGridGeneralSettingsDto.fromJS(_data["general"]) : new CashflowGridGeneralSettingsDto();
            this.visualPreferences = _data["visualPreferences"] ? CashflowGridVisualSettingsDto.fromJS(_data["visualPreferences"]) : new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = _data["localizationAndCurrency"] ? LocalizationAndCurrencyDto.fromJS(_data["localizationAndCurrency"]) : new LocalizationAndCurrencyDto();
        }
    }

    static fromJS(data: any): CashFlowGridSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowGridSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["visualPreferences"] = this.visualPreferences ? this.visualPreferences.toJSON() : <any>undefined;
        data["localizationAndCurrency"] = this.localizationAndCurrency ? this.localizationAndCurrency.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICashFlowGridSettingsDto {
    general: CashflowGridGeneralSettingsDto;
    visualPreferences: CashflowGridVisualSettingsDto;
    localizationAndCurrency: LocalizationAndCurrencyDto;
}

export class CashflowGridVisualSettingsDto implements ICashflowGridVisualSettingsDto {
    fontName!: string;
    fontSize!: string;
    cfoTheme!: string;
    showFooterBar!: boolean;

    constructor(data?: ICashflowGridVisualSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fontName = _data["fontName"];
            this.fontSize = _data["fontSize"];
            this.cfoTheme = _data["cfoTheme"];
            this.showFooterBar = _data["showFooterBar"];
        }
    }

    static fromJS(data: any): CashflowGridVisualSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowGridVisualSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fontName"] = this.fontName;
        data["fontSize"] = this.fontSize;
        data["cfoTheme"] = this.cfoTheme;
        data["showFooterBar"] = this.showFooterBar;
        return data;
    }
}

export interface ICashflowGridVisualSettingsDto {
    fontName: string;
    fontSize: string;
    cfoTheme: string;
    showFooterBar: boolean;
}

export class CashFlowInitialData implements ICashFlowInitialData {
    banks!: BankDto[] | undefined;
    businessEntities!: BusinessEntityDto[] | undefined;
    cashflowTypes!: { [key: string]: string; } | undefined;
    bankAccountBalances!: BankAccountBalanceDto[] | undefined;

    constructor(data?: ICashFlowInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["banks"])) {
                this.banks = [] as any;
                for (let item of _data["banks"])
                    this.banks!.push(BankDto.fromJS(item));
            }
            if (Array.isArray(_data["businessEntities"])) {
                this.businessEntities = [] as any;
                for (let item of _data["businessEntities"])
                    this.businessEntities!.push(BusinessEntityDto.fromJS(item));
            }
            if (_data["cashflowTypes"]) {
                this.cashflowTypes = {} as any;
                for (let key in _data["cashflowTypes"]) {
                    if (_data["cashflowTypes"].hasOwnProperty(key))
                        (<any>this.cashflowTypes)![key] = _data["cashflowTypes"][key];
                }
            }
            if (Array.isArray(_data["bankAccountBalances"])) {
                this.bankAccountBalances = [] as any;
                for (let item of _data["bankAccountBalances"])
                    this.bankAccountBalances!.push(BankAccountBalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowInitialData {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.banks)) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (Array.isArray(this.businessEntities)) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        if (this.cashflowTypes) {
            data["cashflowTypes"] = {};
            for (let key in this.cashflowTypes) {
                if (this.cashflowTypes.hasOwnProperty(key))
                    (<any>data["cashflowTypes"])[key] = this.cashflowTypes[key];
            }
        }
        if (Array.isArray(this.bankAccountBalances)) {
            data["bankAccountBalances"] = [];
            for (let item of this.bankAccountBalances)
                data["bankAccountBalances"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICashFlowInitialData {
    banks: BankDto[] | undefined;
    businessEntities: BusinessEntityDto[] | undefined;
    cashflowTypes: { [key: string]: string; } | undefined;
    bankAccountBalances: BankAccountBalanceDto[] | undefined;
}

export class CashFlowStatsDetailDto implements ICashFlowStatsDetailDto {
    readonly id!: number;
    readonly date!: moment.Moment | undefined;
    businessEntityName!: string | undefined;
    cashflowTypeId!: string | undefined;
    categoryId!: number | undefined;
    categoryName!: string | undefined;
    descriptor!: string | undefined;
    isDescriptorCalculated!: boolean;
    bankName!: string | undefined;
    accountId!: number;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    readonly currencyId!: string | undefined;
    readonly credit!: number | undefined;
    readonly debit!: number | undefined;
    amount!: number;
    readonly description!: string | undefined;
    readonly comment!: string | undefined;
    readonly commentThreadId!: number | undefined;
    forecastId!: number | undefined;
    forecastDate!: moment.Moment | undefined;
    status!: Status;
    counterpartyName!: string | undefined;
    type!: StatsType;

    constructor(data?: ICashFlowStatsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.businessEntityName = _data["businessEntityName"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.descriptor = _data["descriptor"];
            this.isDescriptorCalculated = _data["isDescriptorCalculated"];
            this.bankName = _data["bankName"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            (<any>this).currencyId = _data["currencyId"];
            (<any>this).credit = _data["credit"];
            (<any>this).debit = _data["debit"];
            this.amount = _data["amount"];
            (<any>this).description = _data["description"];
            (<any>this).comment = _data["comment"];
            (<any>this).commentThreadId = _data["commentThreadId"];
            this.forecastId = _data["forecastId"];
            this.forecastDate = _data["forecastDate"] ? moment(_data["forecastDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.counterpartyName = _data["counterpartyName"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CashFlowStatsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowStatsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["businessEntityName"] = this.businessEntityName;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["descriptor"] = this.descriptor;
        data["isDescriptorCalculated"] = this.isDescriptorCalculated;
        data["bankName"] = this.bankName;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["currencyId"] = this.currencyId;
        data["credit"] = this.credit;
        data["debit"] = this.debit;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["commentThreadId"] = this.commentThreadId;
        data["forecastId"] = this.forecastId;
        data["forecastDate"] = this.forecastDate ? this.forecastDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["counterpartyName"] = this.counterpartyName;
        data["type"] = this.type;
        return data;
    }
}

export interface ICashFlowStatsDetailDto {
    id: number;
    date: moment.Moment | undefined;
    businessEntityName: string | undefined;
    cashflowTypeId: string | undefined;
    categoryId: number | undefined;
    categoryName: string | undefined;
    descriptor: string | undefined;
    isDescriptorCalculated: boolean;
    bankName: string | undefined;
    accountId: number;
    accountName: string | undefined;
    accountNumber: string | undefined;
    currencyId: string | undefined;
    credit: number | undefined;
    debit: number | undefined;
    amount: number;
    description: string | undefined;
    comment: string | undefined;
    commentThreadId: number | undefined;
    forecastId: number | undefined;
    forecastDate: moment.Moment | undefined;
    status: Status;
    counterpartyName: string | undefined;
    type: StatsType;
}

export class CashFlowStatsDto implements ICashFlowStatsDto {
    transactionStats!: TransactionStatsDto[] | undefined;
    commentThreads!: CashFlowCommentThreadDto[] | undefined;
    budgets!: BudgetDto[] | undefined;

    constructor(data?: ICashFlowStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transactionStats"])) {
                this.transactionStats = [] as any;
                for (let item of _data["transactionStats"])
                    this.transactionStats!.push(TransactionStatsDto.fromJS(item));
            }
            if (Array.isArray(_data["commentThreads"])) {
                this.commentThreads = [] as any;
                for (let item of _data["commentThreads"])
                    this.commentThreads!.push(CashFlowCommentThreadDto.fromJS(item));
            }
            if (Array.isArray(_data["budgets"])) {
                this.budgets = [] as any;
                for (let item of _data["budgets"])
                    this.budgets!.push(BudgetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transactionStats)) {
            data["transactionStats"] = [];
            for (let item of this.transactionStats)
                data["transactionStats"].push(item.toJSON());
        }
        if (Array.isArray(this.commentThreads)) {
            data["commentThreads"] = [];
            for (let item of this.commentThreads)
                data["commentThreads"].push(item.toJSON());
        }
        if (Array.isArray(this.budgets)) {
            data["budgets"] = [];
            for (let item of this.budgets)
                data["budgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICashFlowStatsDto {
    transactionStats: TransactionStatsDto[] | undefined;
    commentThreads: CashFlowCommentThreadDto[] | undefined;
    budgets: BudgetDto[] | undefined;
}

export enum CategorizationRuleConditionType {
    Exist = "Exist",
    Equal = "Equal",
}

export class CategorizationStatus implements ICategorizationStatus {
    classifiedTransactionCount!: number;
    classifiedTransactionPercent!: number;
    unclassifiedTransactionCount!: number;
    unclassifiedTransactionPercent!: number;

    constructor(data?: ICategorizationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classifiedTransactionCount = _data["classifiedTransactionCount"];
            this.classifiedTransactionPercent = _data["classifiedTransactionPercent"];
            this.unclassifiedTransactionCount = _data["unclassifiedTransactionCount"];
            this.unclassifiedTransactionPercent = _data["unclassifiedTransactionPercent"];
        }
    }

    static fromJS(data: any): CategorizationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CategorizationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedTransactionCount"] = this.classifiedTransactionCount;
        data["classifiedTransactionPercent"] = this.classifiedTransactionPercent;
        data["unclassifiedTransactionCount"] = this.unclassifiedTransactionCount;
        data["unclassifiedTransactionPercent"] = this.unclassifiedTransactionPercent;
        return data;
    }
}

export interface ICategorizationStatus {
    classifiedTransactionCount: number;
    classifiedTransactionPercent: number;
    unclassifiedTransactionCount: number;
    unclassifiedTransactionPercent: number;
}

export class CategoryDto implements ICategoryDto {
    accountingTypeId!: number;
    parentId!: number | undefined;
    coAID!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;
    reportingCategoryId!: number | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingTypeId = _data["accountingTypeId"];
            this.parentId = _data["parentId"];
            this.coAID = _data["coAID"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.reportingCategoryId = _data["reportingCategoryId"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["reportingCategoryId"] = this.reportingCategoryId;
        return data;
    }
}

export interface ICategoryDto {
    accountingTypeId: number;
    parentId: number | undefined;
    coAID: string | undefined;
    name: string | undefined;
    isActive: boolean;
    reportingCategoryId: number | undefined;
}

export class ChangeAutoSyncInput implements IChangeAutoSyncInput {
    syncAccountIds!: number[] | undefined;
    autoSyncTime!: string | undefined;

    constructor(data?: IChangeAutoSyncInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["syncAccountIds"])) {
                this.syncAccountIds = [] as any;
                for (let item of _data["syncAccountIds"])
                    this.syncAccountIds!.push(item);
            }
            this.autoSyncTime = _data["autoSyncTime"];
        }
    }

    static fromJS(data: any): ChangeAutoSyncInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeAutoSyncInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.syncAccountIds)) {
            data["syncAccountIds"] = [];
            for (let item of this.syncAccountIds)
                data["syncAccountIds"].push(item);
        }
        data["autoSyncTime"] = this.autoSyncTime;
        return data;
    }
}

export interface IChangeAutoSyncInput {
    syncAccountIds: number[] | undefined;
    autoSyncTime: string | undefined;
}

export class ChangeCategoryForRulesInput implements IChangeCategoryForRulesInput {
    ruleIds!: number[] | undefined;
    categotyId!: number;
    reclassifyTransactions!: boolean;

    constructor(data?: IChangeCategoryForRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reclassifyTransactions = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ruleIds"])) {
                this.ruleIds = [] as any;
                for (let item of _data["ruleIds"])
                    this.ruleIds!.push(item);
            }
            this.categotyId = _data["categotyId"];
            this.reclassifyTransactions = _data["reclassifyTransactions"] !== undefined ? _data["reclassifyTransactions"] : false;
        }
    }

    static fromJS(data: any): ChangeCategoryForRulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeCategoryForRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ruleIds)) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        data["categotyId"] = this.categotyId;
        data["reclassifyTransactions"] = this.reclassifyTransactions;
        return data;
    }
}

export interface IChangeCategoryForRulesInput {
    ruleIds: number[] | undefined;
    categotyId: number;
    reclassifyTransactions: boolean;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class ChangeStageConfiguration implements IChangeStageConfiguration {
    fromStageIds!: number[];
    toStageId!: number;

    constructor(data?: IChangeStageConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fromStageIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fromStageIds"])) {
                this.fromStageIds = [] as any;
                for (let item of _data["fromStageIds"])
                    this.fromStageIds!.push(item);
            }
            this.toStageId = _data["toStageId"];
        }
    }

    static fromJS(data: any): ChangeStageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStageConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fromStageIds)) {
            data["fromStageIds"] = [];
            for (let item of this.fromStageIds)
                data["fromStageIds"].push(item);
        }
        data["toStageId"] = this.toStageId;
        return data;
    }
}

export interface IChangeStageConfiguration {
    fromStageIds: number[];
    toStageId: number;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: moment.Moment;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: moment.Moment;
    sharedMessageId: string | undefined;
    id: number;
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export class CheckHostNameDnsMappingInput implements ICheckHostNameDnsMappingInput {
    tenantHostType!: TenantHostType;
    hostName!: string | undefined;

    constructor(data?: ICheckHostNameDnsMappingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantHostType = _data["tenantHostType"];
            this.hostName = _data["hostName"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckHostNameDnsMappingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["hostName"] = this.hostName;
        return data;
    }
}

export interface ICheckHostNameDnsMappingInput {
    tenantHostType: TenantHostType;
    hostName: string | undefined;
}

export class CheckHostNameDnsMappingOutput implements ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped!: boolean;

    constructor(data?: ICheckHostNameDnsMappingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hostNameDnsMapped = _data["hostNameDnsMapped"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckHostNameDnsMappingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostNameDnsMapped"] = this.hostNameDnsMapped;
        return data;
    }
}

export interface ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped: boolean;
}

export class CloneEmailTemplateInput implements ICloneEmailTemplateInput {
    id!: number | undefined;
    emailTemplateType!: EmailTemplateType | undefined;

    constructor(data?: ICloneEmailTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailTemplateType = _data["emailTemplateType"];
        }
    }

    static fromJS(data: any): CloneEmailTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CloneEmailTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailTemplateType"] = this.emailTemplateType;
        return data;
    }
}

export interface ICloneEmailTemplateInput {
    id: number | undefined;
    emailTemplateType: EmailTemplateType | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class CommentDto implements ICommentDto {
    threadId!: number;
    comment!: string | undefined;
    createdByUser!: UserKeyInfo | undefined;
    creationTime!: moment.Moment;
    updatedByUser!: UserKeyInfo | undefined;
    lastModificationTime!: moment.Moment | undefined;
    id!: number;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.threadId = _data["threadId"];
            this.comment = _data["comment"];
            this.createdByUser = _data["createdByUser"] ? UserKeyInfo.fromJS(_data["createdByUser"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.updatedByUser = _data["updatedByUser"] ? UserKeyInfo.fromJS(_data["updatedByUser"]) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommentDto {
    threadId: number;
    comment: string | undefined;
    createdByUser: UserKeyInfo | undefined;
    creationTime: moment.Moment;
    updatedByUser: UserKeyInfo | undefined;
    lastModificationTime: moment.Moment | undefined;
    id: number;
}

export enum CommissionAffiliateAssignmentMode {
    Linear = "Linear",
    Dynamic = "Dynamic",
}

export class CommissionLedgerEntryInfo implements ICommissionLedgerEntryInfo {
    id!: number;
    date!: moment.Moment;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;
    status!: CommissionLedgerEntryStatus;
    type!: CommissionLedgerEntryType;
    totalAmount!: number;
    paymentSystem!: PaymentSystem | undefined;

    constructor(data?: ICommissionLedgerEntryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
            this.totalAmount = _data["totalAmount"];
            this.paymentSystem = _data["paymentSystem"];
        }
    }

    static fromJS(data: any): CommissionLedgerEntryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionLedgerEntryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["totalAmount"] = this.totalAmount;
        data["paymentSystem"] = this.paymentSystem;
        return data;
    }
}

export interface ICommissionLedgerEntryInfo {
    id: number;
    date: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    status: CommissionLedgerEntryStatus;
    type: CommissionLedgerEntryType;
    totalAmount: number;
    paymentSystem: PaymentSystem | undefined;
}

export enum CommissionLedgerEntryStatus {
    Pending = "Pending",
    Approved = "Approved",
    Completed = "Completed",
    Cancelled = "Cancelled",
}

export enum CommissionLedgerEntryType {
    Earning = "Earning",
    Withdrawal = "Withdrawal",
}

export enum CommissionTier {
    Tier1 = "Tier1",
    Tier2 = "Tier2",
}

export enum CommunicationMessageDeliveryStatus {
    Delivered = "Delivered",
    Bounce = "Bounce",
    Blocked = "Blocked",
    Dropped = "Dropped",
    Failed = "Failed",
}

export enum CommunicationMessageDeliveryType {
    Email = "Email",
    SMS = "SMS",
}

export enum CommunicationMessageSendingStatus {
    Draft = "Draft",
    Pending = "Pending",
    Failed = "Failed",
    Sent = "Sent",
}

export class CompleteTenantRegistrationInput implements ICompleteTenantRegistrationInput {
    requestXref!: string;
    tenancyName!: string | undefined;
    tenantName!: string | undefined;
    companyName!: string | undefined;
    siteUrl!: string | undefined;
    adminPassword!: string;

    constructor(data?: ICompleteTenantRegistrationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestXref = _data["requestXref"];
            this.tenancyName = _data["tenancyName"];
            this.tenantName = _data["tenantName"];
            this.companyName = _data["companyName"];
            this.siteUrl = _data["siteUrl"];
            this.adminPassword = _data["adminPassword"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTenantRegistrationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestXref"] = this.requestXref;
        data["tenancyName"] = this.tenancyName;
        data["tenantName"] = this.tenantName;
        data["companyName"] = this.companyName;
        data["siteUrl"] = this.siteUrl;
        data["adminPassword"] = this.adminPassword;
        return data;
    }
}

export interface ICompleteTenantRegistrationInput {
    requestXref: string;
    tenancyName: string | undefined;
    tenantName: string | undefined;
    companyName: string | undefined;
    siteUrl: string | undefined;
    adminPassword: string;
}

export class CompleteTenantRegistrationOutput implements ICompleteTenantRegistrationOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isEmailConfirmationRequired!: boolean;
    loginLink!: string | undefined;
    paymentLink!: string | undefined;

    constructor(data?: ICompleteTenantRegistrationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
            this.loginLink = _data["loginLink"];
            this.paymentLink = _data["paymentLink"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTenantRegistrationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        data["loginLink"] = this.loginLink;
        data["paymentLink"] = this.paymentLink;
        return data;
    }
}

export interface ICompleteTenantRegistrationOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isEmailConfirmationRequired: boolean;
    loginLink: string | undefined;
    paymentLink: string | undefined;
}

export class CompleteWithdrawalInput implements ICompleteWithdrawalInput {
    withdrawalIds!: number[] | undefined;
    paymentSystem!: PaymentSystem;
    payDate!: moment.Moment;

    constructor(data?: ICompleteWithdrawalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["withdrawalIds"])) {
                this.withdrawalIds = [] as any;
                for (let item of _data["withdrawalIds"])
                    this.withdrawalIds!.push(item);
            }
            this.paymentSystem = _data["paymentSystem"];
            this.payDate = _data["payDate"] ? moment(_data["payDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CompleteWithdrawalInput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteWithdrawalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.withdrawalIds)) {
            data["withdrawalIds"] = [];
            for (let item of this.withdrawalIds)
                data["withdrawalIds"].push(item);
        }
        data["paymentSystem"] = this.paymentSystem;
        data["payDate"] = this.payDate ? this.payDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICompleteWithdrawalInput {
    withdrawalIds: number[] | undefined;
    paymentSystem: PaymentSystem;
    payDate: moment.Moment;
}

export class ConditionAttributeDto implements IConditionAttributeDto {
    attributeTypeId!: string;
    conditionTypeId!: CategorizationRuleConditionType;
    conditionValue!: string | undefined;

    constructor(data?: IConditionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeTypeId = _data["attributeTypeId"];
            this.conditionTypeId = _data["conditionTypeId"];
            this.conditionValue = _data["conditionValue"];
        }
    }

    static fromJS(data: any): ConditionAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        data["conditionTypeId"] = this.conditionTypeId;
        data["conditionValue"] = this.conditionValue;
        return data;
    }
}

export interface IConditionAttributeDto {
    attributeTypeId: string;
    conditionTypeId: CategorizationRuleConditionType;
    conditionValue: string | undefined;
}

export class ConditionDto implements IConditionDto {
    minAmount!: number | undefined;
    maxAmount!: number | undefined;
    cashFlowAmountFormat!: CashFlowAmountFormat;
    bankId!: number | undefined;
    bankAccountId!: number | undefined;
    transactionCategoryId!: string | undefined;
    descriptionWords!: string | undefined;
    attributes!: { [key: string]: ConditionAttributeDto; } | undefined;
    transactionTypes!: string[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.cashFlowAmountFormat = _data["cashFlowAmountFormat"];
            this.bankId = _data["bankId"];
            this.bankAccountId = _data["bankAccountId"];
            this.transactionCategoryId = _data["transactionCategoryId"];
            this.descriptionWords = _data["descriptionWords"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key] ? ConditionAttributeDto.fromJS(_data["attributes"][key]) : new ConditionAttributeDto();
                }
            }
            if (Array.isArray(_data["transactionTypes"])) {
                this.transactionTypes = [] as any;
                for (let item of _data["transactionTypes"])
                    this.transactionTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["cashFlowAmountFormat"] = this.cashFlowAmountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["descriptionWords"] = this.descriptionWords;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = this.attributes[key] ? this.attributes[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.transactionTypes)) {
            data["transactionTypes"] = [];
            for (let item of this.transactionTypes)
                data["transactionTypes"].push(item);
        }
        return data;
    }
}

export interface IConditionDto {
    minAmount: number | undefined;
    maxAmount: number | undefined;
    cashFlowAmountFormat: CashFlowAmountFormat;
    bankId: number | undefined;
    bankAccountId: number | undefined;
    transactionCategoryId: string | undefined;
    descriptionWords: string | undefined;
    attributes: { [key: string]: ConditionAttributeDto; } | undefined;
    transactionTypes: string[] | undefined;
}

export enum ConnectionMode {
    Create = "Create",
    Reconnect = "Reconnect",
    Refresh = "Refresh",
}

export class ConsumerStatementDto implements IConsumerStatementDto {
    bureau!: Bureau;
    date!: moment.Moment | undefined;
    statement!: string | undefined;

    constructor(data?: IConsumerStatementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bureau = _data["bureau"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.statement = _data["statement"];
        }
    }

    static fromJS(data: any): ConsumerStatementDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerStatementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["statement"] = this.statement;
        return data;
    }
}

export interface IConsumerStatementDto {
    bureau: Bureau;
    date: moment.Moment | undefined;
    statement: string | undefined;
}

export class ContactAddressDto implements IContactAddressDto {
    usageTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    zip!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    contactId!: number;
    id!: number;
    isConfirmed!: boolean;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    confirmedByUserFullName!: string | undefined;

    constructor(data?: IContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usageTypeId = _data["usageTypeId"];
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.zip = _data["zip"];
            this.isActive = _data["isActive"];
            this.comment = _data["comment"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
            this.isConfirmed = _data["isConfirmed"];
            this.confirmationDate = _data["confirmationDate"] ? moment(_data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = _data["confirmedByUserId"];
            this.confirmedByUserFullName = _data["confirmedByUserFullName"];
        }
    }

    static fromJS(data: any): ContactAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["zip"] = this.zip;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUserFullName"] = this.confirmedByUserFullName;
        return data;
    }
}

export interface IContactAddressDto {
    usageTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    zip: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    contactId: number;
    id: number;
    isConfirmed: boolean;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    confirmedByUserFullName: string | undefined;
}

export class ContactAddressInfo implements IContactAddressInfo {
    id!: number;
    usageTypeId!: string | undefined;
    startDate!: moment.Moment | undefined;
    ownershipTypeId!: string | undefined;
    isPrimary!: boolean;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;

    constructor(data?: IContactAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.usageTypeId = _data["usageTypeId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ownershipTypeId = _data["ownershipTypeId"];
            this.isPrimary = _data["isPrimary"];
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ContactAddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["usageTypeId"] = this.usageTypeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["isPrimary"] = this.isPrimary;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IContactAddressInfo {
    id: number;
    usageTypeId: string | undefined;
    startDate: moment.Moment | undefined;
    ownershipTypeId: string | undefined;
    isPrimary: boolean;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
}

export class ContactAgentInput implements IContactAgentInput {
    agentCode!: string;
    agentName!: string | undefined;
    callCenter!: string | undefined;

    constructor(data?: IContactAgentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agentCode = _data["agentCode"];
            this.agentName = _data["agentName"];
            this.callCenter = _data["callCenter"];
        }
    }

    static fromJS(data: any): ContactAgentInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAgentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agentCode"] = this.agentCode;
        data["agentName"] = this.agentName;
        data["callCenter"] = this.callCenter;
        return data;
    }
}

export interface IContactAgentInput {
    agentCode: string;
    agentName: string | undefined;
    callCenter: string | undefined;
}

export class ContactDetailsDto implements IContactDetailsDto {
    firstName!: string | undefined;
    lastName!: string | undefined;
    primaryOrgRelationId!: number | undefined;
    orgRelations!: PersonOrgRelationShortInfo[] | undefined;
    emails!: ContactEmailDto[] | undefined;
    phones!: ContactPhoneDto[] | undefined;
    addresses!: ContactAddressDto[] | undefined;

    constructor(data?: IContactDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.primaryOrgRelationId = _data["primaryOrgRelationId"];
            if (Array.isArray(_data["orgRelations"])) {
                this.orgRelations = [] as any;
                for (let item of _data["orgRelations"])
                    this.orgRelations!.push(PersonOrgRelationShortInfo.fromJS(item));
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(ContactEmailDto.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(ContactPhoneDto.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(ContactAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["primaryOrgRelationId"] = this.primaryOrgRelationId;
        if (Array.isArray(this.orgRelations)) {
            data["orgRelations"] = [];
            for (let item of this.orgRelations)
                data["orgRelations"].push(item.toJSON());
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactDetailsDto {
    firstName: string | undefined;
    lastName: string | undefined;
    primaryOrgRelationId: number | undefined;
    orgRelations: PersonOrgRelationShortInfo[] | undefined;
    emails: ContactEmailDto[] | undefined;
    phones: ContactPhoneDto[] | undefined;
    addresses: ContactAddressDto[] | undefined;
}

export class ContactEmailDto implements IContactEmailDto {
    usageTypeId!: string | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    contactId!: number;
    id!: number;
    isConfirmed!: boolean;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    confirmedByUserFullName!: string | undefined;

    constructor(data?: IContactEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usageTypeId = _data["usageTypeId"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.comment = _data["comment"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
            this.isConfirmed = _data["isConfirmed"];
            this.confirmationDate = _data["confirmationDate"] ? moment(_data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = _data["confirmedByUserId"];
            this.confirmedByUserFullName = _data["confirmedByUserFullName"];
        }
    }

    static fromJS(data: any): ContactEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUserFullName"] = this.confirmedByUserFullName;
        return data;
    }
}

export interface IContactEmailDto {
    usageTypeId: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    contactId: number;
    id: number;
    isConfirmed: boolean;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    confirmedByUserFullName: string | undefined;
}

export class ContactEmailInfo implements IContactEmailInfo {
    id!: number;
    emailAddress!: string | undefined;
    usageTypeId!: string | undefined;
    isPrimary!: boolean;

    constructor(data?: IContactEmailInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            this.usageTypeId = _data["usageTypeId"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): ContactEmailInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["usageTypeId"] = this.usageTypeId;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface IContactEmailInfo {
    id: number;
    emailAddress: string | undefined;
    usageTypeId: string | undefined;
    isPrimary: boolean;
}

export class ContactGroupDto implements IContactGroupDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IContactGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContactGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IContactGroupDto {
    id: string | undefined;
    name: string | undefined;
}

export class ContactGroupInfo implements IContactGroupInfo {
    groupId!: string | undefined;
    isActive!: boolean;
    isProspective!: boolean;

    constructor(data?: IContactGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.isActive = _data["isActive"];
            this.isProspective = _data["isProspective"];
        }
    }

    static fromJS(data: any): ContactGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        data["isProspective"] = this.isProspective;
        return data;
    }
}

export interface IContactGroupInfo {
    groupId: string | undefined;
    isActive: boolean;
    isProspective: boolean;
}

export class ContactInfoDetailsDto implements IContactInfoDetailsDto {
    contactId!: number;
    publicPersonProfileUrl!: string | undefined;
    emails!: ContactEmailDto[] | undefined;
    phones!: ContactPhoneDto[] | undefined;
    addresses!: ContactAddressDto[] | undefined;
    links!: ContactLinkDto[] | undefined;

    constructor(data?: IContactInfoDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.publicPersonProfileUrl = _data["publicPersonProfileUrl"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(ContactEmailDto.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(ContactPhoneDto.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(ContactAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(ContactLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactInfoDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["publicPersonProfileUrl"] = this.publicPersonProfileUrl;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactInfoDetailsDto {
    contactId: number;
    publicPersonProfileUrl: string | undefined;
    emails: ContactEmailDto[] | undefined;
    phones: ContactPhoneDto[] | undefined;
    addresses: ContactAddressDto[] | undefined;
    links: ContactLinkDto[] | undefined;
}

export class ContactInfoDto implements IContactInfoDto {
    id!: number;
    typeId!: string | undefined;
    groups!: ContactGroupInfo[] | undefined;
    assignedContactId!: number | undefined;
    assignedUserId!: number | undefined;
    assignedUserName!: string | undefined;
    assignedUserPicturePublicId!: string | undefined;
    creatorContactId!: number | undefined;
    creatorUserId!: number | undefined;
    creatorUserName!: string | undefined;
    creatorUserPicturePublicId!: string | undefined;
    starId!: number | undefined;
    ratingId!: number | undefined;
    tags!: number[] | undefined;
    lists!: number[] | undefined;
    personContactInfo!: PersonContactInfoDto | undefined;
    primaryOrganizationContactId!: number | undefined;
    affiliateCode!: string | undefined;
    affiliateIsAdvisor!: boolean;
    affiliateRate!: number | undefined;
    affiliateRateTier2!: number | undefined;
    affiliateServiceStatus!: AffiliateServiceStatus;
    parentId!: number | undefined;
    parentName!: string | undefined;
    contactDate!: moment.Moment;
    affiliateContactId!: number | undefined;
    affiliateContactName!: string | undefined;
    subContactsCount!: number;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(ContactGroupInfo.fromJS(item));
            }
            this.assignedContactId = _data["assignedContactId"];
            this.assignedUserId = _data["assignedUserId"];
            this.assignedUserName = _data["assignedUserName"];
            this.assignedUserPicturePublicId = _data["assignedUserPicturePublicId"];
            this.creatorContactId = _data["creatorContactId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creatorUserPicturePublicId = _data["creatorUserPicturePublicId"];
            this.starId = _data["starId"];
            this.ratingId = _data["ratingId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(item);
            }
            this.personContactInfo = _data["personContactInfo"] ? PersonContactInfoDto.fromJS(_data["personContactInfo"]) : <any>undefined;
            this.primaryOrganizationContactId = _data["primaryOrganizationContactId"];
            this.affiliateCode = _data["affiliateCode"];
            this.affiliateIsAdvisor = _data["affiliateIsAdvisor"];
            this.affiliateRate = _data["affiliateRate"];
            this.affiliateRateTier2 = _data["affiliateRateTier2"];
            this.affiliateServiceStatus = _data["affiliateServiceStatus"];
            this.parentId = _data["parentId"];
            this.parentName = _data["parentName"];
            this.contactDate = _data["contactDate"] ? moment(_data["contactDate"].toString()) : <any>undefined;
            this.affiliateContactId = _data["affiliateContactId"];
            this.affiliateContactName = _data["affiliateContactName"];
            this.subContactsCount = _data["subContactsCount"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["assignedContactId"] = this.assignedContactId;
        data["assignedUserId"] = this.assignedUserId;
        data["assignedUserName"] = this.assignedUserName;
        data["assignedUserPicturePublicId"] = this.assignedUserPicturePublicId;
        data["creatorContactId"] = this.creatorContactId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creatorUserPicturePublicId"] = this.creatorUserPicturePublicId;
        data["starId"] = this.starId;
        data["ratingId"] = this.ratingId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item);
        }
        data["personContactInfo"] = this.personContactInfo ? this.personContactInfo.toJSON() : <any>undefined;
        data["primaryOrganizationContactId"] = this.primaryOrganizationContactId;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateIsAdvisor"] = this.affiliateIsAdvisor;
        data["affiliateRate"] = this.affiliateRate;
        data["affiliateRateTier2"] = this.affiliateRateTier2;
        data["affiliateServiceStatus"] = this.affiliateServiceStatus;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["contactDate"] = this.contactDate ? this.contactDate.toISOString() : <any>undefined;
        data["affiliateContactId"] = this.affiliateContactId;
        data["affiliateContactName"] = this.affiliateContactName;
        data["subContactsCount"] = this.subContactsCount;
        return data;
    }
}

export interface IContactInfoDto {
    id: number;
    typeId: string | undefined;
    groups: ContactGroupInfo[] | undefined;
    assignedContactId: number | undefined;
    assignedUserId: number | undefined;
    assignedUserName: string | undefined;
    assignedUserPicturePublicId: string | undefined;
    creatorContactId: number | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creatorUserPicturePublicId: string | undefined;
    starId: number | undefined;
    ratingId: number | undefined;
    tags: number[] | undefined;
    lists: number[] | undefined;
    personContactInfo: PersonContactInfoDto | undefined;
    primaryOrganizationContactId: number | undefined;
    affiliateCode: string | undefined;
    affiliateIsAdvisor: boolean;
    affiliateRate: number | undefined;
    affiliateRateTier2: number | undefined;
    affiliateServiceStatus: AffiliateServiceStatus;
    parentId: number | undefined;
    parentName: string | undefined;
    contactDate: moment.Moment;
    affiliateContactId: number | undefined;
    affiliateContactName: string | undefined;
    subContactsCount: number;
}

export class ContactInfoForMerge implements IContactInfoForMerge {
    id!: number;
    fullName!: string | undefined;
    contactDate!: moment.Moment;
    groupIds!: string[] | undefined;
    typeId!: string | undefined;
    parentId!: number | undefined;
    affiliateCode!: string | undefined;
    xref!: string | undefined;
    userId!: number | undefined;
    userEmailAddress!: string | undefined;
    userIsActive!: boolean | undefined;
    userLastLoginTime!: moment.Moment | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    gender!: Gender;
    contactEmails!: ContactEmailInfo[] | undefined;
    contactPhones!: ContactPhoneInfo[] | undefined;
    contactAddresses!: ContactAddressInfo[] | undefined;
    photoPublicId!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;
    assignedToUserId!: number | undefined;
    assignedToUserName!: string | undefined;
    bankCode!: string | undefined;
    bankCodeDate!: moment.Moment;
    orderCount!: number;

    constructor(data?: IContactInfoForMerge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.contactDate = _data["contactDate"] ? moment(_data["contactDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.typeId = _data["typeId"];
            this.parentId = _data["parentId"];
            this.affiliateCode = _data["affiliateCode"];
            this.xref = _data["xref"];
            this.userId = _data["userId"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userIsActive = _data["userIsActive"];
            this.userLastLoginTime = _data["userLastLoginTime"] ? moment(_data["userLastLoginTime"].toString()) : <any>undefined;
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.gender = _data["gender"];
            if (Array.isArray(_data["contactEmails"])) {
                this.contactEmails = [] as any;
                for (let item of _data["contactEmails"])
                    this.contactEmails!.push(ContactEmailInfo.fromJS(item));
            }
            if (Array.isArray(_data["contactPhones"])) {
                this.contactPhones = [] as any;
                for (let item of _data["contactPhones"])
                    this.contactPhones!.push(ContactPhoneInfo.fromJS(item));
            }
            if (Array.isArray(_data["contactAddresses"])) {
                this.contactAddresses = [] as any;
                for (let item of _data["contactAddresses"])
                    this.contactAddresses!.push(ContactAddressInfo.fromJS(item));
            }
            this.photoPublicId = _data["photoPublicId"];
            this.companyName = _data["companyName"];
            this.jobTitle = _data["jobTitle"];
            this.assignedToUserId = _data["assignedToUserId"];
            this.assignedToUserName = _data["assignedToUserName"];
            this.bankCode = _data["bankCode"];
            this.bankCodeDate = _data["bankCodeDate"] ? moment(_data["bankCodeDate"].toString()) : <any>undefined;
            this.orderCount = _data["orderCount"];
        }
    }

    static fromJS(data: any): ContactInfoForMerge {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoForMerge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["contactDate"] = this.contactDate ? this.contactDate.toISOString() : <any>undefined;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["typeId"] = this.typeId;
        data["parentId"] = this.parentId;
        data["affiliateCode"] = this.affiliateCode;
        data["xref"] = this.xref;
        data["userId"] = this.userId;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userIsActive"] = this.userIsActive;
        data["userLastLoginTime"] = this.userLastLoginTime ? this.userLastLoginTime.toISOString() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        if (Array.isArray(this.contactEmails)) {
            data["contactEmails"] = [];
            for (let item of this.contactEmails)
                data["contactEmails"].push(item.toJSON());
        }
        if (Array.isArray(this.contactPhones)) {
            data["contactPhones"] = [];
            for (let item of this.contactPhones)
                data["contactPhones"].push(item.toJSON());
        }
        if (Array.isArray(this.contactAddresses)) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["photoPublicId"] = this.photoPublicId;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        data["assignedToUserId"] = this.assignedToUserId;
        data["assignedToUserName"] = this.assignedToUserName;
        data["bankCode"] = this.bankCode;
        data["bankCodeDate"] = this.bankCodeDate ? this.bankCodeDate.toISOString() : <any>undefined;
        data["orderCount"] = this.orderCount;
        return data;
    }
}

export interface IContactInfoForMerge {
    id: number;
    fullName: string | undefined;
    contactDate: moment.Moment;
    groupIds: string[] | undefined;
    typeId: string | undefined;
    parentId: number | undefined;
    affiliateCode: string | undefined;
    xref: string | undefined;
    userId: number | undefined;
    userEmailAddress: string | undefined;
    userIsActive: boolean | undefined;
    userLastLoginTime: moment.Moment | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    gender: Gender;
    contactEmails: ContactEmailInfo[] | undefined;
    contactPhones: ContactPhoneInfo[] | undefined;
    contactAddresses: ContactAddressInfo[] | undefined;
    photoPublicId: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
    assignedToUserId: number | undefined;
    assignedToUserName: string | undefined;
    bankCode: string | undefined;
    bankCodeDate: moment.Moment;
    orderCount: number;
}

export class ContactLastModificationInfoDto implements IContactLastModificationInfoDto {
    date!: moment.Moment;
    contactId!: number | undefined;
    userId!: number | undefined;
    userName!: string | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IContactLastModificationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.contactId = _data["contactId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.photoPublicId = _data["photoPublicId"];
        }
    }

    static fromJS(data: any): ContactLastModificationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLastModificationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["contactId"] = this.contactId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["photoPublicId"] = this.photoPublicId;
        return data;
    }
}

export interface IContactLastModificationInfoDto {
    date: moment.Moment;
    contactId: number | undefined;
    userId: number | undefined;
    userName: string | undefined;
    photoPublicId: string | undefined;
}

export class ContactLinkDto implements IContactLinkDto {
    linkTypeId!: string | undefined;
    url!: string | undefined;
    isSocialNetwork!: boolean;
    isActive!: boolean;
    comment!: string | undefined;
    contactId!: number;
    id!: number;
    isConfirmed!: boolean;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    confirmedByUserFullName!: string | undefined;

    constructor(data?: IContactLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkTypeId = _data["linkTypeId"];
            this.url = _data["url"];
            this.isSocialNetwork = _data["isSocialNetwork"];
            this.isActive = _data["isActive"];
            this.comment = _data["comment"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
            this.isConfirmed = _data["isConfirmed"];
            this.confirmationDate = _data["confirmationDate"] ? moment(_data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = _data["confirmedByUserId"];
            this.confirmedByUserFullName = _data["confirmedByUserFullName"];
        }
    }

    static fromJS(data: any): ContactLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isSocialNetwork"] = this.isSocialNetwork;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUserFullName"] = this.confirmedByUserFullName;
        return data;
    }
}

export interface IContactLinkDto {
    linkTypeId: string | undefined;
    url: string | undefined;
    isSocialNetwork: boolean;
    isActive: boolean;
    comment: string | undefined;
    contactId: number;
    id: number;
    isConfirmed: boolean;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    confirmedByUserFullName: string | undefined;
}

export class ContactLinkTypeDto implements IContactLinkTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isSocialNetwork!: boolean;

    constructor(data?: IContactLinkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isSocialNetwork = _data["isSocialNetwork"];
        }
    }

    static fromJS(data: any): ContactLinkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isSocialNetwork"] = this.isSocialNetwork;
        return data;
    }
}

export interface IContactLinkTypeDto {
    id: string | undefined;
    name: string | undefined;
    isSocialNetwork: boolean;
}

export class ContactListInfoDto implements IContactListInfoDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IContactListInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContactListInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IContactListInfoDto {
    id: number;
    name: string | undefined;
}

export class ContactListInput implements IContactListInput {
    name!: string;

    constructor(data?: IContactListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContactListInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IContactListInput {
    name: string;
}

export class ContactMergeOptions implements IContactMergeOptions {
    emailIdsToIgnore!: number[] | undefined;
    phoneIdsToIgnore!: number[] | undefined;
    addressIdsToIgnore!: number[] | undefined;
    preferredProperties!: PreferredProperties;

    constructor(data?: IContactMergeOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["emailIdsToIgnore"])) {
                this.emailIdsToIgnore = [] as any;
                for (let item of _data["emailIdsToIgnore"])
                    this.emailIdsToIgnore!.push(item);
            }
            if (Array.isArray(_data["phoneIdsToIgnore"])) {
                this.phoneIdsToIgnore = [] as any;
                for (let item of _data["phoneIdsToIgnore"])
                    this.phoneIdsToIgnore!.push(item);
            }
            if (Array.isArray(_data["addressIdsToIgnore"])) {
                this.addressIdsToIgnore = [] as any;
                for (let item of _data["addressIdsToIgnore"])
                    this.addressIdsToIgnore!.push(item);
            }
            this.preferredProperties = _data["preferredProperties"];
        }
    }

    static fromJS(data: any): ContactMergeOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ContactMergeOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.emailIdsToIgnore)) {
            data["emailIdsToIgnore"] = [];
            for (let item of this.emailIdsToIgnore)
                data["emailIdsToIgnore"].push(item);
        }
        if (Array.isArray(this.phoneIdsToIgnore)) {
            data["phoneIdsToIgnore"] = [];
            for (let item of this.phoneIdsToIgnore)
                data["phoneIdsToIgnore"].push(item);
        }
        if (Array.isArray(this.addressIdsToIgnore)) {
            data["addressIdsToIgnore"] = [];
            for (let item of this.addressIdsToIgnore)
                data["addressIdsToIgnore"].push(item);
        }
        data["preferredProperties"] = this.preferredProperties;
        return data;
    }
}

export interface IContactMergeOptions {
    emailIdsToIgnore: number[] | undefined;
    phoneIdsToIgnore: number[] | undefined;
    addressIdsToIgnore: number[] | undefined;
    preferredProperties: PreferredProperties;
}

export class ContactPhoneDto implements IContactPhoneDto {
    usageTypeId!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    contactId!: number;
    id!: number;
    isConfirmed!: boolean;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    confirmedByUserFullName!: string | undefined;

    constructor(data?: IContactPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usageTypeId = _data["usageTypeId"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.isActive = _data["isActive"];
            this.comment = _data["comment"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
            this.isConfirmed = _data["isConfirmed"];
            this.confirmationDate = _data["confirmationDate"] ? moment(_data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = _data["confirmedByUserId"];
            this.confirmedByUserFullName = _data["confirmedByUserFullName"];
        }
    }

    static fromJS(data: any): ContactPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUserFullName"] = this.confirmedByUserFullName;
        return data;
    }
}

export interface IContactPhoneDto {
    usageTypeId: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    contactId: number;
    id: number;
    isConfirmed: boolean;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    confirmedByUserFullName: string | undefined;
}

export class ContactPhoneInfo implements IContactPhoneInfo {
    id!: number;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    usageTypeId!: string | undefined;
    isPrimary!: boolean;

    constructor(data?: IContactPhoneInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.usageTypeId = _data["usageTypeId"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): ContactPhoneInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["usageTypeId"] = this.usageTypeId;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface IContactPhoneInfo {
    id: number;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    usageTypeId: string | undefined;
    isPrimary: boolean;
}

export class ContactPhotoInfo implements IContactPhotoInfo {
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;

    constructor(data?: IContactPhotoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.original = _data["original"];
            this.thumbnail = _data["thumbnail"];
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): ContactPhotoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhotoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        return data;
    }
}

export interface IContactPhotoInfo {
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
}

export class ContactPhotoInput implements IContactPhotoInput {
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IContactPhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.original = _data["original"];
            this.thumbnail = _data["thumbnail"];
            this.source = _data["source"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ContactPhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IContactPhotoInput {
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class ContactRatingInfoDto implements IContactRatingInfoDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IContactRatingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContactRatingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactRatingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IContactRatingInfoDto {
    id: number;
    name: string | undefined;
}

export class ContactShortInfo implements IContactShortInfo {
    id!: number;
    fullName!: string | undefined;
    photo!: ContactPhotoInfo | undefined;
    ratingId!: number | undefined;

    constructor(data?: IContactShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.photo = _data["photo"] ? ContactPhotoInfo.fromJS(_data["photo"]) : <any>undefined;
            this.ratingId = _data["ratingId"];
        }
    }

    static fromJS(data: any): ContactShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["ratingId"] = this.ratingId;
        return data;
    }
}

export interface IContactShortInfo {
    id: number;
    fullName: string | undefined;
    photo: ContactPhotoInfo | undefined;
    ratingId: number | undefined;
}

export class ContactsStatsByStarInfo implements IContactsStatsByStarInfo {
    date!: moment.Moment;
    totalCount!: number;
    starCount!: { [key: string]: number; } | undefined;

    constructor(data?: IContactsStatsByStarInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            if (_data["starCount"]) {
                this.starCount = {} as any;
                for (let key in _data["starCount"]) {
                    if (_data["starCount"].hasOwnProperty(key))
                        (<any>this.starCount)![key] = _data["starCount"][key];
                }
            }
        }
    }

    static fromJS(data: any): ContactsStatsByStarInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactsStatsByStarInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        if (this.starCount) {
            data["starCount"] = {};
            for (let key in this.starCount) {
                if (this.starCount.hasOwnProperty(key))
                    (<any>data["starCount"])[key] = this.starCount[key];
            }
        }
        return data;
    }
}

export interface IContactsStatsByStarInfo {
    date: moment.Moment;
    totalCount: number;
    starCount: { [key: string]: number; } | undefined;
}

export enum ContactStarColorType {
    Green = "Green",
    Blue = "Blue",
    Yellow = "Yellow",
    Red = "Red",
    Purple = "Purple",
    Gradient1 = "Gradient1",
    Gradient2 = "Gradient2",
    Gradient3 = "Gradient3",
    Gradient4 = "Gradient4",
    Gradient5 = "Gradient5",
    Blueprint = "Blueprint",
    Action = "Action",
    Nurturing = "Nurturing",
    Knowledge = "Knowledge",
    Unknown = "Unknown",
}

export class ContactStarInfoDto implements IContactStarInfoDto {
    id!: number;
    name!: string | undefined;
    colorType!: ContactStarColorType;

    constructor(data?: IContactStarInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.colorType = _data["colorType"];
        }
    }

    static fromJS(data: any): ContactStarInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStarInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["colorType"] = this.colorType;
        return data;
    }
}

export interface IContactStarInfoDto {
    id: number;
    name: string | undefined;
    colorType: ContactStarColorType;
}

export class ContactTagInfoDto implements IContactTagInfoDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IContactTagInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContactTagInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IContactTagInfoDto {
    id: number;
    name: string | undefined;
}

export class ContactTagInput implements IContactTagInput {
    name!: string;

    constructor(data?: IContactTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContactTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IContactTagInput {
    name: string;
}

export class CopyTemplateInput implements ICopyTemplateInput {
    contactId!: number;
    files!: FileInfo[] | undefined;

    constructor(data?: ICopyTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CopyTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CopyTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICopyTemplateInput {
    contactId: number;
    files: FileInfo[] | undefined;
}

export class CounterpartyDto implements ICounterpartyDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICounterpartyDto {
    id: string | undefined;
    name: string | undefined;
}

export class CountryDto implements ICountryDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto {
    code: string | undefined;
    name: string | undefined;
}

export class CountryStateDto implements ICountryStateDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryStateDto {
    code: string | undefined;
    name: string | undefined;
}

export class CreateAccountingTypeInput implements ICreateAccountingTypeInput {
    cashflowTypeId!: string | undefined;
    name!: string;
    sortOrder!: number;

    constructor(data?: ICreateAccountingTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateAccountingTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountingTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateAccountingTypeInput {
    cashflowTypeId: string | undefined;
    name: string;
    sortOrder: number;
}

export class CreateActivityDto implements ICreateActivityDto {
    type!: ActivityType;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ICreateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["assignedUserIds"])) {
                this.assignedUserIds = [] as any;
                for (let item of _data["assignedUserIds"])
                    this.assignedUserIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.allDay = _data["allDay"];
            this.stageId = _data["stageId"];
            this.leadId = _data["leadId"];
            this.contactId = _data["contactId"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.assignedUserIds)) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateActivityDto {
    type: ActivityType;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class CreateAffiliateLinkInput implements ICreateAffiliateLinkInput {
    category!: string | undefined;
    companyName!: string | undefined;
    phoneNumber!: string | undefined;
    url!: string;
    suggestedCopy!: string | undefined;

    constructor(data?: ICreateAffiliateLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.companyName = _data["companyName"];
            this.phoneNumber = _data["phoneNumber"];
            this.url = _data["url"];
            this.suggestedCopy = _data["suggestedCopy"];
        }
    }

    static fromJS(data: any): CreateAffiliateLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAffiliateLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["companyName"] = this.companyName;
        data["phoneNumber"] = this.phoneNumber;
        data["url"] = this.url;
        data["suggestedCopy"] = this.suggestedCopy;
        return data;
    }
}

export interface ICreateAffiliateLinkInput {
    category: string | undefined;
    companyName: string | undefined;
    phoneNumber: string | undefined;
    url: string;
    suggestedCopy: string | undefined;
}

export class CreateBusinessEntityDto implements ICreateBusinessEntityDto {
    name!: string;
    parentId!: number | undefined;
    industry!: string | undefined;
    type!: BusinessEntityType | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    neighborhood!: string | undefined;
    streetAddress!: string | undefined;
    isDefault!: boolean;

    constructor(data?: ICreateBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.industry = _data["industry"];
            this.type = _data["type"];
            this.taxNumber = _data["taxNumber"];
            this.dateOpened = _data["dateOpened"] ? moment(_data["dateOpened"].toString()) : <any>undefined;
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.alternativeEmail = _data["alternativeEmail"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.neighborhood = _data["neighborhood"];
            this.streetAddress = _data["streetAddress"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateBusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["neighborhood"] = this.neighborhood;
        data["streetAddress"] = this.streetAddress;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateBusinessEntityDto {
    name: string;
    parentId: number | undefined;
    industry: string | undefined;
    type: BusinessEntityType | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    neighborhood: string | undefined;
    streetAddress: string | undefined;
    isDefault: boolean;
}

export class CreateCashFlowCommentThreadInput implements ICreateCashFlowCommentThreadInput {
    accountId!: number | undefined;
    comment!: string;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: ICreateCashFlowCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.comment = _data["comment"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.accountingTypeId = _data["accountingTypeId"];
            this.categoryId = _data["categoryId"];
            this.reportSectionGroup = _data["reportSectionGroup"];
            this.reportSectionId = _data["reportSectionId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashFlowCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["comment"] = this.comment;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data;
    }
}

export interface ICreateCashFlowCommentThreadInput {
    accountId: number | undefined;
    comment: string;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class CreateCashFlowCommentThreadOutput implements ICreateCashFlowCommentThreadOutput {
    readonly threadId!: number;
    id!: number;

    constructor(data?: ICreateCashFlowCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).threadId = _data["threadId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashFlowCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateCashFlowCommentThreadOutput {
    threadId: number;
    id: number;
}

export class CreateCategoryInput implements ICreateCategoryInput {
    accountingTypeId!: number;
    parentId!: number | undefined;
    coAID!: string | undefined;
    name!: string;

    constructor(data?: ICreateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingTypeId = _data["accountingTypeId"];
            this.parentId = _data["parentId"];
            this.coAID = _data["coAID"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateCategoryInput {
    accountingTypeId: number;
    parentId: number | undefined;
    coAID: string | undefined;
    name: string;
}

export class CreateCommentInput implements ICreateCommentInput {
    threadId!: number;
    comment!: string;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.threadId = _data["threadId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateCommentInput {
    threadId: number;
    comment: string;
}

export class CreateCommentOutput implements ICreateCommentOutput {
    id!: number;

    constructor(data?: ICreateCommentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCommentOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateCommentOutput {
    id: number;
}

export class CreateContactAddressInput implements ICreateContactAddressInput {
    contactId!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.usageTypeId = _data["usageTypeId"];
            this.ownershipTypeId = _data["ownershipTypeId"];
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateContactAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateContactAddressInput {
    contactId: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    comment: string | undefined;
}

export class CreateContactAddressInputWithoutCheck implements ICreateContactAddressInputWithoutCheck {
    contactId!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactAddressInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.usageTypeId = _data["usageTypeId"];
            this.ownershipTypeId = _data["ownershipTypeId"];
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateContactAddressInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateContactAddressInputWithoutCheck {
    contactId: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    comment: string | undefined;
}

export class CreateContactAddressOutput implements ICreateContactAddressOutput {
    id!: number;

    constructor(data?: ICreateContactAddressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateContactAddressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateContactAddressOutput {
    id: number;
}

export class CreateContactAgentsInput implements ICreateContactAgentsInput {
    contactId!: number;
    source!: AgentDataSource;
    contactAgents!: ContactAgentInput[];

    constructor(data?: ICreateContactAgentsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactAgents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.source = _data["source"];
            if (Array.isArray(_data["contactAgents"])) {
                this.contactAgents = [] as any;
                for (let item of _data["contactAgents"])
                    this.contactAgents!.push(ContactAgentInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateContactAgentsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAgentsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["source"] = this.source;
        if (Array.isArray(this.contactAgents)) {
            data["contactAgents"] = [];
            for (let item of this.contactAgents)
                data["contactAgents"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateContactAgentsInput {
    contactId: number;
    source: AgentDataSource;
    contactAgents: ContactAgentInput[];
}

export class CreateContactEmailInput implements ICreateContactEmailInput {
    contactId!: number;
    emailAddress!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface ICreateContactEmailInput {
    contactId: number;
    emailAddress: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactEmailInputWithoutCheck implements ICreateContactEmailInputWithoutCheck {
    contactId!: number;
    emailAddress!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactEmailInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactEmailInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface ICreateContactEmailInputWithoutCheck {
    contactId: number;
    emailAddress: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactEmailOutput implements ICreateContactEmailOutput {
    id!: number;

    constructor(data?: ICreateContactEmailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateContactEmailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateContactEmailOutput {
    id: number;
}

export class CreateContactLinkInput implements ICreateContactLinkInput {
    contactId!: number;
    isConfirmed!: boolean;
    isCompany!: boolean;
    url!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: ICreateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.isConfirmed = _data["isConfirmed"];
            this.isCompany = _data["isCompany"];
            this.url = _data["url"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.comment = _data["comment"];
            this.linkTypeId = _data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateContactLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["isConfirmed"] = this.isConfirmed;
        data["isCompany"] = this.isCompany;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data;
    }
}

export interface ICreateContactLinkInput {
    contactId: number;
    isConfirmed: boolean;
    isCompany: boolean;
    url: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class CreateContactLinkInputWithoutCheck implements ICreateContactLinkInputWithoutCheck {
    contactId!: number;
    isConfirmed!: boolean;
    isCompany!: boolean;
    url!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: ICreateContactLinkInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.isConfirmed = _data["isConfirmed"];
            this.isCompany = _data["isCompany"];
            this.url = _data["url"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.comment = _data["comment"];
            this.linkTypeId = _data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateContactLinkInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["isConfirmed"] = this.isConfirmed;
        data["isCompany"] = this.isCompany;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data;
    }
}

export interface ICreateContactLinkInputWithoutCheck {
    contactId: number;
    isConfirmed: boolean;
    isCompany: boolean;
    url: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class CreateContactLinkOutput implements ICreateContactLinkOutput {
    id!: number;

    constructor(data?: ICreateContactLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateContactLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateContactLinkOutput {
    id: number;
}

export class CreateContactPhoneInput implements ICreateContactPhoneInput {
    contactId!: number;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactPhoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface ICreateContactPhoneInput {
    contactId: number;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactPhoneInputWithoutCheck implements ICreateContactPhoneInputWithoutCheck {
    contactId!: number;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactPhoneInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactPhoneInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface ICreateContactPhoneInputWithoutCheck {
    contactId: number;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactPhoneOutput implements ICreateContactPhoneOutput {
    id!: number;

    constructor(data?: ICreateContactPhoneOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateContactPhoneOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateContactPhoneOutput {
    id: number;
}

export class CreateContactPhotoInput implements ICreateContactPhotoInput {
    contactId!: number;
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactPhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.original = _data["original"];
            this.thumbnail = _data["thumbnail"];
            this.source = _data["source"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateContactPhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateContactPhotoInput {
    contactId: number;
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class CreateDocumentTypeInput implements ICreateDocumentTypeInput {
    name!: string;

    constructor(data?: ICreateDocumentTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateDocumentTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateDocumentTypeInput {
    name: string;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class CreateEmailTemplateRequest implements ICreateEmailTemplateRequest {
    name!: string;
    type!: EmailTemplateType;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    previewText!: string | undefined;
    body!: string;

    constructor(data?: ICreateEmailTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.subject = _data["subject"];
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.previewText = _data["previewText"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): CreateEmailTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmailTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["subject"] = this.subject;
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["previewText"] = this.previewText;
        data["body"] = this.body;
        return data;
    }
}

export interface ICreateEmailTemplateRequest {
    name: string;
    type: EmailTemplateType;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    previewText: string | undefined;
    body: string;
}

export class CreateForecastModelInput implements ICreateForecastModelInput {
    name!: string;

    constructor(data?: ICreateForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateForecastModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateForecastModelInput {
    name: string;
}

export class CreateForecastScheduleDto implements ICreateForecastScheduleDto {
    bankAccountId!: number;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    forecastModelIds!: number[];
    startDate!: moment.Moment;
    frequencyId!: string;
    currencyId!: string;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: ICreateForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecastModelIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountId = _data["bankAccountId"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            if (Array.isArray(_data["forecastModelIds"])) {
                this.forecastModelIds = [] as any;
                for (let item of _data["forecastModelIds"])
                    this.forecastModelIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.currencyId = _data["currencyId"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = _data["calculationTypeId"];
            this.amount = _data["amount"];
            this.monthNumber = _data["monthNumber"];
            this.weekNumber = _data["weekNumber"];
            this.dayNumber = _data["dayNumber"];
            this.weekDayNumber = _data["weekDayNumber"];
        }
    }

    static fromJS(data: any): CreateForecastScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        if (Array.isArray(this.forecastModelIds)) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data;
    }
}

export interface ICreateForecastScheduleDto {
    bankAccountId: number;
    cashflowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class CreateForecastsInput implements ICreateForecastsInput {
    forecasts!: AddForecastInput[];

    constructor(data?: ICreateForecastsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecasts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["forecasts"])) {
                this.forecasts = [] as any;
                for (let item of _data["forecasts"])
                    this.forecasts!.push(AddForecastInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateForecastsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.forecasts)) {
            data["forecasts"] = [];
            for (let item of this.forecasts)
                data["forecasts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateForecastsInput {
    forecasts: AddForecastInput[];
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateInvoiceInput implements ICreateInvoiceInput {
    contactId!: number;
    groupId!: string | undefined;
    orderId!: number | undefined;
    orderNumber!: string | undefined;
    leadId!: number | undefined;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment | undefined;
    grandTotal!: number;
    discountTotal!: number | undefined;
    shippingTotal!: number | undefined;
    taxTotal!: number | undefined;
    billingAddress!: InvoiceAddressInput | undefined;
    shippingAddress!: InvoiceAddressInput | undefined;
    description!: string | undefined;
    note!: string | undefined;
    lines!: CreateInvoiceLineInput[] | undefined;
    bypassValidation!: boolean;

    constructor(data?: ICreateInvoiceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.groupId = _data["groupId"];
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.leadId = _data["leadId"];
            this.status = _data["status"];
            this.number = _data["number"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.grandTotal = _data["grandTotal"];
            this.discountTotal = _data["discountTotal"];
            this.shippingTotal = _data["shippingTotal"];
            this.taxTotal = _data["taxTotal"];
            this.billingAddress = _data["billingAddress"] ? InvoiceAddressInput.fromJS(_data["billingAddress"]) : <any>undefined;
            this.shippingAddress = _data["shippingAddress"] ? InvoiceAddressInput.fromJS(_data["shippingAddress"]) : <any>undefined;
            this.description = _data["description"];
            this.note = _data["note"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(CreateInvoiceLineInput.fromJS(item));
            }
            this.bypassValidation = _data["bypassValidation"];
        }
    }

    static fromJS(data: any): CreateInvoiceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["groupId"] = this.groupId;
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["leadId"] = this.leadId;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["grandTotal"] = this.grandTotal;
        data["discountTotal"] = this.discountTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["taxTotal"] = this.taxTotal;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["bypassValidation"] = this.bypassValidation;
        return data;
    }
}

export interface ICreateInvoiceInput {
    contactId: number;
    groupId: string | undefined;
    orderId: number | undefined;
    orderNumber: string | undefined;
    leadId: number | undefined;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment | undefined;
    grandTotal: number;
    discountTotal: number | undefined;
    shippingTotal: number | undefined;
    taxTotal: number | undefined;
    billingAddress: InvoiceAddressInput | undefined;
    shippingAddress: InvoiceAddressInput | undefined;
    description: string | undefined;
    note: string | undefined;
    lines: CreateInvoiceLineInput[] | undefined;
    bypassValidation: boolean;
}

export class CreateInvoiceLineInput implements ICreateInvoiceLineInput {
    quantity!: number;
    rate!: number;
    total!: number;
    commissionableAmount!: number | undefined;
    unitId!: ProductMeasurementUnit;
    productCode!: string | undefined;
    description!: string | undefined;
    sortOrder!: number;

    constructor(data?: ICreateInvoiceLineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.total = _data["total"];
            this.commissionableAmount = _data["commissionableAmount"];
            this.unitId = _data["unitId"];
            this.productCode = _data["productCode"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateInvoiceLineInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceLineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["total"] = this.total;
        data["commissionableAmount"] = this.commissionableAmount;
        data["unitId"] = this.unitId;
        data["productCode"] = this.productCode;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateInvoiceLineInput {
    quantity: number;
    rate: number;
    total: number;
    commissionableAmount: number | undefined;
    unitId: ProductMeasurementUnit;
    productCode: string | undefined;
    description: string | undefined;
    sortOrder: number;
}

export class CreateLeadOutput implements ICreateLeadOutput {
    contactId!: number;
    leadId!: number;

    constructor(data?: ICreateLeadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.leadId = _data["leadId"];
        }
    }

    static fromJS(data: any): CreateLeadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLeadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["leadId"] = this.leadId;
        return data;
    }
}

export interface ICreateLeadOutput {
    contactId: number;
    leadId: number;
}

export class CreateLearningResourceGroupInput implements ICreateLearningResourceGroupInput {
    name!: string;
    htmlColor!: string | undefined;
    isActive!: boolean;

    constructor(data?: ICreateLearningResourceGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.htmlColor = _data["htmlColor"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateLearningResourceGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLearningResourceGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["htmlColor"] = this.htmlColor;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateLearningResourceGroupInput {
    name: string;
    htmlColor: string | undefined;
    isActive: boolean;
}

export class CreateLearningResourceGroupOutput implements ICreateLearningResourceGroupOutput {
    id!: number;
    sortOrder!: number;

    constructor(data?: ICreateLearningResourceGroupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateLearningResourceGroupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLearningResourceGroupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateLearningResourceGroupOutput {
    id: number;
    sortOrder: number;
}

export class CreateLearningResourceInput implements ICreateLearningResourceInput {
    groupId!: number;
    isParent!: boolean;
    parentId!: number | undefined;
    type!: LearningResourceType | undefined;
    name!: string;
    url!: string | undefined;
    fileName!: string | undefined;
    fileSize!: number | undefined;
    file!: string | undefined;
    isActive!: boolean;
    memberServiceAssignments!: MemberServiceAssignmentInput[] | undefined;

    constructor(data?: ICreateLearningResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.isParent = _data["isParent"];
            this.parentId = _data["parentId"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.file = _data["file"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["memberServiceAssignments"])) {
                this.memberServiceAssignments = [] as any;
                for (let item of _data["memberServiceAssignments"])
                    this.memberServiceAssignments!.push(MemberServiceAssignmentInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateLearningResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLearningResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["isParent"] = this.isParent;
        data["parentId"] = this.parentId;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["file"] = this.file;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.memberServiceAssignments)) {
            data["memberServiceAssignments"] = [];
            for (let item of this.memberServiceAssignments)
                data["memberServiceAssignments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateLearningResourceInput {
    groupId: number;
    isParent: boolean;
    parentId: number | undefined;
    type: LearningResourceType | undefined;
    name: string;
    url: string | undefined;
    fileName: string | undefined;
    fileSize: number | undefined;
    file: string | undefined;
    isActive: boolean;
    memberServiceAssignments: MemberServiceAssignmentInput[] | undefined;
}

export class CreateLearningResourceOutput implements ICreateLearningResourceOutput {
    id!: number;
    sortOrder!: number;

    constructor(data?: ICreateLearningResourceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateLearningResourceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLearningResourceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateLearningResourceOutput {
    id: number;
    sortOrder: number;
}

export class CreateLinkInput implements ICreateLinkInput {
    url!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: ICreateLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.comment = _data["comment"];
            this.linkTypeId = _data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data;
    }
}

export interface ICreateLinkInput {
    url: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class CreateLinkOutput implements ICreateLinkOutput {
    id!: number;

    constructor(data?: ICreateLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateLinkOutput {
    id: number;
}

export class CreateNoteInput implements ICreateNoteInput {
    contactId!: number;
    text!: string;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    leadId!: number | undefined;
    noteType!: NoteType;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;

    constructor(data?: ICreateNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.text = _data["text"];
            this.contactPhoneId = _data["contactPhoneId"];
            this.orderId = _data["orderId"];
            this.leadId = _data["leadId"];
            this.noteType = _data["noteType"];
            this.followUpDateTime = _data["followUpDateTime"] ? moment(_data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = _data["addedByUserId"];
        }
    }

    static fromJS(data: any): CreateNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["text"] = this.text;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["leadId"] = this.leadId;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        return data;
    }
}

export interface ICreateNoteInput {
    contactId: number;
    text: string;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    leadId: number | undefined;
    noteType: NoteType;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
}

export class CreateNoteOutput implements ICreateNoteOutput {
    id!: number;

    constructor(data?: ICreateNoteOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateNoteOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateNoteOutput {
    id: number;
}

export class CreateOrEditLeadInput implements ICreateOrEditLeadInput {
    id!: number | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    companyName!: string | undefined;
    emailAddress!: CreateContactEmailInputWithoutCheck | undefined;
    phoneNumber!: CreateContactPhoneInputWithoutCheck | undefined;
    address!: CreateContactAddressInputWithoutCheck | undefined;
    isAIGeneratedBankCode!: boolean;
    bankCode!: string | undefined;
    bankCodeSource!: string | undefined;

    constructor(data?: ICreateOrEditLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.namePrefix = _data["namePrefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
            this.companyName = _data["companyName"];
            this.emailAddress = _data["emailAddress"] ? CreateContactEmailInputWithoutCheck.fromJS(_data["emailAddress"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"] ? CreateContactPhoneInputWithoutCheck.fromJS(_data["phoneNumber"]) : <any>undefined;
            this.address = _data["address"] ? CreateContactAddressInputWithoutCheck.fromJS(_data["address"]) : <any>undefined;
            this.isAIGeneratedBankCode = _data["isAIGeneratedBankCode"];
            this.bankCode = _data["bankCode"];
            this.bankCodeSource = _data["bankCodeSource"];
        }
    }

    static fromJS(data: any): CreateOrEditLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["companyName"] = this.companyName;
        data["emailAddress"] = this.emailAddress ? this.emailAddress.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["isAIGeneratedBankCode"] = this.isAIGeneratedBankCode;
        data["bankCode"] = this.bankCode;
        data["bankCodeSource"] = this.bankCodeSource;
        return data;
    }
}

export interface ICreateOrEditLeadInput {
    id: number | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    companyName: string | undefined;
    emailAddress: CreateContactEmailInputWithoutCheck | undefined;
    phoneNumber: CreateContactPhoneInputWithoutCheck | undefined;
    address: CreateContactAddressInputWithoutCheck | undefined;
    isAIGeneratedBankCode: boolean;
    bankCode: string | undefined;
    bankCodeSource: string | undefined;
}

export class CreateOrganizationInput implements ICreateOrganizationInput {
    relatedContactId!: number;
    relationTypeId!: string;
    createRootOrganizationUnit!: boolean;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    affiliateCode!: string | undefined;
    departmentCode!: string | undefined;

    constructor(data?: ICreateOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relatedContactId = _data["relatedContactId"];
            this.relationTypeId = _data["relationTypeId"];
            this.createRootOrganizationUnit = _data["createRootOrganizationUnit"];
            this.companyName = _data["companyName"];
            this.shortName = _data["shortName"];
            this.typeId = _data["typeId"];
            this.industry = _data["industry"];
            this.annualRevenue = _data["annualRevenue"];
            this.ein = _data["ein"];
            this.businessSicCode = _data["businessSicCode"];
            this.formedCountryId = _data["formedCountryId"];
            this.formedStateId = _data["formedStateId"];
            this.description = _data["description"];
            this.formedDate = _data["formedDate"] ? moment(_data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = _data["sizeFrom"];
            this.sizeTo = _data["sizeTo"];
            this.duns = _data["duns"];
            this.ticker = _data["ticker"];
            this.affiliateCode = _data["affiliateCode"];
            this.departmentCode = _data["departmentCode"];
        }
    }

    static fromJS(data: any): CreateOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedContactId"] = this.relatedContactId;
        data["relationTypeId"] = this.relationTypeId;
        data["createRootOrganizationUnit"] = this.createRootOrganizationUnit;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["affiliateCode"] = this.affiliateCode;
        data["departmentCode"] = this.departmentCode;
        return data;
    }
}

export interface ICreateOrganizationInput {
    relatedContactId: number;
    relationTypeId: string;
    createRootOrganizationUnit: boolean;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    affiliateCode: string | undefined;
    departmentCode: string | undefined;
}

export class CreateOrganizationOutput implements ICreateOrganizationOutput {
    id!: number;

    constructor(data?: ICreateOrganizationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrganizationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrganizationOutput {
    id: number;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreateOrgUnitForOrganizationInput implements ICreateOrgUnitForOrganizationInput {
    organizationId!: number | undefined;
    organizationName!: string | undefined;

    constructor(data?: ICreateOrgUnitForOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
        }
    }

    static fromJS(data: any): CreateOrgUnitForOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrgUnitForOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        return data;
    }
}

export interface ICreateOrgUnitForOrganizationInput {
    organizationId: number | undefined;
    organizationName: string | undefined;
}

export class CreateOrgUnitForOrganizationOutput implements ICreateOrgUnitForOrganizationOutput {
    organizationUnitId!: number;

    constructor(data?: ICreateOrgUnitForOrganizationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateOrgUnitForOrganizationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrgUnitForOrganizationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface ICreateOrgUnitForOrganizationOutput {
    organizationUnitId: number;
}

export class CreateOrUpdateContactInput implements ICreateOrUpdateContactInput {
    matchExisting!: boolean;
    parentContactId!: number | undefined;
    questionnaireAnswers!: SubmitQuestionsAndAnswersDtoWithoutCheck | undefined;
    contactId!: number | undefined;
    contactXRef!: string | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    emailAddresses!: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers!: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses!: CreateContactAddressInputWithoutCheck[] | undefined;
    links!: CreateContactLinkInputWithoutCheck[] | undefined;
    dob!: moment.Moment | undefined;
    bankCode!: string | undefined;
    bankCodeSource!: string | undefined;
    gender!: Gender | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    note!: string | undefined;
    interests!: string[] | undefined;
    companyName!: string | undefined;
    industry!: string | undefined;
    photo!: ContactPhotoInput | undefined;
    sourceContactId!: number | undefined;
    sourceOrganizationUnitId!: number | undefined;
    personAffiliateCode!: string | undefined;
    title!: string | undefined;
    tags!: ContactTagInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    contactGroupId!: string;
    isActive!: boolean;
    isProspective!: boolean;
    statusId!: string | undefined;
    partnerTypeName!: string | undefined;
    leadTypeId!: number | undefined;
    leadTypeSysId!: string | undefined;
    stageId!: number | undefined;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;
    followUpDate!: moment.Moment | undefined;
    trackingInfo!: TrackingInfo | undefined;
    inviteUser!: boolean;
    generateAutoLoginLink!: boolean;
    newUserPassword!: string | undefined;
    changeNewUserPasswordOnNextLogin!: boolean | undefined;
    noWelcomeEmail!: boolean;
    welcomeEmailTemplateRef!: string | undefined;
    propertyInfo!: PropertyInput | undefined;
    bypassValidation!: boolean;

    constructor(data?: ICreateOrUpdateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchExisting = _data["matchExisting"];
            this.parentContactId = _data["parentContactId"];
            this.questionnaireAnswers = _data["questionnaireAnswers"] ? SubmitQuestionsAndAnswersDtoWithoutCheck.fromJS(_data["questionnaireAnswers"]) : <any>undefined;
            this.contactId = _data["contactId"];
            this.contactXRef = _data["contactXRef"];
            this.namePrefix = _data["namePrefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(CreateContactEmailInputWithoutCheck.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(CreateContactPhoneInputWithoutCheck.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CreateContactAddressInputWithoutCheck.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CreateContactLinkInputWithoutCheck.fromJS(item));
            }
            this.dob = _data["dob"] ? moment(_data["dob"].toString()) : <any>undefined;
            this.bankCode = _data["bankCode"];
            this.bankCodeSource = _data["bankCodeSource"];
            this.gender = _data["gender"];
            this.experience = _data["experience"];
            this.profileSummary = _data["profileSummary"];
            this.note = _data["note"];
            if (Array.isArray(_data["interests"])) {
                this.interests = [] as any;
                for (let item of _data["interests"])
                    this.interests!.push(item);
            }
            this.companyName = _data["companyName"];
            this.industry = _data["industry"];
            this.photo = _data["photo"] ? ContactPhotoInput.fromJS(_data["photo"]) : <any>undefined;
            this.sourceContactId = _data["sourceContactId"];
            this.sourceOrganizationUnitId = _data["sourceOrganizationUnitId"];
            this.personAffiliateCode = _data["personAffiliateCode"];
            this.title = _data["title"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ContactTagInput.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ContactListInput.fromJS(item));
            }
            this.assignedUserId = _data["assignedUserId"];
            this.ratingId = _data["ratingId"];
            this.contactGroupId = _data["contactGroupId"];
            this.isActive = _data["isActive"];
            this.isProspective = _data["isProspective"];
            this.statusId = _data["statusId"];
            this.partnerTypeName = _data["partnerTypeName"];
            this.leadTypeId = _data["leadTypeId"];
            this.leadTypeSysId = _data["leadTypeSysId"];
            this.stageId = _data["stageId"];
            this.dealAmount = _data["dealAmount"];
            this.installmentAmount = _data["installmentAmount"];
            this.followUpDate = _data["followUpDate"] ? moment(_data["followUpDate"].toString()) : <any>undefined;
            this.trackingInfo = _data["trackingInfo"] ? TrackingInfo.fromJS(_data["trackingInfo"]) : <any>undefined;
            this.inviteUser = _data["inviteUser"];
            this.generateAutoLoginLink = _data["generateAutoLoginLink"];
            this.newUserPassword = _data["newUserPassword"];
            this.changeNewUserPasswordOnNextLogin = _data["changeNewUserPasswordOnNextLogin"];
            this.noWelcomeEmail = _data["noWelcomeEmail"];
            this.welcomeEmailTemplateRef = _data["welcomeEmailTemplateRef"];
            this.propertyInfo = _data["propertyInfo"] ? PropertyInput.fromJS(_data["propertyInfo"]) : <any>undefined;
            this.bypassValidation = _data["bypassValidation"];
        }
    }

    static fromJS(data: any): CreateOrUpdateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchExisting"] = this.matchExisting;
        data["parentContactId"] = this.parentContactId;
        data["questionnaireAnswers"] = this.questionnaireAnswers ? this.questionnaireAnswers.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contactXRef"] = this.contactXRef;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["bankCode"] = this.bankCode;
        data["bankCodeSource"] = this.bankCodeSource;
        data["gender"] = this.gender;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["note"] = this.note;
        if (Array.isArray(this.interests)) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["companyName"] = this.companyName;
        data["industry"] = this.industry;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["personAffiliateCode"] = this.personAffiliateCode;
        data["title"] = this.title;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["contactGroupId"] = this.contactGroupId;
        data["isActive"] = this.isActive;
        data["isProspective"] = this.isProspective;
        data["statusId"] = this.statusId;
        data["partnerTypeName"] = this.partnerTypeName;
        data["leadTypeId"] = this.leadTypeId;
        data["leadTypeSysId"] = this.leadTypeSysId;
        data["stageId"] = this.stageId;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        data["inviteUser"] = this.inviteUser;
        data["generateAutoLoginLink"] = this.generateAutoLoginLink;
        data["newUserPassword"] = this.newUserPassword;
        data["changeNewUserPasswordOnNextLogin"] = this.changeNewUserPasswordOnNextLogin;
        data["noWelcomeEmail"] = this.noWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["bypassValidation"] = this.bypassValidation;
        return data;
    }
}

export interface ICreateOrUpdateContactInput {
    matchExisting: boolean;
    parentContactId: number | undefined;
    questionnaireAnswers: SubmitQuestionsAndAnswersDtoWithoutCheck | undefined;
    contactId: number | undefined;
    contactXRef: string | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    emailAddresses: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses: CreateContactAddressInputWithoutCheck[] | undefined;
    links: CreateContactLinkInputWithoutCheck[] | undefined;
    dob: moment.Moment | undefined;
    bankCode: string | undefined;
    bankCodeSource: string | undefined;
    gender: Gender | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    note: string | undefined;
    interests: string[] | undefined;
    companyName: string | undefined;
    industry: string | undefined;
    photo: ContactPhotoInput | undefined;
    sourceContactId: number | undefined;
    sourceOrganizationUnitId: number | undefined;
    personAffiliateCode: string | undefined;
    title: string | undefined;
    tags: ContactTagInput[] | undefined;
    lists: ContactListInput[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    contactGroupId: string;
    isActive: boolean;
    isProspective: boolean;
    statusId: string | undefined;
    partnerTypeName: string | undefined;
    leadTypeId: number | undefined;
    leadTypeSysId: string | undefined;
    stageId: number | undefined;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
    followUpDate: moment.Moment | undefined;
    trackingInfo: TrackingInfo | undefined;
    inviteUser: boolean;
    generateAutoLoginLink: boolean;
    newUserPassword: string | undefined;
    changeNewUserPasswordOnNextLogin: boolean | undefined;
    noWelcomeEmail: boolean;
    welcomeEmailTemplateRef: string | undefined;
    propertyInfo: PropertyInput | undefined;
    bypassValidation: boolean;
}

export class CreateOrUpdateContactOutput implements ICreateOrUpdateContactOutput {
    contactId!: number;
    leadId!: number | undefined;
    userId!: number | undefined;
    userKey!: string | undefined;
    userEmailAddress!: string | undefined;
    autoLoginLink!: string | undefined;

    constructor(data?: ICreateOrUpdateContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.leadId = _data["leadId"];
            this.userId = _data["userId"];
            this.userKey = _data["userKey"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.autoLoginLink = _data["autoLoginLink"];
        }
    }

    static fromJS(data: any): CreateOrUpdateContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["leadId"] = this.leadId;
        data["userId"] = this.userId;
        data["userKey"] = this.userKey;
        data["userEmailAddress"] = this.userEmailAddress;
        data["autoLoginLink"] = this.autoLoginLink;
        return data;
    }
}

export interface ICreateOrUpdateContactOutput {
    contactId: number;
    leadId: number | undefined;
    userId: number | undefined;
    userKey: string | undefined;
    userEmailAddress: string | undefined;
    autoLoginLink: string | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class CreateOrUpdateLeadInput implements ICreateOrUpdateLeadInput {
    contactId!: number | undefined;
    contactXRef!: string | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    emailAddresses!: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers!: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses!: CreateContactAddressInputWithoutCheck[] | undefined;
    links!: CreateContactLinkInputWithoutCheck[] | undefined;
    dob!: moment.Moment | undefined;
    bankCode!: string | undefined;
    bankCodeSource!: string | undefined;
    gender!: Gender | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    note!: string | undefined;
    interests!: string[] | undefined;
    companyName!: string | undefined;
    industry!: string | undefined;
    photo!: ContactPhotoInput | undefined;
    sourceContactId!: number | undefined;
    sourceOrganizationUnitId!: number | undefined;
    personAffiliateCode!: string | undefined;
    title!: string | undefined;
    tags!: ContactTagInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    contactGroupId!: string;
    isActive!: boolean;
    isProspective!: boolean;
    statusId!: string | undefined;
    partnerTypeName!: string | undefined;
    leadTypeId!: number | undefined;
    leadTypeSysId!: string | undefined;
    stageId!: number | undefined;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;
    followUpDate!: moment.Moment | undefined;
    trackingInfo!: TrackingInfo | undefined;
    inviteUser!: boolean;
    generateAutoLoginLink!: boolean;
    newUserPassword!: string | undefined;
    changeNewUserPasswordOnNextLogin!: boolean | undefined;
    noWelcomeEmail!: boolean;
    welcomeEmailTemplateRef!: string | undefined;
    propertyInfo!: PropertyInput | undefined;
    bypassValidation!: boolean;

    constructor(data?: ICreateOrUpdateLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.contactXRef = _data["contactXRef"];
            this.namePrefix = _data["namePrefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(CreateContactEmailInputWithoutCheck.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(CreateContactPhoneInputWithoutCheck.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CreateContactAddressInputWithoutCheck.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CreateContactLinkInputWithoutCheck.fromJS(item));
            }
            this.dob = _data["dob"] ? moment(_data["dob"].toString()) : <any>undefined;
            this.bankCode = _data["bankCode"];
            this.bankCodeSource = _data["bankCodeSource"];
            this.gender = _data["gender"];
            this.experience = _data["experience"];
            this.profileSummary = _data["profileSummary"];
            this.note = _data["note"];
            if (Array.isArray(_data["interests"])) {
                this.interests = [] as any;
                for (let item of _data["interests"])
                    this.interests!.push(item);
            }
            this.companyName = _data["companyName"];
            this.industry = _data["industry"];
            this.photo = _data["photo"] ? ContactPhotoInput.fromJS(_data["photo"]) : <any>undefined;
            this.sourceContactId = _data["sourceContactId"];
            this.sourceOrganizationUnitId = _data["sourceOrganizationUnitId"];
            this.personAffiliateCode = _data["personAffiliateCode"];
            this.title = _data["title"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ContactTagInput.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ContactListInput.fromJS(item));
            }
            this.assignedUserId = _data["assignedUserId"];
            this.ratingId = _data["ratingId"];
            this.contactGroupId = _data["contactGroupId"];
            this.isActive = _data["isActive"];
            this.isProspective = _data["isProspective"];
            this.statusId = _data["statusId"];
            this.partnerTypeName = _data["partnerTypeName"];
            this.leadTypeId = _data["leadTypeId"];
            this.leadTypeSysId = _data["leadTypeSysId"];
            this.stageId = _data["stageId"];
            this.dealAmount = _data["dealAmount"];
            this.installmentAmount = _data["installmentAmount"];
            this.followUpDate = _data["followUpDate"] ? moment(_data["followUpDate"].toString()) : <any>undefined;
            this.trackingInfo = _data["trackingInfo"] ? TrackingInfo.fromJS(_data["trackingInfo"]) : <any>undefined;
            this.inviteUser = _data["inviteUser"];
            this.generateAutoLoginLink = _data["generateAutoLoginLink"];
            this.newUserPassword = _data["newUserPassword"];
            this.changeNewUserPasswordOnNextLogin = _data["changeNewUserPasswordOnNextLogin"];
            this.noWelcomeEmail = _data["noWelcomeEmail"];
            this.welcomeEmailTemplateRef = _data["welcomeEmailTemplateRef"];
            this.propertyInfo = _data["propertyInfo"] ? PropertyInput.fromJS(_data["propertyInfo"]) : <any>undefined;
            this.bypassValidation = _data["bypassValidation"];
        }
    }

    static fromJS(data: any): CreateOrUpdateLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXRef"] = this.contactXRef;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["bankCode"] = this.bankCode;
        data["bankCodeSource"] = this.bankCodeSource;
        data["gender"] = this.gender;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["note"] = this.note;
        if (Array.isArray(this.interests)) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["companyName"] = this.companyName;
        data["industry"] = this.industry;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["personAffiliateCode"] = this.personAffiliateCode;
        data["title"] = this.title;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["contactGroupId"] = this.contactGroupId;
        data["isActive"] = this.isActive;
        data["isProspective"] = this.isProspective;
        data["statusId"] = this.statusId;
        data["partnerTypeName"] = this.partnerTypeName;
        data["leadTypeId"] = this.leadTypeId;
        data["leadTypeSysId"] = this.leadTypeSysId;
        data["stageId"] = this.stageId;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        data["inviteUser"] = this.inviteUser;
        data["generateAutoLoginLink"] = this.generateAutoLoginLink;
        data["newUserPassword"] = this.newUserPassword;
        data["changeNewUserPasswordOnNextLogin"] = this.changeNewUserPasswordOnNextLogin;
        data["noWelcomeEmail"] = this.noWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["bypassValidation"] = this.bypassValidation;
        return data;
    }
}

export interface ICreateOrUpdateLeadInput {
    contactId: number | undefined;
    contactXRef: string | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    emailAddresses: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses: CreateContactAddressInputWithoutCheck[] | undefined;
    links: CreateContactLinkInputWithoutCheck[] | undefined;
    dob: moment.Moment | undefined;
    bankCode: string | undefined;
    bankCodeSource: string | undefined;
    gender: Gender | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    note: string | undefined;
    interests: string[] | undefined;
    companyName: string | undefined;
    industry: string | undefined;
    photo: ContactPhotoInput | undefined;
    sourceContactId: number | undefined;
    sourceOrganizationUnitId: number | undefined;
    personAffiliateCode: string | undefined;
    title: string | undefined;
    tags: ContactTagInput[] | undefined;
    lists: ContactListInput[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    contactGroupId: string;
    isActive: boolean;
    isProspective: boolean;
    statusId: string | undefined;
    partnerTypeName: string | undefined;
    leadTypeId: number | undefined;
    leadTypeSysId: string | undefined;
    stageId: number | undefined;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
    followUpDate: moment.Moment | undefined;
    trackingInfo: TrackingInfo | undefined;
    inviteUser: boolean;
    generateAutoLoginLink: boolean;
    newUserPassword: string | undefined;
    changeNewUserPasswordOnNextLogin: boolean | undefined;
    noWelcomeEmail: boolean;
    welcomeEmailTemplateRef: string | undefined;
    propertyInfo: PropertyInput | undefined;
    bypassValidation: boolean;
}

export class CreateOrUpdateLeadOutput implements ICreateOrUpdateLeadOutput {
    contactId!: number;
    leadId!: number | undefined;
    userId!: number | undefined;
    userKey!: string | undefined;
    userEmailAddress!: string | undefined;
    autoLoginLink!: string | undefined;

    constructor(data?: ICreateOrUpdateLeadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.leadId = _data["leadId"];
            this.userId = _data["userId"];
            this.userKey = _data["userKey"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.autoLoginLink = _data["autoLoginLink"];
        }
    }

    static fromJS(data: any): CreateOrUpdateLeadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLeadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["leadId"] = this.leadId;
        data["userId"] = this.userId;
        data["userKey"] = this.userKey;
        data["userEmailAddress"] = this.userEmailAddress;
        data["autoLoginLink"] = this.autoLoginLink;
        return data;
    }
}

export interface ICreateOrUpdateLeadOutput {
    contactId: number;
    leadId: number | undefined;
    userId: number | undefined;
    userKey: string | undefined;
    userEmailAddress: string | undefined;
    autoLoginLink: string | undefined;
}

export class CreateOrUpdateMemberServiceOutput implements ICreateOrUpdateMemberServiceOutput {
    id!: number;
    memberServiceLevels!: MemberServiceLevelBaseDto[] | undefined;

    constructor(data?: ICreateOrUpdateMemberServiceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["memberServiceLevels"])) {
                this.memberServiceLevels = [] as any;
                for (let item of _data["memberServiceLevels"])
                    this.memberServiceLevels!.push(MemberServiceLevelBaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateMemberServiceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMemberServiceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.memberServiceLevels)) {
            data["memberServiceLevels"] = [];
            for (let item of this.memberServiceLevels)
                data["memberServiceLevels"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrUpdateMemberServiceOutput {
    id: number;
    memberServiceLevels: MemberServiceLevelBaseDto[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    profilePicture!: string | undefined;
    profileThumbnail!: string | undefined;
    pictureSource!: string | undefined;
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.profilePicture = _data["profilePicture"];
            this.profileThumbnail = _data["profileThumbnail"];
            this.pictureSource = _data["pictureSource"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["profilePicture"] = this.profilePicture;
        data["profileThumbnail"] = this.profileThumbnail;
        data["pictureSource"] = this.pictureSource;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    profilePicture: string | undefined;
    profileThumbnail: string | undefined;
    pictureSource: string | undefined;
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
}

export class CreatePersonOrgRelationInput implements ICreatePersonOrgRelationInput {
    personId!: number;
    organizationId!: number | undefined;
    organizationName!: string | undefined;
    relationshipType!: string;
    jobTitle!: string | undefined;

    constructor(data?: ICreatePersonOrgRelationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.relationshipType = _data["relationshipType"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): CreatePersonOrgRelationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonOrgRelationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["relationshipType"] = this.relationshipType;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface ICreatePersonOrgRelationInput {
    personId: number;
    organizationId: number | undefined;
    organizationName: string | undefined;
    relationshipType: string;
    jobTitle: string | undefined;
}

export class CreatePersonOrgRelationOutput implements ICreatePersonOrgRelationOutput {
    id!: number;
    organizationId!: number;

    constructor(data?: ICreatePersonOrgRelationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): CreatePersonOrgRelationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonOrgRelationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        return data;
    }
}

export interface ICreatePersonOrgRelationOutput {
    id: number;
    organizationId: number;
}

export class CreatePointInfoOutput implements ICreatePointInfoOutput {
    id!: number;
    sortOrder!: number;

    constructor(data?: ICreatePointInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreatePointInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePointInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreatePointInfoOutput {
    id: number;
    sortOrder: number;
}

export class CreateProductInput implements ICreateProductInput {
    code!: string;
    name!: string;
    description!: string | undefined;
    groupId!: number | undefined;
    groupName!: string | undefined;
    type!: ProductType;
    price!: number | undefined;
    commissionableAmount!: number | undefined;
    maxCommissionRate!: number | undefined;
    maxCommissionRateTier2!: number | undefined;
    unit!: ProductMeasurementUnit | undefined;
    productServices!: ProductServiceInfo[] | undefined;
    productSubscriptionOptions!: ProductSubscriptionOptionInfo[] | undefined;

    constructor(data?: ICreateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.type = _data["type"];
            this.price = _data["price"];
            this.commissionableAmount = _data["commissionableAmount"];
            this.maxCommissionRate = _data["maxCommissionRate"];
            this.maxCommissionRateTier2 = _data["maxCommissionRateTier2"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["productServices"])) {
                this.productServices = [] as any;
                for (let item of _data["productServices"])
                    this.productServices!.push(ProductServiceInfo.fromJS(item));
            }
            if (Array.isArray(_data["productSubscriptionOptions"])) {
                this.productSubscriptionOptions = [] as any;
                for (let item of _data["productSubscriptionOptions"])
                    this.productSubscriptionOptions!.push(ProductSubscriptionOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["type"] = this.type;
        data["price"] = this.price;
        data["commissionableAmount"] = this.commissionableAmount;
        data["maxCommissionRate"] = this.maxCommissionRate;
        data["maxCommissionRateTier2"] = this.maxCommissionRateTier2;
        data["unit"] = this.unit;
        if (Array.isArray(this.productServices)) {
            data["productServices"] = [];
            for (let item of this.productServices)
                data["productServices"].push(item.toJSON());
        }
        if (Array.isArray(this.productSubscriptionOptions)) {
            data["productSubscriptionOptions"] = [];
            for (let item of this.productSubscriptionOptions)
                data["productSubscriptionOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateProductInput {
    code: string;
    name: string;
    description: string | undefined;
    groupId: number | undefined;
    groupName: string | undefined;
    type: ProductType;
    price: number | undefined;
    commissionableAmount: number | undefined;
    maxCommissionRate: number | undefined;
    maxCommissionRateTier2: number | undefined;
    unit: ProductMeasurementUnit | undefined;
    productServices: ProductServiceInfo[] | undefined;
    productSubscriptionOptions: ProductSubscriptionOptionInfo[] | undefined;
}

export class CreateProductOutput implements ICreateProductOutput {
    productId!: number;

    constructor(data?: ICreateProductOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateProductOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        return data;
    }
}

export interface ICreateProductOutput {
    productId: number;
}

export class CreateProfilePhotoInput implements ICreateProfilePhotoInput {
    providerKey!: string | undefined;
    fileUrl!: string | undefined;
    thumbnailUrl!: string | undefined;
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateProfilePhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerKey = _data["providerKey"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.original = _data["original"];
            this.thumbnail = _data["thumbnail"];
            this.source = _data["source"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateProfilePhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProfilePhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerKey"] = this.providerKey;
        data["fileUrl"] = this.fileUrl;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateProfilePhotoInput {
    providerKey: string | undefined;
    fileUrl: string | undefined;
    thumbnailUrl: string | undefined;
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class CreateRuleDto implements ICreateRuleDto {
    parentId!: number | undefined;
    name!: string;
    categoryId!: number;
    transactionDescriptor!: string | undefined;
    transactionDescriptorAttributeTypeId!: string | undefined;
    condition!: ConditionDto;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption;

    constructor(data?: ICreateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.condition = new ConditionDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = _data["transactionDescriptorAttributeTypeId"];
            this.condition = _data["condition"] ? ConditionDto.fromJS(_data["condition"]) : new ConditionDto();
            if (Array.isArray(_data["sourceTransactionList"])) {
                this.sourceTransactionList = [] as any;
                for (let item of _data["sourceTransactionList"])
                    this.sourceTransactionList!.push(item);
            }
            this.applyOption = _data["applyOption"];
        }
    }

    static fromJS(data: any): CreateRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (Array.isArray(this.sourceTransactionList)) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data;
    }
}

export interface ICreateRuleDto {
    parentId: number | undefined;
    name: string;
    categoryId: number;
    transactionDescriptor: string | undefined;
    transactionDescriptorAttributeTypeId: string | undefined;
    condition: ConditionDto;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption;
}

export class CreateStageChecklistPointInput implements ICreateStageChecklistPointInput {
    stageId!: number;
    name!: string;

    constructor(data?: ICreateStageChecklistPointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stageId = _data["stageId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateStageChecklistPointInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStageChecklistPointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stageId"] = this.stageId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateStageChecklistPointInput {
    stageId: number;
    name: string;
}

export class CreateStageInput implements ICreateStageInput {
    pipelineId!: number;
    name!: string;
    sortOrder!: number;

    constructor(data?: ICreateStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pipelineId = _data["pipelineId"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelineId"] = this.pipelineId;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateStageInput {
    pipelineId: number;
    name: string;
    sortOrder: number;
}

export class CreateSyncAccountInput implements ICreateSyncAccountInput {
    typeId!: string;
    publicToken!: string | undefined;
    syncAccountRef!: string | undefined;
    isSyncBankAccountsEnabled!: boolean;

    constructor(data?: ICreateSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.publicToken = _data["publicToken"];
            this.syncAccountRef = _data["syncAccountRef"];
            this.isSyncBankAccountsEnabled = _data["isSyncBankAccountsEnabled"];
        }
    }

    static fromJS(data: any): CreateSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["publicToken"] = this.publicToken;
        data["syncAccountRef"] = this.syncAccountRef;
        data["isSyncBankAccountsEnabled"] = this.isSyncBankAccountsEnabled;
        return data;
    }
}

export interface ICreateSyncAccountInput {
    typeId: string;
    publicToken: string | undefined;
    syncAccountRef: string | undefined;
    isSyncBankAccountsEnabled: boolean;
}

export class CreateTenantInput implements ICreateTenantInput {
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    adminFirstName!: string | undefined;
    adminLastName!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    products!: TenantProductInfo[] | undefined;
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    crmConnectionString!: string | undefined;
    memberDbConnectionString!: string | undefined;
    cfoConnectionString!: string | undefined;
    azureConnectionString!: string | undefined;
    editions!: TenantEditEditionDto[] | undefined;
    isActive!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.adminFirstName = _data["adminFirstName"];
            this.adminLastName = _data["adminLastName"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(TenantProductInfo.fromJS(item));
            }
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.crmConnectionString = _data["crmConnectionString"];
            this.memberDbConnectionString = _data["memberDbConnectionString"];
            this.cfoConnectionString = _data["cfoConnectionString"];
            this.azureConnectionString = _data["azureConnectionString"];
            if (Array.isArray(_data["editions"])) {
                this.editions = [] as any;
                for (let item of _data["editions"])
                    this.editions!.push(TenantEditEditionDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["adminFirstName"] = this.adminFirstName;
        data["adminLastName"] = this.adminLastName;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["azureConnectionString"] = this.azureConnectionString;
        if (Array.isArray(this.editions)) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateTenantInput {
    adminEmailAddress: string;
    adminPassword: string | undefined;
    adminFirstName: string | undefined;
    adminLastName: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    products: TenantProductInfo[] | undefined;
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    crmConnectionString: string | undefined;
    memberDbConnectionString: string | undefined;
    cfoConnectionString: string | undefined;
    azureConnectionString: string | undefined;
    editions: TenantEditEditionDto[] | undefined;
    isActive: boolean;
}

export class CreateTransactionCommentThreadInput implements ICreateTransactionCommentThreadInput {
    transactionId!: number;
    comment!: string;

    constructor(data?: ICreateTransactionCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateTransactionCommentThreadInput {
    transactionId: number;
    comment: string;
}

export class CreateTransactionCommentThreadOutput implements ICreateTransactionCommentThreadOutput {
    readonly threadId!: number;
    id!: number;

    constructor(data?: ICreateTransactionCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).threadId = _data["threadId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateTransactionCommentThreadOutput {
    threadId: number;
    id: number;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: moment.Moment;
    endTime!: moment.Moment;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: moment.Moment;
    endTime: moment.Moment;
}

export class CreateUserForContactInput implements ICreateUserForContactInput {
    contactId!: number;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    changePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    generateAutoLoginLink!: boolean;
    assignedRoleNames!: string[] | undefined;
    organizationUnitIds!: number[] | undefined;

    constructor(data?: ICreateUserForContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.changePasswordOnNextLogin = _data["changePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.generateAutoLoginLink = _data["generateAutoLoginLink"];
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserForContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserForContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["changePasswordOnNextLogin"] = this.changePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["generateAutoLoginLink"] = this.generateAutoLoginLink;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        return data;
    }
}

export interface ICreateUserForContactInput {
    contactId: number;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    changePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    generateAutoLoginLink: boolean;
    assignedRoleNames: string[] | undefined;
    organizationUnitIds: number[] | undefined;
}

export class CreateUserForContactOutput implements ICreateUserForContactOutput {
    userId!: number;
    autoLoginLink!: string | undefined;

    constructor(data?: ICreateUserForContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.autoLoginLink = _data["autoLoginLink"];
        }
    }

    static fromJS(data: any): CreateUserForContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserForContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["autoLoginLink"] = this.autoLoginLink;
        return data;
    }
}

export interface ICreateUserForContactOutput {
    userId: number;
    autoLoginLink: string | undefined;
}

export class CreditBureauReportDto implements ICreditBureauReportDto {
    bureau!: Bureau;
    creditScore!: CreditScoreDto | undefined;
    creditSummary!: CreditSummaryDto | undefined;
    personalInfo!: PersonalInfoDto | undefined;
    inquiries!: InquiryDto[] | undefined;
    scoreFactors!: ScoreFactorDto[] | undefined;

    constructor(data?: ICreditBureauReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bureau = _data["bureau"];
            this.creditScore = _data["creditScore"] ? CreditScoreDto.fromJS(_data["creditScore"]) : <any>undefined;
            this.creditSummary = _data["creditSummary"] ? CreditSummaryDto.fromJS(_data["creditSummary"]) : <any>undefined;
            this.personalInfo = _data["personalInfo"] ? PersonalInfoDto.fromJS(_data["personalInfo"]) : <any>undefined;
            if (Array.isArray(_data["inquiries"])) {
                this.inquiries = [] as any;
                for (let item of _data["inquiries"])
                    this.inquiries!.push(InquiryDto.fromJS(item));
            }
            if (Array.isArray(_data["scoreFactors"])) {
                this.scoreFactors = [] as any;
                for (let item of _data["scoreFactors"])
                    this.scoreFactors!.push(ScoreFactorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditBureauReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditBureauReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["creditScore"] = this.creditScore ? this.creditScore.toJSON() : <any>undefined;
        data["creditSummary"] = this.creditSummary ? this.creditSummary.toJSON() : <any>undefined;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.inquiries)) {
            data["inquiries"] = [];
            for (let item of this.inquiries)
                data["inquiries"].push(item.toJSON());
        }
        if (Array.isArray(this.scoreFactors)) {
            data["scoreFactors"] = [];
            for (let item of this.scoreFactors)
                data["scoreFactors"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreditBureauReportDto {
    bureau: Bureau;
    creditScore: CreditScoreDto | undefined;
    creditSummary: CreditSummaryDto | undefined;
    personalInfo: PersonalInfoDto | undefined;
    inquiries: InquiryDto[] | undefined;
    scoreFactors: ScoreFactorDto[] | undefined;
}

export class CreditorContactDto implements ICreditorContactDto {
    name!: string | undefined;
    address!: AddressDto | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: ICreditorContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreditorContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditorContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ICreditorContactDto {
    name: string | undefined;
    address: AddressDto | undefined;
    phoneNumber: string | undefined;
}

export class CreditReportDto implements ICreditReportDto {
    creditReportId!: number;
    minScoreValue!: number;
    maxScoreValue!: number;
    bureauReports!: CreditBureauReportDto[] | undefined;
    accounts!: AccountDto[] | undefined;
    alerts!: AlertDto[] | undefined;
    recommendations!: RecommendationDto[] | undefined;
    creditorContacts!: CreditorContactDto[] | undefined;
    consumerStatements!: ConsumerStatementDto[] | undefined;
    publicInformation!: PublicRecordDto[] | undefined;

    constructor(data?: ICreditReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creditReportId = _data["creditReportId"];
            this.minScoreValue = _data["minScoreValue"];
            this.maxScoreValue = _data["maxScoreValue"];
            if (Array.isArray(_data["bureauReports"])) {
                this.bureauReports = [] as any;
                for (let item of _data["bureauReports"])
                    this.bureauReports!.push(CreditBureauReportDto.fromJS(item));
            }
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(AccountDto.fromJS(item));
            }
            if (Array.isArray(_data["alerts"])) {
                this.alerts = [] as any;
                for (let item of _data["alerts"])
                    this.alerts!.push(AlertDto.fromJS(item));
            }
            if (Array.isArray(_data["recommendations"])) {
                this.recommendations = [] as any;
                for (let item of _data["recommendations"])
                    this.recommendations!.push(RecommendationDto.fromJS(item));
            }
            if (Array.isArray(_data["creditorContacts"])) {
                this.creditorContacts = [] as any;
                for (let item of _data["creditorContacts"])
                    this.creditorContacts!.push(CreditorContactDto.fromJS(item));
            }
            if (Array.isArray(_data["consumerStatements"])) {
                this.consumerStatements = [] as any;
                for (let item of _data["consumerStatements"])
                    this.consumerStatements!.push(ConsumerStatementDto.fromJS(item));
            }
            if (Array.isArray(_data["publicInformation"])) {
                this.publicInformation = [] as any;
                for (let item of _data["publicInformation"])
                    this.publicInformation!.push(PublicRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditReportId"] = this.creditReportId;
        data["minScoreValue"] = this.minScoreValue;
        data["maxScoreValue"] = this.maxScoreValue;
        if (Array.isArray(this.bureauReports)) {
            data["bureauReports"] = [];
            for (let item of this.bureauReports)
                data["bureauReports"].push(item.toJSON());
        }
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        if (Array.isArray(this.alerts)) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendations)) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item.toJSON());
        }
        if (Array.isArray(this.creditorContacts)) {
            data["creditorContacts"] = [];
            for (let item of this.creditorContacts)
                data["creditorContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.consumerStatements)) {
            data["consumerStatements"] = [];
            for (let item of this.consumerStatements)
                data["consumerStatements"].push(item.toJSON());
        }
        if (Array.isArray(this.publicInformation)) {
            data["publicInformation"] = [];
            for (let item of this.publicInformation)
                data["publicInformation"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreditReportDto {
    creditReportId: number;
    minScoreValue: number;
    maxScoreValue: number;
    bureauReports: CreditBureauReportDto[] | undefined;
    accounts: AccountDto[] | undefined;
    alerts: AlertDto[] | undefined;
    recommendations: RecommendationDto[] | undefined;
    creditorContacts: CreditorContactDto[] | undefined;
    consumerStatements: ConsumerStatementDto[] | undefined;
    publicInformation: PublicRecordDto[] | undefined;
}

export class CreditReportOutput implements ICreditReportOutput {
    memberExists!: boolean;
    uncompletedPackageId!: number | undefined;
    kbaPassed!: boolean | undefined;
    creditReport!: CreditReportDto | undefined;
    readonly updatable!: boolean;
    isPaymentDelayed!: boolean;
    isSubscriptionCancelled!: boolean;
    previousReportExists!: boolean;
    refreshErrorMessage!: string | undefined;
    memberFullName!: string | undefined;
    providerCreatedDate!: moment.Moment | undefined;

    constructor(data?: ICreditReportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberExists = _data["memberExists"];
            this.uncompletedPackageId = _data["uncompletedPackageId"];
            this.kbaPassed = _data["kbaPassed"];
            this.creditReport = _data["creditReport"] ? CreditReportDto.fromJS(_data["creditReport"]) : <any>undefined;
            (<any>this).updatable = _data["updatable"];
            this.isPaymentDelayed = _data["isPaymentDelayed"];
            this.isSubscriptionCancelled = _data["isSubscriptionCancelled"];
            this.previousReportExists = _data["previousReportExists"];
            this.refreshErrorMessage = _data["refreshErrorMessage"];
            this.memberFullName = _data["memberFullName"];
            this.providerCreatedDate = _data["providerCreatedDate"] ? moment(_data["providerCreatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreditReportOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberExists"] = this.memberExists;
        data["uncompletedPackageId"] = this.uncompletedPackageId;
        data["kbaPassed"] = this.kbaPassed;
        data["creditReport"] = this.creditReport ? this.creditReport.toJSON() : <any>undefined;
        data["updatable"] = this.updatable;
        data["isPaymentDelayed"] = this.isPaymentDelayed;
        data["isSubscriptionCancelled"] = this.isSubscriptionCancelled;
        data["previousReportExists"] = this.previousReportExists;
        data["refreshErrorMessage"] = this.refreshErrorMessage;
        data["memberFullName"] = this.memberFullName;
        data["providerCreatedDate"] = this.providerCreatedDate ? this.providerCreatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreditReportOutput {
    memberExists: boolean;
    uncompletedPackageId: number | undefined;
    kbaPassed: boolean | undefined;
    creditReport: CreditReportDto | undefined;
    updatable: boolean;
    isPaymentDelayed: boolean;
    isSubscriptionCancelled: boolean;
    previousReportExists: boolean;
    refreshErrorMessage: string | undefined;
    memberFullName: string | undefined;
    providerCreatedDate: moment.Moment | undefined;
}

export class CreditScoreDto implements ICreditScoreDto {
    score!: number;
    readonly scoreRank!: CreditScoreRank;
    populationRank!: number | undefined;
    qualitativeRank!: number | undefined;
    scoreDate!: moment.Moment | undefined;
    nextUpdate!: number;

    constructor(data?: ICreditScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data["score"];
            (<any>this).scoreRank = _data["scoreRank"];
            this.populationRank = _data["populationRank"];
            this.qualitativeRank = _data["qualitativeRank"];
            this.scoreDate = _data["scoreDate"] ? moment(_data["scoreDate"].toString()) : <any>undefined;
            this.nextUpdate = _data["nextUpdate"];
        }
    }

    static fromJS(data: any): CreditScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["scoreRank"] = this.scoreRank;
        data["populationRank"] = this.populationRank;
        data["qualitativeRank"] = this.qualitativeRank;
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["nextUpdate"] = this.nextUpdate;
        return data;
    }
}

export interface ICreditScoreDto {
    score: number;
    scoreRank: CreditScoreRank;
    populationRank: number | undefined;
    qualitativeRank: number | undefined;
    scoreDate: moment.Moment | undefined;
    nextUpdate: number;
}

export enum CreditScoreRank {
    Poor = "Poor",
    Fair = "Fair",
    Good = "Good",
    Excellent = "Excellent",
}

export enum CreditScoreRating {
    NotSure = "NotSure",
    Excellent = "Excellent",
    Good = "Good",
    Fair = "Fair",
    Poor = "Poor",
}

export class CreditSummaryDto implements ICreditSummaryDto {
    totalAccounts!: number;
    openAccounts!: number;
    closedAccounts!: number;
    deliquent!: number;
    derogatory!: number;
    balances!: number;
    payments!: number;
    publicRecords!: number;
    inquiries2Years!: number;

    constructor(data?: ICreditSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalAccounts = _data["totalAccounts"];
            this.openAccounts = _data["openAccounts"];
            this.closedAccounts = _data["closedAccounts"];
            this.deliquent = _data["deliquent"];
            this.derogatory = _data["derogatory"];
            this.balances = _data["balances"];
            this.payments = _data["payments"];
            this.publicRecords = _data["publicRecords"];
            this.inquiries2Years = _data["inquiries2Years"];
        }
    }

    static fromJS(data: any): CreditSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAccounts"] = this.totalAccounts;
        data["openAccounts"] = this.openAccounts;
        data["closedAccounts"] = this.closedAccounts;
        data["deliquent"] = this.deliquent;
        data["derogatory"] = this.derogatory;
        data["balances"] = this.balances;
        data["payments"] = this.payments;
        data["publicRecords"] = this.publicRecords;
        data["inquiries2Years"] = this.inquiries2Years;
        return data;
    }
}

export interface ICreditSummaryDto {
    totalAccounts: number;
    openAccounts: number;
    closedAccounts: number;
    deliquent: number;
    derogatory: number;
    balances: number;
    payments: number;
    publicRecords: number;
    inquiries2Years: number;
}

export enum Currency {
    USD = "USD",
    CAD = "CAD",
    EUR = "EUR",
    GBP = "GBP",
    AUD = "AUD",
    NZD = "NZD",
    SGD = "SGD",
    HKD = "HKD",
    UAH = "UAH",
    INR = "INR",
    JPY = "JPY",
    ILS = "ILS",
    CHF = "CHF",
    MXN = "MXN",
    RUB = "RUB",
    BTC = "BTC",
}

export class CurrencyInfo implements ICurrencyInfo {
    id!: string | undefined;
    name!: string | undefined;
    symbol!: string | undefined;

    constructor(data?: ICurrencyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): CurrencyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        return data;
    }
}

export interface ICurrencyInfo {
    id: string | undefined;
    name: string | undefined;
    symbol: string | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    companyName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.companyName = _data["companyName"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["companyName"] = this.companyName;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    companyName: string | undefined;
    countryId: string | undefined;
}

export enum CustomCssType {
    Platform = "Platform",
    Login = "Login",
    Portal = "Portal",
}

export enum CustomerAccountingType {
    Checking = 0,
    Saving = 1,
}

export class CustomFieldsInput implements ICustomFieldsInput {
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;

    constructor(data?: ICustomFieldsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customField1 = _data["customField1"];
            this.customField2 = _data["customField2"];
            this.customField3 = _data["customField3"];
            this.customField4 = _data["customField4"];
            this.customField5 = _data["customField5"];
        }
    }

    static fromJS(data: any): CustomFieldsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        return data;
    }
}

export interface ICustomFieldsInput {
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
}

export class CustomWelcomeTemplate implements ICustomWelcomeTemplate {
    groupId!: string | undefined;
    templateId!: number | undefined;

    constructor(data?: ICustomWelcomeTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
        }
    }

    static fromJS(data: any): CustomWelcomeTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomWelcomeTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        return data;
    }
}

export interface ICustomWelcomeTemplate {
    groupId: string | undefined;
    templateId: number | undefined;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DebtInformation implements IDebtInformation {
    debtAmount!: number | undefined;
    creditCardDebtAmount!: number | undefined;
    studentDebtAmount!: number | undefined;

    constructor(data?: IDebtInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debtAmount = _data["debtAmount"];
            this.creditCardDebtAmount = _data["creditCardDebtAmount"];
            this.studentDebtAmount = _data["studentDebtAmount"];
        }
    }

    static fromJS(data: any): DebtInformation {
        data = typeof data === 'object' ? data : {};
        let result = new DebtInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtAmount"] = this.debtAmount;
        data["creditCardDebtAmount"] = this.creditCardDebtAmount;
        data["studentDebtAmount"] = this.studentDebtAmount;
        return data;
    }
}

export interface IDebtInformation {
    debtAmount: number | undefined;
    creditCardDebtAmount: number | undefined;
    studentDebtAmount: number | undefined;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDelegationId"] = this.userDelegationId;
        return data;
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;
}

export enum DIOSVertical {
    Undefined = "Undefined",
    PersonalLoans = "PersonalLoans",
    Beauty = "Beauty",
    Auto = "Auto",
    Legal = "Legal",
    CreditRepair = "CreditRepair",
    CreditScore = "CreditScore",
    Travel = "Travel",
    Jobs = "Jobs",
    BusinessLoans = "BusinessLoans",
    HybridLoans = "HybridLoans",
    DebtConsolidation = "DebtConsolidation",
    CreditCards = "CreditCards",
    MerchantServices = "MerchantServices",
    Dating = "Dating",
    Crypto = "Crypto",
    CreditMonitoring = "CreditMonitoring",
}

export class DiscardDiscrepanciesInput implements IDiscardDiscrepanciesInput {
    bankIds!: number[] | undefined;
    bankAccountIds!: number[] | undefined;
    currencyId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;

    constructor(data?: IDiscardDiscrepanciesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bankIds"])) {
                this.bankIds = [] as any;
                for (let item of _data["bankIds"])
                    this.bankIds!.push(item);
            }
            if (Array.isArray(_data["bankAccountIds"])) {
                this.bankAccountIds = [] as any;
                for (let item of _data["bankAccountIds"])
                    this.bankAccountIds!.push(item);
            }
            this.currencyId = _data["currencyId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscardDiscrepanciesInput {
        data = typeof data === 'object' ? data : {};
        let result = new DiscardDiscrepanciesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bankIds)) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (Array.isArray(this.bankAccountIds)) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["currencyId"] = this.currencyId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDiscardDiscrepanciesInput {
    bankIds: number[] | undefined;
    bankAccountIds: number[] | undefined;
    currencyId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
}

export class DocumentInfo implements IDocumentInfo {
    id!: string;
    typeId!: number | undefined;
    typeName!: string | undefined;
    fileId!: string;
    fileName!: string | undefined;
    size!: string | undefined;
    creationTime!: moment.Moment;
    isViewSupportedByWopi!: boolean;
    isEditSupportedByWopi!: boolean;

    constructor(data?: IDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.typeName = _data["typeName"];
            this.fileId = _data["fileId"];
            this.fileName = _data["fileName"];
            this.size = _data["size"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isViewSupportedByWopi = _data["isViewSupportedByWopi"];
            this.isEditSupportedByWopi = _data["isEditSupportedByWopi"];
        }
    }

    static fromJS(data: any): DocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["fileId"] = this.fileId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isViewSupportedByWopi"] = this.isViewSupportedByWopi;
        data["isEditSupportedByWopi"] = this.isEditSupportedByWopi;
        return data;
    }
}

export interface IDocumentInfo {
    id: string;
    typeId: number | undefined;
    typeName: string | undefined;
    fileId: string;
    fileName: string | undefined;
    size: string | undefined;
    creationTime: moment.Moment;
    isViewSupportedByWopi: boolean;
    isEditSupportedByWopi: boolean;
}

export class DocumentTypeInfo implements IDocumentTypeInfo {
    id!: number;
    name!: string | undefined;

    constructor(data?: IDocumentTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DocumentTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDocumentTypeInfo {
    id: number;
    name: string | undefined;
}

export class DownloadPictureInput implements IDownloadPictureInput {
    url!: string;

    constructor(data?: IDownloadPictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): DownloadPictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadPictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface IDownloadPictureInput {
    url: string;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    creationTime!: moment.Moment;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    module!: ModuleType | undefined;
    packageName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.module = _data["module"];
            this.packageName = _data["packageName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["module"] = this.module;
        data["packageName"] = this.packageName;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    module: ModuleType | undefined;
    packageName: string | undefined;
    id: number;
}

export class EditRuleDto implements IEditRuleDto {
    id!: number;
    name!: string;
    categoryId!: number;
    transactionDescriptor!: string | undefined;
    transactionDescriptorAttributeTypeId!: string | undefined;
    condition!: ConditionDto;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption;

    constructor(data?: IEditRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.condition = new ConditionDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = _data["transactionDescriptorAttributeTypeId"];
            this.condition = _data["condition"] ? ConditionDto.fromJS(_data["condition"]) : new ConditionDto();
            if (Array.isArray(_data["sourceTransactionList"])) {
                this.sourceTransactionList = [] as any;
                for (let item of _data["sourceTransactionList"])
                    this.sourceTransactionList!.push(item);
            }
            this.applyOption = _data["applyOption"];
        }
    }

    static fromJS(data: any): EditRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (Array.isArray(this.sourceTransactionList)) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data;
    }
}

export interface IEditRuleDto {
    id: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string | undefined;
    transactionDescriptorAttributeTypeId: string | undefined;
    condition: ConditionDto;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption;
}

export class EditWorkflowRuleDto implements IEditWorkflowRuleDto {
    id!: number;
    triggerIdentifier!: string;
    actionIdentifier!: string;
    configurationOptions!: string;
    isActive!: boolean;

    constructor(data?: IEditWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.triggerIdentifier = _data["triggerIdentifier"];
            this.actionIdentifier = _data["actionIdentifier"];
            this.configurationOptions = _data["configurationOptions"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EditWorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditWorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IEditWorkflowRuleDto {
    id: number;
    triggerIdentifier: string;
    actionIdentifier: string;
    configurationOptions: string;
    isActive: boolean;
}

export class EmailFromInfo implements IEmailFromInfo {
    emailSettingsSource!: EmailSettingsSource;
    emailAddress!: string | undefined;
    ccEmailAddress!: string | undefined;

    constructor(data?: IEmailFromInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailSettingsSource = _data["emailSettingsSource"];
            this.emailAddress = _data["emailAddress"];
            this.ccEmailAddress = _data["ccEmailAddress"];
        }
    }

    static fromJS(data: any): EmailFromInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EmailFromInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailSettingsSource"] = this.emailSettingsSource;
        data["emailAddress"] = this.emailAddress;
        data["ccEmailAddress"] = this.ccEmailAddress;
        return data;
    }
}

export interface IEmailFromInfo {
    emailSettingsSource: EmailSettingsSource;
    emailAddress: string | undefined;
    ccEmailAddress: string | undefined;
}

export class EmailFromSettings implements IEmailFromSettings {
    emailAddress!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IEmailFromSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmailFromSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailFromSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmailFromSettings {
    emailAddress: string | undefined;
    displayName: string | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultReplyTo!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpEnableSsl!: boolean;
    smtpDomain!: string | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    isImapEnabled!: boolean;
    imapHost!: string | undefined;
    imapPort!: number | undefined;
    imapUseSsl!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultReplyTo = _data["defaultReplyTo"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.isImapEnabled = _data["isImapEnabled"];
            this.imapHost = _data["imapHost"];
            this.imapPort = _data["imapPort"];
            this.imapUseSsl = _data["imapUseSsl"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultReplyTo"] = this.defaultReplyTo;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["isImapEnabled"] = this.isImapEnabled;
        data["imapHost"] = this.imapHost;
        data["imapPort"] = this.imapPort;
        data["imapUseSsl"] = this.imapUseSsl;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IEmailSettingsEditDto {
    defaultReplyTo: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpEnableSsl: boolean;
    smtpDomain: string | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    isImapEnabled: boolean;
    imapHost: string | undefined;
    imapPort: number | undefined;
    imapUseSsl: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
}

export enum EmailSettingsSource {
    Tenant = "Tenant",
    User = "User",
    External = "External",
}

export class EmailSmtpSettings implements IEmailSmtpSettings {
    host!: string | undefined;
    port!: number | undefined;
    enableSsl!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: IEmailSmtpSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
            this.enableSsl = _data["enableSsl"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): EmailSmtpSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSmtpSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        data["enableSsl"] = this.enableSsl;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IEmailSmtpSettings {
    host: string | undefined;
    port: number | undefined;
    enableSsl: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export enum EmailTemplateType {
    Invoice = "Invoice",
    Contact = "Contact",
    WelcomeEmail = "WelcomeEmail",
}

export class EmailUsageTypeDto implements IEmailUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean;

    constructor(data?: IEmailUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isCompany = _data["isCompany"];
        }
    }

    static fromJS(data: any): EmailUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data;
    }
}

export interface IEmailUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean;
}

export class EmployerDto implements IEmployerDto {
    name!: string | undefined;
    date!: moment.Moment | undefined;
    type!: string | undefined;

    constructor(data?: IEmployerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): EmployerDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IEmployerDto {
    name: string | undefined;
    date: moment.Moment | undefined;
    type: string | undefined;
}

export class EmploymentInformation implements IEmploymentInformation {
    isEmployed!: boolean | undefined;
    employerName!: string | undefined;
    jobTitle!: string | undefined;
    monthsAtEmployer!: number | undefined;
    phoneWork!: string | undefined;
    phoneWorkExtension!: string | undefined;
    employerAddress1!: string | undefined;
    employerCity!: string | undefined;
    employerStateCode!: string | undefined;
    employerPostalCode!: string | undefined;
    netMonthlyIncome!: number | undefined;
    payFrequency!: PayFrequency | undefined;
    payNextDate!: moment.Moment | undefined;
    payAfterNextDate!: moment.Moment | undefined;
    incomeType!: IncomeType | undefined;

    constructor(data?: IEmploymentInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmployed = _data["isEmployed"];
            this.employerName = _data["employerName"];
            this.jobTitle = _data["jobTitle"];
            this.monthsAtEmployer = _data["monthsAtEmployer"];
            this.phoneWork = _data["phoneWork"];
            this.phoneWorkExtension = _data["phoneWorkExtension"];
            this.employerAddress1 = _data["employerAddress1"];
            this.employerCity = _data["employerCity"];
            this.employerStateCode = _data["employerStateCode"];
            this.employerPostalCode = _data["employerPostalCode"];
            this.netMonthlyIncome = _data["netMonthlyIncome"];
            this.payFrequency = _data["payFrequency"];
            this.payNextDate = _data["payNextDate"] ? moment(_data["payNextDate"].toString()) : <any>undefined;
            this.payAfterNextDate = _data["payAfterNextDate"] ? moment(_data["payAfterNextDate"].toString()) : <any>undefined;
            this.incomeType = _data["incomeType"];
        }
    }

    static fromJS(data: any): EmploymentInformation {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmployed"] = this.isEmployed;
        data["employerName"] = this.employerName;
        data["jobTitle"] = this.jobTitle;
        data["monthsAtEmployer"] = this.monthsAtEmployer;
        data["phoneWork"] = this.phoneWork;
        data["phoneWorkExtension"] = this.phoneWorkExtension;
        data["employerAddress1"] = this.employerAddress1;
        data["employerCity"] = this.employerCity;
        data["employerStateCode"] = this.employerStateCode;
        data["employerPostalCode"] = this.employerPostalCode;
        data["netMonthlyIncome"] = this.netMonthlyIncome;
        data["payFrequency"] = this.payFrequency;
        data["payNextDate"] = this.payNextDate ? this.payNextDate.toISOString() : <any>undefined;
        data["payAfterNextDate"] = this.payAfterNextDate ? this.payAfterNextDate.toISOString() : <any>undefined;
        data["incomeType"] = this.incomeType;
        return data;
    }
}

export interface IEmploymentInformation {
    isEmployed: boolean | undefined;
    employerName: string | undefined;
    jobTitle: string | undefined;
    monthsAtEmployer: number | undefined;
    phoneWork: string | undefined;
    phoneWorkExtension: string | undefined;
    employerAddress1: string | undefined;
    employerCity: string | undefined;
    employerStateCode: string | undefined;
    employerPostalCode: string | undefined;
    netMonthlyIncome: number | undefined;
    payFrequency: PayFrequency | undefined;
    payNextDate: moment.Moment | undefined;
    payAfterNextDate: moment.Moment | undefined;
    incomeType: IncomeType | undefined;
}

export class EmploymentInformationExtended implements IEmploymentInformationExtended {
    employerAddress2!: string | undefined;
    isEmployed!: boolean | undefined;
    employerName!: string | undefined;
    jobTitle!: string | undefined;
    monthsAtEmployer!: number | undefined;
    phoneWork!: string | undefined;
    phoneWorkExtension!: string | undefined;
    employerAddress1!: string | undefined;
    employerCity!: string | undefined;
    employerStateCode!: string | undefined;
    employerPostalCode!: string | undefined;
    netMonthlyIncome!: number | undefined;
    payFrequency!: PayFrequency | undefined;
    payNextDate!: moment.Moment | undefined;
    payAfterNextDate!: moment.Moment | undefined;
    incomeType!: IncomeType | undefined;

    constructor(data?: IEmploymentInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employerAddress2 = _data["employerAddress2"];
            this.isEmployed = _data["isEmployed"];
            this.employerName = _data["employerName"];
            this.jobTitle = _data["jobTitle"];
            this.monthsAtEmployer = _data["monthsAtEmployer"];
            this.phoneWork = _data["phoneWork"];
            this.phoneWorkExtension = _data["phoneWorkExtension"];
            this.employerAddress1 = _data["employerAddress1"];
            this.employerCity = _data["employerCity"];
            this.employerStateCode = _data["employerStateCode"];
            this.employerPostalCode = _data["employerPostalCode"];
            this.netMonthlyIncome = _data["netMonthlyIncome"];
            this.payFrequency = _data["payFrequency"];
            this.payNextDate = _data["payNextDate"] ? moment(_data["payNextDate"].toString()) : <any>undefined;
            this.payAfterNextDate = _data["payAfterNextDate"] ? moment(_data["payAfterNextDate"].toString()) : <any>undefined;
            this.incomeType = _data["incomeType"];
        }
    }

    static fromJS(data: any): EmploymentInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employerAddress2"] = this.employerAddress2;
        data["isEmployed"] = this.isEmployed;
        data["employerName"] = this.employerName;
        data["jobTitle"] = this.jobTitle;
        data["monthsAtEmployer"] = this.monthsAtEmployer;
        data["phoneWork"] = this.phoneWork;
        data["phoneWorkExtension"] = this.phoneWorkExtension;
        data["employerAddress1"] = this.employerAddress1;
        data["employerCity"] = this.employerCity;
        data["employerStateCode"] = this.employerStateCode;
        data["employerPostalCode"] = this.employerPostalCode;
        data["netMonthlyIncome"] = this.netMonthlyIncome;
        data["payFrequency"] = this.payFrequency;
        data["payNextDate"] = this.payNextDate ? this.payNextDate.toISOString() : <any>undefined;
        data["payAfterNextDate"] = this.payAfterNextDate ? this.payAfterNextDate.toISOString() : <any>undefined;
        data["incomeType"] = this.incomeType;
        return data;
    }
}

export interface IEmploymentInformationExtended {
    employerAddress2: string | undefined;
    isEmployed: boolean | undefined;
    employerName: string | undefined;
    jobTitle: string | undefined;
    monthsAtEmployer: number | undefined;
    phoneWork: string | undefined;
    phoneWorkExtension: string | undefined;
    employerAddress1: string | undefined;
    employerCity: string | undefined;
    employerStateCode: string | undefined;
    employerPostalCode: string | undefined;
    netMonthlyIncome: number | undefined;
    payFrequency: PayFrequency | undefined;
    payNextDate: moment.Moment | undefined;
    payAfterNextDate: moment.Moment | undefined;
    incomeType: IncomeType | undefined;
}

export class EntityAddressInfo implements IEntityAddressInfo {
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    country!: string | undefined;
    zip!: string | undefined;

    constructor(data?: IEntityAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.country = _data["country"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): EntityAddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["country"] = this.country;
        data["zip"] = this.zip;
        return data;
    }
}

export interface IEntityAddressInfo {
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    country: string | undefined;
    zip: string | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? moment(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityContactInfo implements IEntityContactInfo {
    id!: number;
    name!: string | undefined;
    email!: string | undefined;
    userId!: number | undefined;
    address!: EntityAddressInfo | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IEntityContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.userId = _data["userId"];
            this.address = _data["address"] ? EntityAddressInfo.fromJS(_data["address"]) : <any>undefined;
            this.photoPublicId = _data["photoPublicId"];
        }
    }

    static fromJS(data: any): EntityContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntityContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["userId"] = this.userId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["photoPublicId"] = this.photoPublicId;
        return data;
    }
}

export interface IEntityContactInfo {
    id: number;
    name: string | undefined;
    email: string | undefined;
    userId: number | undefined;
    address: EntityAddressInfo | undefined;
    photoPublicId: string | undefined;
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDto {
    id: number;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class EPCVIPMailerSettingsEditDto implements IEPCVIPMailerSettingsEditDto {
    baseUrl!: string | undefined;
    apiKey!: string | undefined;
    server!: EPCVIPServer | undefined;

    constructor(data?: IEPCVIPMailerSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.apiKey = _data["apiKey"];
            this.server = _data["server"];
        }
    }

    static fromJS(data: any): EPCVIPMailerSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EPCVIPMailerSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["apiKey"] = this.apiKey;
        data["server"] = this.server;
        return data;
    }
}

export interface IEPCVIPMailerSettingsEditDto {
    baseUrl: string | undefined;
    apiKey: string | undefined;
    server: EPCVIPServer | undefined;
}

export class EPCVIPOfferProviderSettings implements IEPCVIPOfferProviderSettings {
    apiKey!: string | undefined;

    constructor(data?: IEPCVIPOfferProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): EPCVIPOfferProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EPCVIPOfferProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IEPCVIPOfferProviderSettings {
    apiKey: string | undefined;
}

export enum EPCVIPServer {
    AmazonSES = "AmazonSES",
    Mailgun = "Mailgun",
    SendGrid = "SendGrid",
    SparkPost = "SparkPost",
}

export class EventJobExecutionDto implements IEventJobExecutionDto {
    id!: number;
    creationTime!: moment.Moment;
    requestBody!: string | undefined;
    responseStatus!: string | undefined;
    httpStatusCode!: number;
    httpStatusName!: string | undefined;
    responseContent!: string | undefined;
    responseErrorMessage!: string | undefined;

    constructor(data?: IEventJobExecutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.requestBody = _data["requestBody"];
            this.responseStatus = _data["responseStatus"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.httpStatusName = _data["httpStatusName"];
            this.responseContent = _data["responseContent"];
            this.responseErrorMessage = _data["responseErrorMessage"];
        }
    }

    static fromJS(data: any): EventJobExecutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventJobExecutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["requestBody"] = this.requestBody;
        data["responseStatus"] = this.responseStatus;
        data["httpStatusCode"] = this.httpStatusCode;
        data["httpStatusName"] = this.httpStatusName;
        data["responseContent"] = this.responseContent;
        data["responseErrorMessage"] = this.responseErrorMessage;
        return data;
    }
}

export interface IEventJobExecutionDto {
    id: number;
    creationTime: moment.Moment;
    requestBody: string | undefined;
    responseStatus: string | undefined;
    httpStatusCode: number;
    httpStatusName: string | undefined;
    responseContent: string | undefined;
    responseErrorMessage: string | undefined;
}

export class EventSubscriptionDto implements IEventSubscriptionDto {
    id!: number;
    appEvent!: string | undefined;
    targetUrl!: string | undefined;
    creatorUserId!: number;
    creatorUserName!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IEventSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appEvent = _data["appEvent"];
            this.targetUrl = _data["targetUrl"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appEvent"] = this.appEvent;
        data["targetUrl"] = this.targetUrl;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEventSubscriptionDto {
    id: number;
    appEvent: string | undefined;
    targetUrl: string | undefined;
    creatorUserId: number;
    creatorUserName: string | undefined;
    creationTime: moment.Moment;
}

export enum ExitStrategy {
    Airbnb = "Airbnb",
    Flip = "Flip",
    JV = "JV",
    LTR = "LTR",
    RTO = "RTO",
    STR = "STR",
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class ExtendFromCSVOutput implements IExtendFromCSVOutput {
    notMatchedUrls!: string[] | undefined;

    constructor(data?: IExtendFromCSVOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notMatchedUrls"])) {
                this.notMatchedUrls = [] as any;
                for (let item of _data["notMatchedUrls"])
                    this.notMatchedUrls!.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendFromCSVOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendFromCSVOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notMatchedUrls)) {
            data["notMatchedUrls"] = [];
            for (let item of this.notMatchedUrls)
                data["notMatchedUrls"].push(item);
        }
        return data;
    }
}

export interface IExtendFromCSVOutput {
    notMatchedUrls: string[] | undefined;
}

export class ExtendOfferDto implements IExtendOfferDto {
    customName!: string | undefined;
    subId!: string | undefined;
    isPublished!: boolean | undefined;
    overallRating!: number | undefined;
    interestRating!: number | undefined;
    feesRating!: number | undefined;
    benefitsRating!: number | undefined;
    rewardsRating!: number | undefined;
    serviceRating!: number | undefined;
    cardNetwork!: CardNetwork | undefined;
    cardType!: CardType | undefined;
    targetAudience!: TargetAudience | undefined;
    securingType!: SecuringType | undefined;
    regularAPR!: string | undefined;
    introAPR!: string | undefined;
    balanceTransferFee!: string | undefined;
    annualFee!: string | undefined;
    monthlyFee!: string | undefined;
    activationFee!: string | undefined;
    introRewardsBonus!: string | undefined;
    rewardsRate!: string | undefined;
    durationForZeroPercentagePurchasesInMonths!: number | undefined;
    zeroPercentageInterestTransfers!: string | undefined;
    durationForZeroPercentageTransfersInMonths!: number | undefined;
    issuingBank!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    details!: string[] | undefined;
    pros!: string[] | undefined;
    cons!: string[] | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    minLoanTermMonths!: number | undefined;
    maxLoanTermMonths!: number | undefined;
    minAnnualIncome!: number | undefined;
    maxAnnualIncome!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    parameterHandlerType!: ParameterHandlerType | undefined;
    flags!: Flags | undefined;
    creditScores!: CreditScoreRating[] | undefined;
    states!: string[] | undefined;

    constructor(data?: IExtendOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customName = _data["customName"];
            this.subId = _data["subId"];
            this.isPublished = _data["isPublished"];
            this.overallRating = _data["overallRating"];
            this.interestRating = _data["interestRating"];
            this.feesRating = _data["feesRating"];
            this.benefitsRating = _data["benefitsRating"];
            this.rewardsRating = _data["rewardsRating"];
            this.serviceRating = _data["serviceRating"];
            this.cardNetwork = _data["cardNetwork"];
            this.cardType = _data["cardType"];
            this.targetAudience = _data["targetAudience"];
            this.securingType = _data["securingType"];
            this.regularAPR = _data["regularAPR"];
            this.introAPR = _data["introAPR"];
            this.balanceTransferFee = _data["balanceTransferFee"];
            this.annualFee = _data["annualFee"];
            this.monthlyFee = _data["monthlyFee"];
            this.activationFee = _data["activationFee"];
            this.introRewardsBonus = _data["introRewardsBonus"];
            this.rewardsRate = _data["rewardsRate"];
            this.durationForZeroPercentagePurchasesInMonths = _data["durationForZeroPercentagePurchasesInMonths"];
            this.zeroPercentageInterestTransfers = _data["zeroPercentageInterestTransfers"];
            this.durationForZeroPercentageTransfersInMonths = _data["durationForZeroPercentageTransfersInMonths"];
            this.issuingBank = _data["issuingBank"];
            this.offerCollection = _data["offerCollection"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(item);
            }
            if (Array.isArray(_data["pros"])) {
                this.pros = [] as any;
                for (let item of _data["pros"])
                    this.pros!.push(item);
            }
            if (Array.isArray(_data["cons"])) {
                this.cons = [] as any;
                for (let item of _data["cons"])
                    this.cons!.push(item);
            }
            this.minLoanAmount = _data["minLoanAmount"];
            this.maxLoanAmount = _data["maxLoanAmount"];
            this.minLoanTermMonths = _data["minLoanTermMonths"];
            this.maxLoanTermMonths = _data["maxLoanTermMonths"];
            this.minAnnualIncome = _data["minAnnualIncome"];
            this.maxAnnualIncome = _data["maxAnnualIncome"];
            this.campaignProviderType = _data["campaignProviderType"];
            this.parameterHandlerType = _data["parameterHandlerType"];
            this.flags = _data["flags"] ? Flags.fromJS(_data["flags"]) : <any>undefined;
            if (Array.isArray(_data["creditScores"])) {
                this.creditScores = [] as any;
                for (let item of _data["creditScores"])
                    this.creditScores!.push(item);
            }
            if (Array.isArray(_data["states"])) {
                this.states = [] as any;
                for (let item of _data["states"])
                    this.states!.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customName"] = this.customName;
        data["subId"] = this.subId;
        data["isPublished"] = this.isPublished;
        data["overallRating"] = this.overallRating;
        data["interestRating"] = this.interestRating;
        data["feesRating"] = this.feesRating;
        data["benefitsRating"] = this.benefitsRating;
        data["rewardsRating"] = this.rewardsRating;
        data["serviceRating"] = this.serviceRating;
        data["cardNetwork"] = this.cardNetwork;
        data["cardType"] = this.cardType;
        data["targetAudience"] = this.targetAudience;
        data["securingType"] = this.securingType;
        data["regularAPR"] = this.regularAPR;
        data["introAPR"] = this.introAPR;
        data["balanceTransferFee"] = this.balanceTransferFee;
        data["annualFee"] = this.annualFee;
        data["monthlyFee"] = this.monthlyFee;
        data["activationFee"] = this.activationFee;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["rewardsRate"] = this.rewardsRate;
        data["durationForZeroPercentagePurchasesInMonths"] = this.durationForZeroPercentagePurchasesInMonths;
        data["zeroPercentageInterestTransfers"] = this.zeroPercentageInterestTransfers;
        data["durationForZeroPercentageTransfersInMonths"] = this.durationForZeroPercentageTransfersInMonths;
        data["issuingBank"] = this.issuingBank;
        data["offerCollection"] = this.offerCollection;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        if (Array.isArray(this.pros)) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (Array.isArray(this.cons)) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["minLoanTermMonths"] = this.minLoanTermMonths;
        data["maxLoanTermMonths"] = this.maxLoanTermMonths;
        data["minAnnualIncome"] = this.minAnnualIncome;
        data["maxAnnualIncome"] = this.maxAnnualIncome;
        data["campaignProviderType"] = this.campaignProviderType;
        data["parameterHandlerType"] = this.parameterHandlerType;
        data["flags"] = this.flags ? this.flags.toJSON() : <any>undefined;
        if (Array.isArray(this.creditScores)) {
            data["creditScores"] = [];
            for (let item of this.creditScores)
                data["creditScores"].push(item);
        }
        if (Array.isArray(this.states)) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item);
        }
        return data;
    }
}

export interface IExtendOfferDto {
    customName: string | undefined;
    subId: string | undefined;
    isPublished: boolean | undefined;
    overallRating: number | undefined;
    interestRating: number | undefined;
    feesRating: number | undefined;
    benefitsRating: number | undefined;
    rewardsRating: number | undefined;
    serviceRating: number | undefined;
    cardNetwork: CardNetwork | undefined;
    cardType: CardType | undefined;
    targetAudience: TargetAudience | undefined;
    securingType: SecuringType | undefined;
    regularAPR: string | undefined;
    introAPR: string | undefined;
    balanceTransferFee: string | undefined;
    annualFee: string | undefined;
    monthlyFee: string | undefined;
    activationFee: string | undefined;
    introRewardsBonus: string | undefined;
    rewardsRate: string | undefined;
    durationForZeroPercentagePurchasesInMonths: number | undefined;
    zeroPercentageInterestTransfers: string | undefined;
    durationForZeroPercentageTransfersInMonths: number | undefined;
    issuingBank: string | undefined;
    offerCollection: OfferCollection | undefined;
    details: string[] | undefined;
    pros: string[] | undefined;
    cons: string[] | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    minLoanTermMonths: number | undefined;
    maxLoanTermMonths: number | undefined;
    minAnnualIncome: number | undefined;
    maxAnnualIncome: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    parameterHandlerType: ParameterHandlerType | undefined;
    flags: Flags | undefined;
    creditScores: CreditScoreRating[] | undefined;
    states: string[] | undefined;
}

export class ExtensionCategoryDto implements IExtensionCategoryDto {
    id!: number;
    name!: string | undefined;
    count!: number;

    constructor(data?: IExtensionCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ExtensionCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["count"] = this.count;
        return data;
    }
}

export interface IExtensionCategoryDto {
    id: number;
    name: string | undefined;
    count: number;
}

export class ExtensionDto implements IExtensionDto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    categoryId!: number;
    logo!: string | undefined;
    url!: string | undefined;
    rank!: number | undefined;

    constructor(data?: IExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.logo = _data["logo"];
            this.url = _data["url"];
            this.rank = _data["rank"];
        }
    }

    static fromJS(data: any): ExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["logo"] = this.logo;
        data["url"] = this.url;
        data["rank"] = this.rank;
        return data;
    }
}

export interface IExtensionDto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    categoryId: number;
    logo: string | undefined;
    url: string | undefined;
    rank: number | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;
    autoRegistration!: boolean;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.autoRegistration = _data["autoRegistration"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["autoRegistration"] = this.autoRegistration;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
    autoRegistration: boolean;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    waitingForActivation!: boolean;
    userNotFound!: boolean;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    detectedTenancies!: TenantModel[] | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.waitingForActivation = _data["waitingForActivation"];
            this.userNotFound = _data["userNotFound"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            if (Array.isArray(_data["detectedTenancies"])) {
                this.detectedTenancies = [] as any;
                for (let item of _data["detectedTenancies"])
                    this.detectedTenancies!.push(TenantModel.fromJS(item));
            }
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waitingForActivation"] = this.waitingForActivation;
        data["userNotFound"] = this.userNotFound;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (Array.isArray(this.detectedTenancies)) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IExternalAuthenticateResultModel {
    waitingForActivation: boolean;
    userNotFound: boolean;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    detectedTenancies: TenantModel[] | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        (<any>this.additionalParams)![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    (<any>data["additionalParams"])[key] = this.additionalParams[key];
            }
        }
        return data;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated!: boolean;
    facebook!: FacebookExternalLoginProviderSettings | undefined;
    google_IsDeactivated!: boolean;
    google!: GoogleExternalLoginProviderSettings | undefined;
    twitter_IsDeactivated!: boolean;
    twitter!: TwitterExternalLoginProviderSettings | undefined;
    microsoft_IsDeactivated!: boolean;
    microsoft!: MicrosoftExternalLoginProviderSettings | undefined;
    openIdConnect_IsDeactivated!: boolean;
    openIdConnect!: OpenIdConnectExternalLoginProviderSettings | undefined;
    openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated!: boolean;
    wsFederation!: WsFederationExternalLoginProviderSettings | undefined;
    wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

    constructor(data?: IExternalLoginProviderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facebook_IsDeactivated = _data["facebook_IsDeactivated"];
            this.facebook = _data["facebook"] ? FacebookExternalLoginProviderSettings.fromJS(_data["facebook"]) : <any>undefined;
            this.google_IsDeactivated = _data["google_IsDeactivated"];
            this.google = _data["google"] ? GoogleExternalLoginProviderSettings.fromJS(_data["google"]) : <any>undefined;
            this.twitter_IsDeactivated = _data["twitter_IsDeactivated"];
            this.twitter = _data["twitter"] ? TwitterExternalLoginProviderSettings.fromJS(_data["twitter"]) : <any>undefined;
            this.microsoft_IsDeactivated = _data["microsoft_IsDeactivated"];
            this.microsoft = _data["microsoft"] ? MicrosoftExternalLoginProviderSettings.fromJS(_data["microsoft"]) : <any>undefined;
            this.openIdConnect_IsDeactivated = _data["openIdConnect_IsDeactivated"];
            this.openIdConnect = _data["openIdConnect"] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data["openIdConnect"]) : <any>undefined;
            if (Array.isArray(_data["openIdConnectClaimsMapping"])) {
                this.openIdConnectClaimsMapping = [] as any;
                for (let item of _data["openIdConnectClaimsMapping"])
                    this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
            this.wsFederation_IsDeactivated = _data["wsFederation_IsDeactivated"];
            this.wsFederation = _data["wsFederation"] ? WsFederationExternalLoginProviderSettings.fromJS(_data["wsFederation"]) : <any>undefined;
            if (Array.isArray(_data["wsFederationClaimsMapping"])) {
                this.wsFederationClaimsMapping = [] as any;
                for (let item of _data["wsFederationClaimsMapping"])
                    this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facebook_IsDeactivated"] = this.facebook_IsDeactivated;
        data["facebook"] = this.facebook ? this.facebook.toJSON() : <any>undefined;
        data["google_IsDeactivated"] = this.google_IsDeactivated;
        data["google"] = this.google ? this.google.toJSON() : <any>undefined;
        data["twitter_IsDeactivated"] = this.twitter_IsDeactivated;
        data["twitter"] = this.twitter ? this.twitter.toJSON() : <any>undefined;
        data["microsoft_IsDeactivated"] = this.microsoft_IsDeactivated;
        data["microsoft"] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
        data["openIdConnect_IsDeactivated"] = this.openIdConnect_IsDeactivated;
        data["openIdConnect"] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
        if (Array.isArray(this.openIdConnectClaimsMapping)) {
            data["openIdConnectClaimsMapping"] = [];
            for (let item of this.openIdConnectClaimsMapping)
                data["openIdConnectClaimsMapping"].push(item.toJSON());
        }
        data["wsFederation_IsDeactivated"] = this.wsFederation_IsDeactivated;
        data["wsFederation"] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
        if (Array.isArray(this.wsFederationClaimsMapping)) {
            data["wsFederationClaimsMapping"] = [];
            for (let item of this.wsFederationClaimsMapping)
                data["wsFederationClaimsMapping"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated: boolean;
    facebook: FacebookExternalLoginProviderSettings | undefined;
    google_IsDeactivated: boolean;
    google: GoogleExternalLoginProviderSettings | undefined;
    twitter_IsDeactivated: boolean;
    twitter: TwitterExternalLoginProviderSettings | undefined;
    microsoft_IsDeactivated: boolean;
    microsoft: MicrosoftExternalLoginProviderSettings | undefined;
    openIdConnect_IsDeactivated: boolean;
    openIdConnect: OpenIdConnectExternalLoginProviderSettings | undefined;
    openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated: boolean;
    wsFederation: WsFederationExternalLoginProviderSettings | undefined;
    wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data;
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
    appId!: string | undefined;
    appSecret!: string | undefined;

    constructor(data?: IFacebookExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.appSecret = _data["appSecret"];
        }
    }

    static fromJS(data: any): FacebookExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        return data;
    }
}

export interface IFacebookExternalLoginProviderSettings {
    appId: string | undefined;
    appSecret: string | undefined;
}

export class FaviconDto implements IFaviconDto {
    name!: string | undefined;
    type!: string | undefined;
    relationship!: string | undefined;
    size!: string | undefined;

    constructor(data?: IFaviconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.relationship = _data["relationship"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): FaviconDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaviconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["relationship"] = this.relationship;
        data["size"] = this.size;
        return data;
    }
}

export interface IFaviconDto {
    name: string | undefined;
    type: string | undefined;
    relationship: string | undefined;
    size: string | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class FileInfo implements IFileInfo {
    id!: string;
    name!: string | undefined;

    constructor(data?: IFileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFileInfo {
    id: string;
    name: string | undefined;
}

export class FilestackSettingsDto implements IFilestackSettingsDto {
    apiKey!: string | undefined;
    policy!: string | undefined;
    signature!: string | undefined;

    constructor(data?: IFilestackSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.policy = _data["policy"];
            this.signature = _data["signature"];
        }
    }

    static fromJS(data: any): FilestackSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilestackSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["policy"] = this.policy;
        data["signature"] = this.signature;
        return data;
    }
}

export interface IFilestackSettingsDto {
    apiKey: string | undefined;
    policy: string | undefined;
    signature: string | undefined;
}

export class FilterElementDtoOfInt32 implements IFilterElementDtoOfInt32 {
    id!: number;
    name!: string | undefined;

    constructor(data?: IFilterElementDtoOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FilterElementDtoOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new FilterElementDtoOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFilterElementDtoOfInt32 {
    id: number;
    name: string | undefined;
}

export class FilterElementDtoOfString implements IFilterElementDtoOfString {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IFilterElementDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FilterElementDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new FilterElementDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFilterElementDtoOfString {
    id: string | undefined;
    name: string | undefined;
}

export class FiltersInitialData implements IFiltersInitialData {
    banks!: BankDto[] | undefined;
    cashflowTypes!: FilterElementDtoOfString[] | undefined;
    currencies!: FilterElementDtoOfString[] | undefined;
    businessEntities!: FilterElementDtoOfInt32[] | undefined;

    constructor(data?: IFiltersInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["banks"])) {
                this.banks = [] as any;
                for (let item of _data["banks"])
                    this.banks!.push(BankDto.fromJS(item));
            }
            if (Array.isArray(_data["cashflowTypes"])) {
                this.cashflowTypes = [] as any;
                for (let item of _data["cashflowTypes"])
                    this.cashflowTypes!.push(FilterElementDtoOfString.fromJS(item));
            }
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies!.push(FilterElementDtoOfString.fromJS(item));
            }
            if (Array.isArray(_data["businessEntities"])) {
                this.businessEntities = [] as any;
                for (let item of _data["businessEntities"])
                    this.businessEntities!.push(FilterElementDtoOfInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FiltersInitialData {
        data = typeof data === 'object' ? data : {};
        let result = new FiltersInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.banks)) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (Array.isArray(this.cashflowTypes)) {
            data["cashflowTypes"] = [];
            for (let item of this.cashflowTypes)
                data["cashflowTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        if (Array.isArray(this.businessEntities)) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFiltersInitialData {
    banks: BankDto[] | undefined;
    cashflowTypes: FilterElementDtoOfString[] | undefined;
    currencies: FilterElementDtoOfString[] | undefined;
    businessEntities: FilterElementDtoOfInt32[] | undefined;
}

export class FinalizeApplicationResponse implements IFinalizeApplicationResponse {
    status!: FinalizeApplicationStatus;
    redirectUrl!: string | undefined;

    constructor(data?: IFinalizeApplicationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): FinalizeApplicationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FinalizeApplicationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        return data;
    }
}

export interface IFinalizeApplicationResponse {
    status: FinalizeApplicationStatus;
    redirectUrl: string | undefined;
}

export enum FinalizeApplicationStatus {
    Approved = "Approved",
    Declined = "Declined",
    Finalizing = "Finalizing",
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export enum FireplaceType {
    NA = 0,
    Electric = 1,
    Gas = 2,
    Wood = 4,
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class ForecastModelDto implements IForecastModelDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IForecastModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ForecastModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IForecastModelDto {
    id: number;
    name: string | undefined;
}

export class ForecastScheduleDto implements IForecastScheduleDto {
    id!: number;
    bankAccountId!: number;
    categoryId!: number;
    forecastModelIds!: number[] | undefined;
    startDate!: moment.Moment;
    frequencyId!: string | undefined;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: IForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankAccountId = _data["bankAccountId"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["forecastModelIds"])) {
                this.forecastModelIds = [] as any;
                for (let item of _data["forecastModelIds"])
                    this.forecastModelIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = _data["calculationTypeId"];
            this.amount = _data["amount"];
            this.monthNumber = _data["monthNumber"];
            this.weekNumber = _data["weekNumber"];
            this.dayNumber = _data["dayNumber"];
            this.weekDayNumber = _data["weekDayNumber"];
        }
    }

    static fromJS(data: any): ForecastScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.forecastModelIds)) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data;
    }
}

export interface IForecastScheduleDto {
    id: number;
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[] | undefined;
    startDate: moment.Moment;
    frequencyId: string | undefined;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export enum GarbageCollection {
    Compost = 1,
    Recycling = 2,
    Waste = 4,
}

export enum Gender {
    Female = "Female",
    Male = "Male",
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    defaultCountryCode!: string | undefined;
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;
    zendeskAccountUrl!: string | undefined;
    publicPhone!: string | undefined;
    publicSiteUrl!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultCountryCode = _data["defaultCountryCode"];
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
            this.zendeskAccountUrl = _data["zendeskAccountUrl"];
            this.publicPhone = _data["publicPhone"];
            this.publicSiteUrl = _data["publicSiteUrl"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultCountryCode"] = this.defaultCountryCode;
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        data["zendeskAccountUrl"] = this.zendeskAccountUrl;
        data["publicPhone"] = this.publicPhone;
        data["publicSiteUrl"] = this.publicSiteUrl;
        return data;
    }
}

export interface IGeneralSettingsEditDto {
    defaultCountryCode: string | undefined;
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
    zendeskAccountUrl: string | undefined;
    publicPhone: string | undefined;
    publicSiteUrl: string | undefined;
}

export class GenerateApiKeyInput implements IGenerateApiKeyInput {
    name!: string;
    expirationDate!: moment.Moment | undefined;
    userId!: number | undefined;
    paths!: string | undefined;

    constructor(data?: IGenerateApiKeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.paths = _data["paths"];
        }
    }

    static fromJS(data: any): GenerateApiKeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateApiKeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["paths"] = this.paths;
        return data;
    }
}

export interface IGenerateApiKeyInput {
    name: string;
    expirationDate: moment.Moment | undefined;
    userId: number | undefined;
    paths: string | undefined;
}

export class GenerateBalanceSheetReportInput implements IGenerateBalanceSheetReportInput {
    date!: moment.Moment;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateBalanceSheetReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
            this.notificationData = _data["notificationData"] ? SendReportNotificationInfo.fromJS(_data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateBalanceSheetReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateBalanceSheetReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGenerateBalanceSheetReportInput {
    date: moment.Moment;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    notificationData: SendReportNotificationInfo | undefined;
}

export class GenerateBudgetReportInput implements IGenerateBudgetReportInput {
    businessEntityId!: number;
    year!: number;
    currencyId!: string;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateBudgetReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessEntityId = _data["businessEntityId"];
            this.year = _data["year"];
            this.currencyId = _data["currencyId"];
            this.notificationData = _data["notificationData"] ? SendReportNotificationInfo.fromJS(_data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateBudgetReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateBudgetReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        data["year"] = this.year;
        data["currencyId"] = this.currencyId;
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGenerateBudgetReportInput {
    businessEntityId: number;
    year: number;
    currencyId: string;
    notificationData: SendReportNotificationInfo | undefined;
}

export class GenerateIncomeStatementByEntityReportInput implements IGenerateIncomeStatementByEntityReportInput {
    reportTemplate!: ReportTemplate;
    from!: moment.Moment;
    to!: moment.Moment;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateIncomeStatementByEntityReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportTemplate = _data["reportTemplate"];
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
            this.notificationData = _data["notificationData"] ? SendReportNotificationInfo.fromJS(_data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateIncomeStatementByEntityReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateIncomeStatementByEntityReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportTemplate"] = this.reportTemplate;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGenerateIncomeStatementByEntityReportInput {
    reportTemplate: ReportTemplate;
    from: moment.Moment;
    to: moment.Moment;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    notificationData: SendReportNotificationInfo | undefined;
}

export class GenerateInput implements IGenerateInput {
    reportTemplate!: ReportTemplate;
    departments!: string[] | undefined;
    bankAccountIds!: number[] | undefined;
    from!: moment.Moment;
    to!: moment.Moment;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportTemplate = _data["reportTemplate"];
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments!.push(item);
            }
            if (Array.isArray(_data["bankAccountIds"])) {
                this.bankAccountIds = [] as any;
                for (let item of _data["bankAccountIds"])
                    this.bankAccountIds!.push(item);
            }
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
            this.notificationData = _data["notificationData"] ? SendReportNotificationInfo.fromJS(_data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportTemplate"] = this.reportTemplate;
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item);
        }
        if (Array.isArray(this.bankAccountIds)) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGenerateInput {
    reportTemplate: ReportTemplate;
    departments: string[] | undefined;
    bankAccountIds: number[] | undefined;
    from: moment.Moment;
    to: moment.Moment;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    notificationData: SendReportNotificationInfo | undefined;
}

export class GetAdvisorInfoOutput implements IGetAdvisorInfoOutput {
    fullName!: string | undefined;
    emailAddress!: string | undefined;
    phone!: string | undefined;
    bankCode!: string | undefined;
    profilePictureId!: string | undefined;
    advisorLinks!: AdvisorLinkInfo[] | undefined;

    constructor(data?: IGetAdvisorInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.emailAddress = _data["emailAddress"];
            this.phone = _data["phone"];
            this.bankCode = _data["bankCode"];
            this.profilePictureId = _data["profilePictureId"];
            if (Array.isArray(_data["advisorLinks"])) {
                this.advisorLinks = [] as any;
                for (let item of _data["advisorLinks"])
                    this.advisorLinks!.push(AdvisorLinkInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAdvisorInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdvisorInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["phone"] = this.phone;
        data["bankCode"] = this.bankCode;
        data["profilePictureId"] = this.profilePictureId;
        if (Array.isArray(this.advisorLinks)) {
            data["advisorLinks"] = [];
            for (let item of this.advisorLinks)
                data["advisorLinks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAdvisorInfoOutput {
    fullName: string | undefined;
    emailAddress: string | undefined;
    phone: string | undefined;
    bankCode: string | undefined;
    profilePictureId: string | undefined;
    advisorLinks: AdvisorLinkInfo[] | undefined;
}

export class GetAffiliateInfoOutput implements IGetAffiliateInfoOutput {
    id!: number;
    typeId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    affiliateCode!: string | undefined;
    userId!: number | undefined;
    photoUrl!: string | undefined;
    organizationUnitName!: string | undefined;
    organizationUnitLogoUrl!: string | undefined;

    constructor(data?: IGetAffiliateInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.affiliateCode = _data["affiliateCode"];
            this.userId = _data["userId"];
            this.photoUrl = _data["photoUrl"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.organizationUnitLogoUrl = _data["organizationUnitLogoUrl"];
        }
    }

    static fromJS(data: any): GetAffiliateInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAffiliateInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["affiliateCode"] = this.affiliateCode;
        data["userId"] = this.userId;
        data["photoUrl"] = this.photoUrl;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitLogoUrl"] = this.organizationUnitLogoUrl;
        return data;
    }
}

export interface IGetAffiliateInfoOutput {
    id: number;
    typeId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    affiliateCode: string | undefined;
    userId: number | undefined;
    photoUrl: string | undefined;
    organizationUnitName: string | undefined;
    organizationUnitLogoUrl: string | undefined;
}

export class GetAllInput implements IGetAllInput {
    testMode!: boolean;
    category!: CampaignCategory | undefined;
    type!: CampaignType | undefined;
    country!: string | undefined;
    state!: string | undefined;
    creditScore!: CreditScoreRating | undefined;
    isOfferCollection!: boolean | undefined;
    itemOfOfferCollection!: OfferCollection | undefined;
    loanAmount!: number | undefined;
    cardNetworks!: CardNetwork[] | undefined;
    cardType!: CardType | undefined;
    securingType!: SecuringType | undefined;
    targetAudience!: TargetAudience | undefined;
    annualIncome!: number | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    campaignIds!: number[] | undefined;
    sortOrderType!: SortOrderType;
    topCount!: number | undefined;
    strictMatch!: boolean;

    constructor(data?: IGetAllInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testMode = _data["testMode"];
            this.category = _data["category"];
            this.type = _data["type"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.creditScore = _data["creditScore"];
            this.isOfferCollection = _data["isOfferCollection"];
            this.itemOfOfferCollection = _data["itemOfOfferCollection"];
            this.loanAmount = _data["loanAmount"];
            if (Array.isArray(_data["cardNetworks"])) {
                this.cardNetworks = [] as any;
                for (let item of _data["cardNetworks"])
                    this.cardNetworks!.push(item);
            }
            this.cardType = _data["cardType"];
            this.securingType = _data["securingType"];
            this.targetAudience = _data["targetAudience"];
            this.annualIncome = _data["annualIncome"];
            this.overallRating = _data["overallRating"];
            this.issuingBank = _data["issuingBank"];
            if (Array.isArray(_data["campaignIds"])) {
                this.campaignIds = [] as any;
                for (let item of _data["campaignIds"])
                    this.campaignIds!.push(item);
            }
            this.sortOrderType = _data["sortOrderType"];
            this.topCount = _data["topCount"];
            this.strictMatch = _data["strictMatch"];
        }
    }

    static fromJS(data: any): GetAllInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testMode"] = this.testMode;
        data["category"] = this.category;
        data["type"] = this.type;
        data["country"] = this.country;
        data["state"] = this.state;
        data["creditScore"] = this.creditScore;
        data["isOfferCollection"] = this.isOfferCollection;
        data["itemOfOfferCollection"] = this.itemOfOfferCollection;
        data["loanAmount"] = this.loanAmount;
        if (Array.isArray(this.cardNetworks)) {
            data["cardNetworks"] = [];
            for (let item of this.cardNetworks)
                data["cardNetworks"].push(item);
        }
        data["cardType"] = this.cardType;
        data["securingType"] = this.securingType;
        data["targetAudience"] = this.targetAudience;
        data["annualIncome"] = this.annualIncome;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        if (Array.isArray(this.campaignIds)) {
            data["campaignIds"] = [];
            for (let item of this.campaignIds)
                data["campaignIds"].push(item);
        }
        data["sortOrderType"] = this.sortOrderType;
        data["topCount"] = this.topCount;
        data["strictMatch"] = this.strictMatch;
        return data;
    }
}

export interface IGetAllInput {
    testMode: boolean;
    category: CampaignCategory | undefined;
    type: CampaignType | undefined;
    country: string | undefined;
    state: string | undefined;
    creditScore: CreditScoreRating | undefined;
    isOfferCollection: boolean | undefined;
    itemOfOfferCollection: OfferCollection | undefined;
    loanAmount: number | undefined;
    cardNetworks: CardNetwork[] | undefined;
    cardType: CardType | undefined;
    securingType: SecuringType | undefined;
    targetAudience: TargetAudience | undefined;
    annualIncome: number | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    campaignIds: number[] | undefined;
    sortOrderType: SortOrderType;
    topCount: number | undefined;
    strictMatch: boolean;
}

export class GetApplicationDetailsOutput implements IGetApplicationDetailsOutput {
    systemType!: OfferProviderType;
    campaignId!: number | undefined;
    clickId!: string | undefined;
    personalInformation!: PersonalInformation | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformation | undefined;
    employmentInformation!: EmploymentInformation | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IGetApplicationDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemType = _data["systemType"];
            this.campaignId = _data["campaignId"];
            this.clickId = _data["clickId"];
            this.personalInformation = _data["personalInformation"] ? PersonalInformation.fromJS(_data["personalInformation"]) : <any>undefined;
            this.debtInformation = _data["debtInformation"] ? DebtInformation.fromJS(_data["debtInformation"]) : <any>undefined;
            this.loanInformation = _data["loanInformation"] ? LoanInformation.fromJS(_data["loanInformation"]) : <any>undefined;
            this.employmentInformation = _data["employmentInformation"] ? EmploymentInformation.fromJS(_data["employmentInformation"]) : <any>undefined;
            this.bankInformation = _data["bankInformation"] ? BankInformation.fromJS(_data["bankInformation"]) : <any>undefined;
            this.legalInformation = _data["legalInformation"] ? LegalInformation.fromJS(_data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetApplicationDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["campaignId"] = this.campaignId;
        data["clickId"] = this.clickId;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetApplicationDetailsOutput {
    systemType: OfferProviderType;
    campaignId: number | undefined;
    clickId: string | undefined;
    personalInformation: PersonalInformation | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformation | undefined;
    employmentInformation: EmploymentInformation | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class GetBankCodeInput implements IGetBankCodeInput {
    content!: string;
    source!: string | undefined;

    constructor(data?: IGetBankCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): GetBankCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["source"] = this.source;
        return data;
    }
}

export interface IGetBankCodeInput {
    content: string;
    source: string | undefined;
}

export class GetBankCodeOutput implements IGetBankCodeOutput {
    action!: number;
    blueprint!: number;
    knowledge!: number;
    nurturing!: number;
    value!: string | undefined;

    constructor(data?: IGetBankCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.blueprint = _data["blueprint"];
            this.knowledge = _data["knowledge"];
            this.nurturing = _data["nurturing"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GetBankCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["blueprint"] = this.blueprint;
        data["knowledge"] = this.knowledge;
        data["nurturing"] = this.nurturing;
        data["value"] = this.value;
        return data;
    }
}

export interface IGetBankCodeOutput {
    action: number;
    blueprint: number;
    knowledge: number;
    nurturing: number;
    value: string | undefined;
}

export class GetCategoryTreeOutput implements IGetCategoryTreeOutput {
    types!: { [key: string]: TypeDto; } | undefined;
    accountingTypes!: { [key: string]: AccountingTypeDto; } | undefined;
    categories!: { [key: string]: CategoryDto; } | undefined;

    constructor(data?: IGetCategoryTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeDto.fromJS(_data["types"][key]) : new TypeDto();
                }
            }
            if (_data["accountingTypes"]) {
                this.accountingTypes = {} as any;
                for (let key in _data["accountingTypes"]) {
                    if (_data["accountingTypes"].hasOwnProperty(key))
                        (<any>this.accountingTypes)![key] = _data["accountingTypes"][key] ? AccountingTypeDto.fromJS(_data["accountingTypes"][key]) : new AccountingTypeDto();
                }
            }
            if (_data["categories"]) {
                this.categories = {} as any;
                for (let key in _data["categories"]) {
                    if (_data["categories"].hasOwnProperty(key))
                        (<any>this.categories)![key] = _data["categories"][key] ? CategoryDto.fromJS(_data["categories"][key]) : new CategoryDto();
                }
            }
        }
    }

    static fromJS(data: any): GetCategoryTreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
            }
        }
        if (this.accountingTypes) {
            data["accountingTypes"] = {};
            for (let key in this.accountingTypes) {
                if (this.accountingTypes.hasOwnProperty(key))
                    (<any>data["accountingTypes"])[key] = this.accountingTypes[key] ? this.accountingTypes[key].toJSON() : <any>undefined;
            }
        }
        if (this.categories) {
            data["categories"] = {};
            for (let key in this.categories) {
                if (this.categories.hasOwnProperty(key))
                    (<any>data["categories"])[key] = this.categories[key] ? this.categories[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IGetCategoryTreeOutput {
    types: { [key: string]: TypeDto; } | undefined;
    accountingTypes: { [key: string]: AccountingTypeDto; } | undefined;
    categories: { [key: string]: CategoryDto; } | undefined;
}

export class GetContactInfoForMergeOutput implements IGetContactInfoForMergeOutput {
    contactInfo!: ContactInfoForMerge | undefined;
    contactLeadInfo!: LeadInfoForMerge | undefined;
    targetContactInfo!: ContactInfoForMerge | undefined;
    targetContactLeadInfo!: LeadInfoForMerge | undefined;

    constructor(data?: IGetContactInfoForMergeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactInfo = _data["contactInfo"] ? ContactInfoForMerge.fromJS(_data["contactInfo"]) : <any>undefined;
            this.contactLeadInfo = _data["contactLeadInfo"] ? LeadInfoForMerge.fromJS(_data["contactLeadInfo"]) : <any>undefined;
            this.targetContactInfo = _data["targetContactInfo"] ? ContactInfoForMerge.fromJS(_data["targetContactInfo"]) : <any>undefined;
            this.targetContactLeadInfo = _data["targetContactLeadInfo"] ? LeadInfoForMerge.fromJS(_data["targetContactLeadInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContactInfoForMergeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactInfoForMergeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        data["contactLeadInfo"] = this.contactLeadInfo ? this.contactLeadInfo.toJSON() : <any>undefined;
        data["targetContactInfo"] = this.targetContactInfo ? this.targetContactInfo.toJSON() : <any>undefined;
        data["targetContactLeadInfo"] = this.targetContactLeadInfo ? this.targetContactLeadInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetContactInfoForMergeOutput {
    contactInfo: ContactInfoForMerge | undefined;
    contactLeadInfo: LeadInfoForMerge | undefined;
    targetContactInfo: ContactInfoForMerge | undefined;
    targetContactLeadInfo: LeadInfoForMerge | undefined;
}

export class GetContactInfoStatsByStarOutput implements IGetContactInfoStatsByStarOutput {
    countWithEmail!: number;
    countWithName!: number;
    countWithPhone!: number;
    key!: string | undefined;
    count!: number;

    constructor(data?: IGetContactInfoStatsByStarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countWithEmail = _data["countWithEmail"];
            this.countWithName = _data["countWithName"];
            this.countWithPhone = _data["countWithPhone"];
            this.key = _data["key"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): GetContactInfoStatsByStarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactInfoStatsByStarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countWithEmail"] = this.countWithEmail;
        data["countWithName"] = this.countWithName;
        data["countWithPhone"] = this.countWithPhone;
        data["key"] = this.key;
        data["count"] = this.count;
        return data;
    }
}

export interface IGetContactInfoStatsByStarOutput {
    countWithEmail: number;
    countWithName: number;
    countWithPhone: number;
    key: string | undefined;
    count: number;
}

export class GetContactsByCompanySizeOutput implements IGetContactsByCompanySizeOutput {
    contactCount!: number;
    companySizeRange!: string | undefined;

    constructor(data?: IGetContactsByCompanySizeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactCount = _data["contactCount"];
            this.companySizeRange = _data["companySizeRange"];
        }
    }

    static fromJS(data: any): GetContactsByCompanySizeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactsByCompanySizeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactCount"] = this.contactCount;
        data["companySizeRange"] = this.companySizeRange;
        return data;
    }
}

export interface IGetContactsByCompanySizeOutput {
    contactCount: number;
    companySizeRange: string | undefined;
}

export class GetContactsByRegionOutput implements IGetContactsByRegionOutput {
    countryId!: string | undefined;
    stateId!: string | undefined;
    count!: number;

    constructor(data?: IGetContactsByRegionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): GetContactsByRegionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactsByRegionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["count"] = this.count;
        return data;
    }
}

export interface IGetContactsByRegionOutput {
    countryId: string | undefined;
    stateId: string | undefined;
    count: number;
}

export class GetCountByStarOutput implements IGetCountByStarOutput {
    colorType!: ContactStarColorType | undefined;
    key!: string | undefined;
    count!: number;

    constructor(data?: IGetCountByStarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.colorType = _data["colorType"];
            this.key = _data["key"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): GetCountByStarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountByStarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colorType"] = this.colorType;
        data["key"] = this.key;
        data["count"] = this.count;
        return data;
    }
}

export interface IGetCountByStarOutput {
    colorType: ContactStarColorType | undefined;
    key: string | undefined;
    count: number;
}

export class GetCountOutput implements IGetCountOutput {
    key!: string | undefined;
    count!: number;

    constructor(data?: IGetCountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): GetCountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data;
    }
}

export interface IGetCountOutput {
    key: string | undefined;
    count: number;
}

export class GetCountOutputOfLeadAgeRange implements IGetCountOutputOfLeadAgeRange {
    key!: LeadAgeRange;
    count!: number;

    constructor(data?: IGetCountOutputOfLeadAgeRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): GetCountOutputOfLeadAgeRange {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountOutputOfLeadAgeRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data;
    }
}

export interface IGetCountOutputOfLeadAgeRange {
    key: LeadAgeRange;
    count: number;
}

export class GetCRMStatusOutput implements IGetCRMStatusOutput {
    hasData!: boolean;

    constructor(data?: IGetCRMStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasData = _data["hasData"];
        }
    }

    static fromJS(data: any): GetCRMStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCRMStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasData"] = this.hasData;
        return data;
    }
}

export interface IGetCRMStatusOutput {
    hasData: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    impersonatorUser!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    impersonatorTenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;
    theme!: UiCustomizationSettingsDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    impersonatorUser: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    impersonatorTenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
}

export class GetCurrentUserProfileEditDto implements IGetCurrentUserProfileEditDto {
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;
    name!: string;
    surname!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    companyName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IGetCurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.companyName = _data["companyName"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): GetCurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["companyName"] = this.companyName;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IGetCurrentUserProfileEditDto {
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    companyName: string | undefined;
    countryId: string | undefined;
}

export class GetCustomerAndLeadStatsOutput implements IGetCustomerAndLeadStatsOutput {
    date!: moment.Moment;
    customerCount!: number;
    leadTotalCount!: number;
    leadStageCount!: { [key: string]: number; } | undefined;

    constructor(data?: IGetCustomerAndLeadStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.customerCount = _data["customerCount"];
            this.leadTotalCount = _data["leadTotalCount"];
            if (_data["leadStageCount"]) {
                this.leadStageCount = {} as any;
                for (let key in _data["leadStageCount"]) {
                    if (_data["leadStageCount"].hasOwnProperty(key))
                        (<any>this.leadStageCount)![key] = _data["leadStageCount"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetCustomerAndLeadStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerAndLeadStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["customerCount"] = this.customerCount;
        data["leadTotalCount"] = this.leadTotalCount;
        if (this.leadStageCount) {
            data["leadStageCount"] = {};
            for (let key in this.leadStageCount) {
                if (this.leadStageCount.hasOwnProperty(key))
                    (<any>data["leadStageCount"])[key] = this.leadStageCount[key];
            }
        }
        return data;
    }
}

export interface IGetCustomerAndLeadStatsOutput {
    date: moment.Moment;
    customerCount: number;
    leadTotalCount: number;
    leadStageCount: { [key: string]: number; } | undefined;
}

export class GetDailyBalanceStatsOutput implements IGetDailyBalanceStatsOutput {
    minBalance!: number;
    avarageBalance!: number;
    maxBalance!: number;
    count!: number;

    constructor(data?: IGetDailyBalanceStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minBalance = _data["minBalance"];
            this.avarageBalance = _data["avarageBalance"];
            this.maxBalance = _data["maxBalance"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): GetDailyBalanceStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailyBalanceStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minBalance"] = this.minBalance;
        data["avarageBalance"] = this.avarageBalance;
        data["maxBalance"] = this.maxBalance;
        data["count"] = this.count;
        return data;
    }
}

export interface IGetDailyBalanceStatsOutput {
    minBalance: number;
    avarageBalance: number;
    maxBalance: number;
    count: number;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GetEmailDataOutput implements IGetEmailDataOutput {
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    previewText!: string | undefined;
    body!: string | undefined;
    attachments!: Attachment[] | undefined;
    tags!: { [key: string]: string; } | undefined;

    constructor(data?: IGetEmailDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.previewText = _data["previewText"];
            this.body = _data["body"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(Attachment.fromJS(item));
            }
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetEmailDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["previewText"] = this.previewText;
        data["body"] = this.body;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = this.tags[key];
            }
        }
        return data;
    }
}

export interface IGetEmailDataOutput {
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    previewText: string | undefined;
    body: string | undefined;
    attachments: Attachment[] | undefined;
    tags: { [key: string]: string; } | undefined;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: moment.Moment;
    subscriptionEndDateEnd!: moment.Moment;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? moment(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? moment(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;
}

export class GetFileUrlDto implements IGetFileUrlDto {
    url!: string | undefined;
    validityPeriodSeconds!: number;

    constructor(data?: IGetFileUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.validityPeriodSeconds = _data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetFileUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data;
    }
}

export interface IGetFileUrlDto {
    url: string | undefined;
    validityPeriodSeconds: number;
}

export class GetFileUrlOutput implements IGetFileUrlOutput {
    url!: string | undefined;
    validityPeriod!: string;

    constructor(data?: IGetFileUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): GetFileUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriod"] = this.validityPeriod;
        return data;
    }
}

export interface IGetFileUrlOutput {
    url: string | undefined;
    validityPeriod: string;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export class GetImportStatusOutput implements IGetImportStatusOutput {
    id!: number;
    statusId!: string | undefined;
    fileName!: string | undefined;
    totalCount!: number;
    importedCount!: number;
    failedCount!: number;

    constructor(data?: IGetImportStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.statusId = _data["statusId"];
            this.fileName = _data["fileName"];
            this.totalCount = _data["totalCount"];
            this.importedCount = _data["importedCount"];
            this.failedCount = _data["failedCount"];
        }
    }

    static fromJS(data: any): GetImportStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImportStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusId"] = this.statusId;
        data["fileName"] = this.fileName;
        data["totalCount"] = this.totalCount;
        data["importedCount"] = this.importedCount;
        data["failedCount"] = this.failedCount;
        return data;
    }
}

export interface IGetImportStatusOutput {
    id: number;
    statusId: string | undefined;
    fileName: string | undefined;
    totalCount: number;
    importedCount: number;
    failedCount: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetInvoiceReceiptInfoOutput implements IGetInvoiceReceiptInfoOutput {
    tenantName!: string | undefined;
    tenantLogoUrl!: string | undefined;
    invoiceNumber!: string | undefined;
    invoiceAmount!: number;
    invoiceStatus!: InvoiceStatus;
    paymentDate!: moment.Moment | undefined;
    paymentMethod!: string | undefined;
    downloadInvoiceUrl!: string | undefined;

    constructor(data?: IGetInvoiceReceiptInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.tenantLogoUrl = _data["tenantLogoUrl"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceAmount = _data["invoiceAmount"];
            this.invoiceStatus = _data["invoiceStatus"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.paymentMethod = _data["paymentMethod"];
            this.downloadInvoiceUrl = _data["downloadInvoiceUrl"];
        }
    }

    static fromJS(data: any): GetInvoiceReceiptInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceReceiptInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["tenantLogoUrl"] = this.tenantLogoUrl;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceAmount"] = this.invoiceAmount;
        data["invoiceStatus"] = this.invoiceStatus;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["paymentMethod"] = this.paymentMethod;
        data["downloadInvoiceUrl"] = this.downloadInvoiceUrl;
        return data;
    }
}

export interface IGetInvoiceReceiptInfoOutput {
    tenantName: string | undefined;
    tenantLogoUrl: string | undefined;
    invoiceNumber: string | undefined;
    invoiceAmount: number;
    invoiceStatus: InvoiceStatus;
    paymentDate: moment.Moment | undefined;
    paymentMethod: string | undefined;
    downloadInvoiceUrl: string | undefined;
}

export class GetKeyAttributeValuesInput implements IGetKeyAttributeValuesInput {
    ruleId!: number | undefined;
    transactionIds!: number[] | undefined;

    constructor(data?: IGetKeyAttributeValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleId = _data["ruleId"];
            if (Array.isArray(_data["transactionIds"])) {
                this.transactionIds = [] as any;
                for (let item of _data["transactionIds"])
                    this.transactionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetKeyAttributeValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetKeyAttributeValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        if (Array.isArray(this.transactionIds)) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data;
    }
}

export interface IGetKeyAttributeValuesInput {
    ruleId: number | undefined;
    transactionIds: number[] | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class GetLeaderBoardOutput implements IGetLeaderBoardOutput {
    leaders!: LeaderInfo[] | undefined;
    generationTime!: moment.Moment;

    constructor(data?: IGetLeaderBoardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["leaders"])) {
                this.leaders = [] as any;
                for (let item of _data["leaders"])
                    this.leaders!.push(LeaderInfo.fromJS(item));
            }
            this.generationTime = _data["generationTime"] ? moment(_data["generationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLeaderBoardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLeaderBoardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.leaders)) {
            data["leaders"] = [];
            for (let item of this.leaders)
                data["leaders"].push(item.toJSON());
        }
        data["generationTime"] = this.generationTime ? this.generationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetLeaderBoardOutput {
    leaders: LeaderInfo[] | undefined;
    generationTime: moment.Moment;
}

export class GetLedgerOutput implements IGetLedgerOutput {
    startingEarningsBalance!: number;
    startingWithdrawalsBalance!: number;
    availableBalance!: number;
    entries!: CommissionLedgerEntryInfo[] | undefined;

    constructor(data?: IGetLedgerOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startingEarningsBalance = _data["startingEarningsBalance"];
            this.startingWithdrawalsBalance = _data["startingWithdrawalsBalance"];
            this.availableBalance = _data["availableBalance"];
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(CommissionLedgerEntryInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLedgerOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLedgerOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startingEarningsBalance"] = this.startingEarningsBalance;
        data["startingWithdrawalsBalance"] = this.startingWithdrawalsBalance;
        data["availableBalance"] = this.availableBalance;
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLedgerOutput {
    startingEarningsBalance: number;
    startingWithdrawalsBalance: number;
    availableBalance: number;
    entries: CommissionLedgerEntryInfo[] | undefined;
}

export class GetLedgerTotalsOutput implements IGetLedgerTotalsOutput {
    earnedAmount!: number;
    withdrawnAmount!: number;
    pendingEarningsAmount!: number;
    pendingWithdrawalsAmount!: number;
    availableBalance!: number;

    constructor(data?: IGetLedgerTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.earnedAmount = _data["earnedAmount"];
            this.withdrawnAmount = _data["withdrawnAmount"];
            this.pendingEarningsAmount = _data["pendingEarningsAmount"];
            this.pendingWithdrawalsAmount = _data["pendingWithdrawalsAmount"];
            this.availableBalance = _data["availableBalance"];
        }
    }

    static fromJS(data: any): GetLedgerTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLedgerTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["earnedAmount"] = this.earnedAmount;
        data["withdrawnAmount"] = this.withdrawnAmount;
        data["pendingEarningsAmount"] = this.pendingEarningsAmount;
        data["pendingWithdrawalsAmount"] = this.pendingWithdrawalsAmount;
        data["availableBalance"] = this.availableBalance;
        return data;
    }
}

export interface IGetLedgerTotalsOutput {
    earnedAmount: number;
    withdrawnAmount: number;
    pendingEarningsAmount: number;
    pendingWithdrawalsAmount: number;
    availableBalance: number;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class GetMemberInfoOutput implements IGetMemberInfoOutput {
    subscriptions!: SubscriptionShortInfoOutput[] | undefined;
    userKey!: string | undefined;
    monthlyGoal!: number | undefined;

    constructor(data?: IGetMemberInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subscriptions"])) {
                this.subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    this.subscriptions!.push(SubscriptionShortInfoOutput.fromJS(item));
            }
            this.userKey = _data["userKey"];
            this.monthlyGoal = _data["monthlyGoal"];
        }
    }

    static fromJS(data: any): GetMemberInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        data["userKey"] = this.userKey;
        data["monthlyGoal"] = this.monthlyGoal;
        return data;
    }
}

export interface IGetMemberInfoOutput {
    subscriptions: SubscriptionShortInfoOutput[] | undefined;
    userKey: string | undefined;
    monthlyGoal: number | undefined;
}

export class GetMemberInfoResponse implements IGetMemberInfoResponse {
    applicantId!: string | undefined;
    incompleteApplicationId!: number | undefined;
    clickId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    zipCode!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    countryCode!: string | undefined;
    doB!: moment.Moment | undefined;
    creditScore!: CreditScoreRating | undefined;
    testMode!: boolean;
    profileSubmissionDate!: moment.Moment | undefined;

    constructor(data?: IGetMemberInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicantId = _data["applicantId"];
            this.incompleteApplicationId = _data["incompleteApplicationId"];
            this.clickId = _data["clickId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.zipCode = _data["zipCode"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.stateCode = _data["stateCode"];
            this.countryCode = _data["countryCode"];
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.creditScore = _data["creditScore"];
            this.testMode = _data["testMode"];
            this.profileSubmissionDate = _data["profileSubmissionDate"] ? moment(_data["profileSubmissionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMemberInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantId"] = this.applicantId;
        data["incompleteApplicationId"] = this.incompleteApplicationId;
        data["clickId"] = this.clickId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["zipCode"] = this.zipCode;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["creditScore"] = this.creditScore;
        data["testMode"] = this.testMode;
        data["profileSubmissionDate"] = this.profileSubmissionDate ? this.profileSubmissionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetMemberInfoResponse {
    applicantId: string | undefined;
    incompleteApplicationId: number | undefined;
    clickId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    zipCode: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    countryCode: string | undefined;
    doB: moment.Moment | undefined;
    creditScore: CreditScoreRating | undefined;
    testMode: boolean;
    profileSubmissionDate: moment.Moment | undefined;
}

export class GetMemberPortalUrlOutput implements IGetMemberPortalUrlOutput {
    url!: string | undefined;

    constructor(data?: IGetMemberPortalUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): GetMemberPortalUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberPortalUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface IGetMemberPortalUrlOutput {
    url: string | undefined;
}

export class GetNewInvoiceInfoOutput implements IGetNewInvoiceInfoOutput {
    nextInvoiceNumber!: string | undefined;

    constructor(data?: IGetNewInvoiceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextInvoiceNumber = _data["nextInvoiceNumber"];
        }
    }

    static fromJS(data: any): GetNewInvoiceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNewInvoiceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextInvoiceNumber"] = this.nextInvoiceNumber;
        return data;
    }
}

export interface IGetNewInvoiceInfoOutput {
    nextInvoiceNumber: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    items!: UserNotificationDto[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationsOutput {
    items: UserNotificationDto[] | undefined;
}

export class GetPackagesConfigOutput implements IGetPackagesConfigOutput {
    currentSubscriptionInfo!: ModuleSubscriptionInfoExtended | undefined;
    packages!: PackageConfigDto[] | undefined;

    constructor(data?: IGetPackagesConfigOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentSubscriptionInfo = _data["currentSubscriptionInfo"] ? ModuleSubscriptionInfoExtended.fromJS(_data["currentSubscriptionInfo"]) : <any>undefined;
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages!.push(PackageConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPackagesConfigOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackagesConfigOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentSubscriptionInfo"] = this.currentSubscriptionInfo ? this.currentSubscriptionInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPackagesConfigOutput {
    currentSubscriptionInfo: ModuleSubscriptionInfoExtended | undefined;
    packages: PackageConfigDto[] | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetPaymentsDto implements IGetPaymentsDto {
    totalPaymentAmount!: number;
    hasRecurringBilling!: boolean;
    payments!: ShortPaymentInfo[] | undefined;

    constructor(data?: IGetPaymentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPaymentAmount = _data["totalPaymentAmount"];
            this.hasRecurringBilling = _data["hasRecurringBilling"];
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(ShortPaymentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPaymentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaymentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPaymentsDto {
    totalPaymentAmount: number;
    hasRecurringBilling: boolean;
    payments: ShortPaymentInfo[] | undefined;
}

export class GetPlatformAppUrlOutput implements IGetPlatformAppUrlOutput {
    url!: string | undefined;
    isCustom!: boolean;

    constructor(data?: IGetPlatformAppUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.isCustom = _data["isCustom"];
        }
    }

    static fromJS(data: any): GetPlatformAppUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlatformAppUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["isCustom"] = this.isCustom;
        return data;
    }
}

export interface IGetPlatformAppUrlOutput {
    url: string | undefined;
    isCustom: boolean;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetRapidClientsOutput implements IGetRapidClientsOutput {
    contactId!: number;
    name!: string | undefined;
    companyName!: string | undefined;
    email!: string | undefined;

    constructor(data?: IGetRapidClientsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.name = _data["name"];
            this.companyName = _data["companyName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetRapidClientsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRapidClientsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["name"] = this.name;
        data["companyName"] = this.companyName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetRapidClientsOutput {
    contactId: number;
    name: string | undefined;
    companyName: string | undefined;
    email: string | undefined;
}

export class GetRapidTokenOutput implements IGetRapidTokenOutput {
    token!: string | undefined;
    expirationDate!: moment.Moment;

    constructor(data?: IGetRapidTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRapidTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRapidTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetRapidTokenOutput {
    token: string | undefined;
    expirationDate: moment.Moment;
}

export class GetRecentlyCreatedCustomersOutput implements IGetRecentlyCreatedCustomersOutput {
    contactId!: number;
    fullName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    bankCode!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IGetRecentlyCreatedCustomersOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.bankCode = _data["bankCode"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentlyCreatedCustomersOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentlyCreatedCustomersOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["bankCode"] = this.bankCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetRecentlyCreatedCustomersOutput {
    contactId: number;
    fullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    bankCode: string | undefined;
    creationTime: moment.Moment;
}

export class GetRecentlyCreatedLeadsOutput implements IGetRecentlyCreatedLeadsOutput {
    leadId!: number;
    contactId!: number;
    fullName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    bankCode!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IGetRecentlyCreatedLeadsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.contactId = _data["contactId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.bankCode = _data["bankCode"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentlyCreatedLeadsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentlyCreatedLeadsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["bankCode"] = this.bankCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetRecentlyCreatedLeadsOutput {
    leadId: number;
    contactId: number;
    fullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    bankCode: string | undefined;
    creationTime: moment.Moment;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: moment.Moment;
    recentTenants!: RecentTenant[] | undefined;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? moment(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: moment.Moment;
    recentTenants: RecentTenant[] | undefined;
}

export class GetRefundsAndCancellationsOutput implements IGetRefundsAndCancellationsOutput {
    refunds!: { [key: string]: RefundInfo; } | undefined;
    cancellations!: { [key: string]: number; } | undefined;

    constructor(data?: IGetRefundsAndCancellationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["refunds"]) {
                this.refunds = {} as any;
                for (let key in _data["refunds"]) {
                    if (_data["refunds"].hasOwnProperty(key))
                        (<any>this.refunds)![key] = _data["refunds"][key] ? RefundInfo.fromJS(_data["refunds"][key]) : new RefundInfo();
                }
            }
            if (_data["cancellations"]) {
                this.cancellations = {} as any;
                for (let key in _data["cancellations"]) {
                    if (_data["cancellations"].hasOwnProperty(key))
                        (<any>this.cancellations)![key] = _data["cancellations"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetRefundsAndCancellationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRefundsAndCancellationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.refunds) {
            data["refunds"] = {};
            for (let key in this.refunds) {
                if (this.refunds.hasOwnProperty(key))
                    (<any>data["refunds"])[key] = this.refunds[key] ? this.refunds[key].toJSON() : <any>undefined;
            }
        }
        if (this.cancellations) {
            data["cancellations"] = {};
            for (let key in this.cancellations) {
                if (this.cancellations.hasOwnProperty(key))
                    (<any>data["cancellations"])[key] = this.cancellations[key];
            }
        }
        return data;
    }
}

export interface IGetRefundsAndCancellationsOutput {
    refunds: { [key: string]: RefundInfo; } | undefined;
    cancellations: { [key: string]: number; } | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetReportTemplateDefinitionOutput implements IGetReportTemplateDefinitionOutput {
    sections!: { [key: string]: ReportSectionDto; } | undefined;
    categorySectionMap!: { [key: string]: number; } | undefined;

    constructor(data?: IGetReportTemplateDefinitionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["sections"]) {
                this.sections = {} as any;
                for (let key in _data["sections"]) {
                    if (_data["sections"].hasOwnProperty(key))
                        (<any>this.sections)![key] = _data["sections"][key] ? ReportSectionDto.fromJS(_data["sections"][key]) : new ReportSectionDto();
                }
            }
            if (_data["categorySectionMap"]) {
                this.categorySectionMap = {} as any;
                for (let key in _data["categorySectionMap"]) {
                    if (_data["categorySectionMap"].hasOwnProperty(key))
                        (<any>this.categorySectionMap)![key] = _data["categorySectionMap"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetReportTemplateDefinitionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateDefinitionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sections) {
            data["sections"] = {};
            for (let key in this.sections) {
                if (this.sections.hasOwnProperty(key))
                    (<any>data["sections"])[key] = this.sections[key] ? this.sections[key].toJSON() : <any>undefined;
            }
        }
        if (this.categorySectionMap) {
            data["categorySectionMap"] = {};
            for (let key in this.categorySectionMap) {
                if (this.categorySectionMap.hasOwnProperty(key))
                    (<any>data["categorySectionMap"])[key] = this.categorySectionMap[key];
            }
        }
        return data;
    }
}

export interface IGetReportTemplateDefinitionOutput {
    sections: { [key: string]: ReportSectionDto; } | undefined;
    categorySectionMap: { [key: string]: number; } | undefined;
}

export class GetReportUrlOutput implements IGetReportUrlOutput {
    url!: string | undefined;
    validityPeriodSeconds!: number;

    constructor(data?: IGetReportUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.validityPeriodSeconds = _data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetReportUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data;
    }
}

export interface IGetReportUrlOutput {
    url: string | undefined;
    validityPeriodSeconds: number;
}

export class GetResetPasswordCodeInfoInput implements IGetResetPasswordCodeInfoInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IGetResetPasswordCodeInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): GetResetPasswordCodeInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetResetPasswordCodeInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IGetResetPasswordCodeInfoInput {
    userId: number | undefined;
    resetCode: string | undefined;
    c: string | undefined;
}

export class GetResetPasswordCodeInfoOutput implements IGetResetPasswordCodeInfoOutput {
    tenantId!: number | undefined;
    isValid!: boolean;

    constructor(data?: IGetResetPasswordCodeInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): GetResetPasswordCodeInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetResetPasswordCodeInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface IGetResetPasswordCodeInfoOutput {
    tenantId: number | undefined;
    isValid: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetRolesInput implements IGetRolesInput {
    permissions!: string[] | undefined;
    moduleType!: ModuleType | undefined;

    constructor(data?: IGetRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.moduleType = _data["moduleType"];
        }
    }

    static fromJS(data: any): GetRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["moduleType"] = this.moduleType;
        return data;
    }
}

export interface IGetRolesInput {
    permissions: string[] | undefined;
    moduleType: ModuleType | undefined;
}

export class GetRulesInput implements IGetRulesInput {

    constructor(data?: IGetRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetRulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetRulesInput {
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetSourceContactInfoOutput implements IGetSourceContactInfoOutput {
    sourceContactLevel1!: SourceContactLevelInfo | undefined;
    sourceContactLevel2!: SourceContactLevelInfo | undefined;

    constructor(data?: IGetSourceContactInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceContactLevel1 = _data["sourceContactLevel1"] ? SourceContactLevelInfo.fromJS(_data["sourceContactLevel1"]) : <any>undefined;
            this.sourceContactLevel2 = _data["sourceContactLevel2"] ? SourceContactLevelInfo.fromJS(_data["sourceContactLevel2"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSourceContactInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSourceContactInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceContactLevel1"] = this.sourceContactLevel1 ? this.sourceContactLevel1.toJSON() : <any>undefined;
        data["sourceContactLevel2"] = this.sourceContactLevel2 ? this.sourceContactLevel2.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSourceContactInfoOutput {
    sourceContactLevel1: SourceContactLevelInfo | undefined;
    sourceContactLevel2: SourceContactLevelInfo | undefined;
}

export class GetSpendingCategoriesOutput implements IGetSpendingCategoriesOutput {
    id!: number;
    name!: string | undefined;
    fullName!: string | undefined;
    amount!: number;

    constructor(data?: IGetSpendingCategoriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.fullName = _data["fullName"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): GetSpendingCategoriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSpendingCategoriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IGetSpendingCategoriesOutput {
    id: number;
    name: string | undefined;
    fullName: string | undefined;
    amount: number;
}

export class GetStatusOutput implements IGetStatusOutput {
    status!: InstanceStatus;
    userId!: number | undefined;
    hasSyncAccounts!: boolean;
    hasTransactions!: boolean;
    hasAccountsAccess!: boolean;
    hasCategorizationSupported!: boolean;

    constructor(data?: IGetStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.userId = _data["userId"];
            this.hasSyncAccounts = _data["hasSyncAccounts"];
            this.hasTransactions = _data["hasTransactions"];
            this.hasAccountsAccess = _data["hasAccountsAccess"];
            this.hasCategorizationSupported = _data["hasCategorizationSupported"];
        }
    }

    static fromJS(data: any): GetStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["hasSyncAccounts"] = this.hasSyncAccounts;
        data["hasTransactions"] = this.hasTransactions;
        data["hasAccountsAccess"] = this.hasAccountsAccess;
        data["hasCategorizationSupported"] = this.hasCategorizationSupported;
        return data;
    }
}

export interface IGetStatusOutput {
    status: InstanceStatus;
    userId: number | undefined;
    hasSyncAccounts: boolean;
    hasTransactions: boolean;
    hasAccountsAccess: boolean;
    hasCategorizationSupported: boolean;
}

export class GetSystemTotalsOutput implements IGetSystemTotalsOutput {
    systemTotals!: { [key: string]: number; } | undefined;
    lastCrackedCode!: string | undefined;
    generationTime!: moment.Moment;

    constructor(data?: IGetSystemTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["systemTotals"]) {
                this.systemTotals = {} as any;
                for (let key in _data["systemTotals"]) {
                    if (_data["systemTotals"].hasOwnProperty(key))
                        (<any>this.systemTotals)![key] = _data["systemTotals"][key];
                }
            }
            this.lastCrackedCode = _data["lastCrackedCode"];
            this.generationTime = _data["generationTime"] ? moment(_data["generationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSystemTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSystemTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.systemTotals) {
            data["systemTotals"] = {};
            for (let key in this.systemTotals) {
                if (this.systemTotals.hasOwnProperty(key))
                    (<any>data["systemTotals"])[key] = this.systemTotals[key];
            }
        }
        data["lastCrackedCode"] = this.lastCrackedCode;
        data["generationTime"] = this.generationTime ? this.generationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetSystemTotalsOutput {
    systemTotals: { [key: string]: number; } | undefined;
    lastCrackedCode: string | undefined;
    generationTime: moment.Moment;
}

export class GetTemplateReponse implements IGetTemplateReponse {
    name!: string | undefined;
    type!: EmailTemplateType;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    previewText!: string | undefined;
    body!: string | undefined;

    constructor(data?: IGetTemplateReponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.subject = _data["subject"];
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.previewText = _data["previewText"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): GetTemplateReponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplateReponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["subject"] = this.subject;
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["previewText"] = this.previewText;
        data["body"] = this.body;
        return data;
    }
}

export interface IGetTemplateReponse {
    name: string | undefined;
    type: EmailTemplateType;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    previewText: string | undefined;
    body: string | undefined;
}

export class GetTemplatesResponse implements IGetTemplatesResponse {
    id!: number;
    name!: string | undefined;

    constructor(data?: IGetTemplatesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetTemplatesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplatesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetTemplatesResponse {
    id: number;
    name: string | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetTotalsOutput implements IGetTotalsOutput {
    newLeadCount!: number;
    newClientCount!: number;
    newOrderAmount!: number;
    totalLeadCount!: number;
    totalClientCount!: number;
    totalOrderAmount!: number;

    constructor(data?: IGetTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newLeadCount = _data["newLeadCount"];
            this.newClientCount = _data["newClientCount"];
            this.newOrderAmount = _data["newOrderAmount"];
            this.totalLeadCount = _data["totalLeadCount"];
            this.totalClientCount = _data["totalClientCount"];
            this.totalOrderAmount = _data["totalOrderAmount"];
        }
    }

    static fromJS(data: any): GetTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newLeadCount"] = this.newLeadCount;
        data["newClientCount"] = this.newClientCount;
        data["newOrderAmount"] = this.newOrderAmount;
        data["totalLeadCount"] = this.totalLeadCount;
        data["totalClientCount"] = this.totalClientCount;
        data["totalOrderAmount"] = this.totalOrderAmount;
        return data;
    }
}

export interface IGetTotalsOutput {
    newLeadCount: number;
    newClientCount: number;
    newOrderAmount: number;
    totalLeadCount: number;
    totalClientCount: number;
    totalOrderAmount: number;
}

export class GetTransactionAttributeTypesOutput implements IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes!: { [key: string]: TransactionAttributeTypeDto; } | undefined;

    constructor(data?: IGetTransactionAttributeTypesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["transactionAttributeTypes"]) {
                this.transactionAttributeTypes = {} as any;
                for (let key in _data["transactionAttributeTypes"]) {
                    if (_data["transactionAttributeTypes"].hasOwnProperty(key))
                        (<any>this.transactionAttributeTypes)![key] = _data["transactionAttributeTypes"][key] ? TransactionAttributeTypeDto.fromJS(_data["transactionAttributeTypes"][key]) : new TransactionAttributeTypeDto();
                }
            }
        }
    }

    static fromJS(data: any): GetTransactionAttributeTypesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionAttributeTypesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionAttributeTypes) {
            data["transactionAttributeTypes"] = {};
            for (let key in this.transactionAttributeTypes) {
                if (this.transactionAttributeTypes.hasOwnProperty(key))
                    (<any>data["transactionAttributeTypes"])[key] = this.transactionAttributeTypes[key] ? this.transactionAttributeTypes[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes: { [key: string]: TransactionAttributeTypeDto; } | undefined;
}

export class GetTransactionCommonDetailsInput implements IGetTransactionCommonDetailsInput {
    transactionIds!: number[] | undefined;

    constructor(data?: IGetTransactionCommonDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transactionIds"])) {
                this.transactionIds = [] as any;
                for (let item of _data["transactionIds"])
                    this.transactionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTransactionCommonDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionCommonDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transactionIds)) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data;
    }
}

export interface IGetTransactionCommonDetailsInput {
    transactionIds: number[] | undefined;
}

export class GetTransactionDetailsOutput implements IGetTransactionDetailsOutput {
    transactionDetails!: TransactionDetailsDto | undefined;

    constructor(data?: IGetTransactionDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionDetails = _data["transactionDetails"] ? TransactionDetailsDto.fromJS(_data["transactionDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransactionDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionDetails"] = this.transactionDetails ? this.transactionDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetTransactionDetailsOutput {
    transactionDetails: TransactionDetailsDto | undefined;
}

export class GetUrlOutput implements IGetUrlOutput {
    url!: string | undefined;
    validityPeriodSeconds!: number;

    constructor(data?: IGetUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.validityPeriodSeconds = _data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data;
    }
}

export interface IGetUrlOutput {
    url: string | undefined;
    validityPeriodSeconds: number;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverTime = _data["serverTime"] ? moment(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserInstanceInfoOutput implements IGetUserInstanceInfoOutput {
    id!: number | undefined;
    status!: InstanceStatus;

    constructor(data?: IGetUserInstanceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetUserInstanceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserInstanceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetUserInstanceInfoOutput {
    id: number | undefined;
    status: InstanceStatus;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUserRankOutput implements IGetUserRankOutput {
    rank!: number | undefined;
    generationDate!: moment.Moment;

    constructor(data?: IGetUserRankOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rank = _data["rank"];
            this.generationDate = _data["generationDate"] ? moment(_data["generationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserRankOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserRankOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["generationDate"] = this.generationDate ? this.generationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetUserRankOutput {
    rank: number | undefined;
    generationDate: moment.Moment;
}

export class GetUsersInfoDto implements IGetUsersInfoDto {
    userId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    startDate!: moment.Moment;

    constructor(data?: IGetUsersInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUsersInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetUsersInfoDto {
    userId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    startDate: moment.Moment;
}

export class GetUserTotalsOutput implements IGetUserTotalsOutput {
    totalCount!: number;
    lastCrackedCode!: string | undefined;

    constructor(data?: IGetUserTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.lastCrackedCode = _data["lastCrackedCode"];
        }
    }

    static fromJS(data: any): GetUserTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["lastCrackedCode"] = this.lastCrackedCode;
        return data;
    }
}

export interface IGetUserTotalsOutput {
    totalCount: number;
    lastCrackedCode: string | undefined;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    userInfoEndpoint!: string | undefined;

    constructor(data?: IGoogleExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.userInfoEndpoint = _data["userInfoEndpoint"];
        }
    }

    static fromJS(data: any): GoogleExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["userInfoEndpoint"] = this.userInfoEndpoint;
        return data;
    }
}

export interface IGoogleExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    userInfoEndpoint: string | undefined;
}

export class GrantPermissionInput implements IGrantPermissionInput {
    id!: number;
    permissionName!: string;

    constructor(data?: IGrantPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): GrantPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionName"] = this.permissionName;
        return data;
    }
}

export interface IGrantPermissionInput {
    id: number;
    permissionName: string;
}

export enum GroupByPeriod {
    Daily = "Daily",
    Weekly = "Weekly",
    Monthly = "Monthly",
    Quarterly = "Quarterly",
    Yearly = "Yearly",
}

export enum HeatingCoolingType {
    Electric = "Electric",
    Gas = "Gas",
    Water = "Water",
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    bugsnag!: BugsnagSettingsDto | undefined;
    otherSettings!: OtherSettingsEditDto | undefined;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.bugsnag = _data["bugsnag"] ? BugsnagSettingsDto.fromJS(_data["bugsnag"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["bugsnag"] = this.bugsnag ? this.bugsnag.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    bugsnag: BugsnagSettingsDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto | undefined;
    customWelcomeEmailTemplates!: CustomWelcomeTemplate[] | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
            if (Array.isArray(_data["customWelcomeEmailTemplates"])) {
                this.customWelcomeEmailTemplates = [] as any;
                for (let item of _data["customWelcomeEmailTemplates"])
                    this.customWelcomeEmailTemplates!.push(CustomWelcomeTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        if (Array.isArray(this.customWelcomeEmailTemplates)) {
            data["customWelcomeEmailTemplates"] = [];
            for (let item of this.customWelcomeEmailTemplates)
                data["customWelcomeEmailTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto | undefined;
    customWelcomeEmailTemplates: CustomWelcomeTemplate[] | undefined;
}

export class IAgeSettingsEditDto implements IIAgeSettingsEditDto {
    apiKey!: string | undefined;
    activationEmailId!: number | undefined;
    passwordResetEmailId!: number | undefined;
    isEnabled!: boolean;
    offerAnnouncementEmailId!: number | undefined;

    constructor(data?: IIAgeSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.activationEmailId = _data["activationEmailId"];
            this.passwordResetEmailId = _data["passwordResetEmailId"];
            this.isEnabled = _data["isEnabled"];
            this.offerAnnouncementEmailId = _data["offerAnnouncementEmailId"];
        }
    }

    static fromJS(data: any): IAgeSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new IAgeSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["activationEmailId"] = this.activationEmailId;
        data["passwordResetEmailId"] = this.passwordResetEmailId;
        data["isEnabled"] = this.isEnabled;
        data["offerAnnouncementEmailId"] = this.offerAnnouncementEmailId;
        return data;
    }
}

export interface IIAgeSettingsEditDto {
    apiKey: string | undefined;
    activationEmailId: number | undefined;
    passwordResetEmailId: number | undefined;
    isEnabled: boolean;
    offerAnnouncementEmailId: number | undefined;
}

export class IdcsSettings implements IIdcsSettings {
    requestSource!: string | undefined;
    partnerCode!: string | undefined;
    partnerAccount!: string | undefined;
    password!: string | undefined;
    branding!: string | undefined;

    constructor(data?: IIdcsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestSource = _data["requestSource"];
            this.partnerCode = _data["partnerCode"];
            this.partnerAccount = _data["partnerAccount"];
            this.password = _data["password"];
            this.branding = _data["branding"];
        }
    }

    static fromJS(data: any): IdcsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new IdcsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestSource"] = this.requestSource;
        data["partnerCode"] = this.partnerCode;
        data["partnerAccount"] = this.partnerAccount;
        data["password"] = this.password;
        data["branding"] = this.branding;
        return data;
    }
}

export interface IIdcsSettings {
    requestSource: string | undefined;
    partnerCode: string | undefined;
    partnerAccount: string | undefined;
    password: string | undefined;
    branding: string | undefined;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    userId!: number;
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    shouldVerifyEmail!: boolean;
    userEmail!: string | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.shouldVerifyEmail = _data["shouldVerifyEmail"];
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["shouldVerifyEmail"] = this.shouldVerifyEmail;
        data["userEmail"] = this.userEmail;
        return data;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    userId: number;
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    shouldVerifyEmail: boolean;
    userEmail: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class ImportAddressInput implements IImportAddressInput {
    street!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    stateName!: string | undefined;
    stateId!: string | undefined;
    neighborhood!: string | undefined;
    zip!: string | undefined;
    countryName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IImportAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.street = _data["street"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.stateName = _data["stateName"];
            this.stateId = _data["stateId"];
            this.neighborhood = _data["neighborhood"];
            this.zip = _data["zip"];
            this.countryName = _data["countryName"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ImportAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["stateName"] = this.stateName;
        data["stateId"] = this.stateId;
        data["neighborhood"] = this.neighborhood;
        data["zip"] = this.zip;
        data["countryName"] = this.countryName;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IImportAddressInput {
    street: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    stateName: string | undefined;
    stateId: string | undefined;
    neighborhood: string | undefined;
    zip: string | undefined;
    countryName: string | undefined;
    countryId: string | undefined;
}

export class ImportBusinessInput implements IImportBusinessInput {
    companyName!: string | undefined;
    organizationType!: string | undefined;
    jobTitle!: string | undefined;
    isEmployed!: boolean | undefined;
    employmentStartDate!: moment.Moment | undefined;
    employeeCount!: number | undefined;
    dateFounded!: moment.Moment | undefined;
    ein!: string | undefined;
    annualRevenue!: number | undefined;
    industry!: string | undefined;
    companyPhone!: string | undefined;
    companyPhoneExt!: string | undefined;
    companyFaxNumber!: string | undefined;
    companyEmail!: string | undefined;
    companyFullAddress!: ImportAddressInput | undefined;
    companyWebSiteUrl!: string | undefined;
    companyFacebookUrl!: string | undefined;
    companyLinkedInUrl!: string | undefined;
    companyInstagramUrl!: string | undefined;
    companyTwitterUrl!: string | undefined;
    companyGooglePlusUrl!: string | undefined;
    companyCrunchbaseUrl!: string | undefined;
    companyBBBUrl!: string | undefined;
    companyPinterestUrl!: string | undefined;
    companyDomainUrl!: string | undefined;
    companyAlexaUrl!: string | undefined;
    companyOpenCorporatesUrl!: string | undefined;
    companyGlassDoorUrl!: string | undefined;
    companyTrustpilotUrl!: string | undefined;
    companyFollowersUrl!: string | undefined;
    companyYoutubeUrl!: string | undefined;
    companyYelpUrl!: string | undefined;
    companyRSSUrl!: string | undefined;
    companyNavUrl!: string | undefined;
    companyAngelListUrl!: string | undefined;
    companyCalendlyUrl!: string | undefined;
    companyZoomUrl!: string | undefined;
    companyOtherLinkUrl!: string | undefined;
    companyLogoUrl!: string | undefined;
    workPhone1!: string | undefined;
    workPhone1Ext!: string | undefined;
    workPhone2!: string | undefined;
    workPhone2Ext!: string | undefined;
    workEmail1!: string | undefined;
    workEmail2!: string | undefined;
    workEmail3!: string | undefined;
    workFullAddress!: ImportAddressInput | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: IImportBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.organizationType = _data["organizationType"];
            this.jobTitle = _data["jobTitle"];
            this.isEmployed = _data["isEmployed"];
            this.employmentStartDate = _data["employmentStartDate"] ? moment(_data["employmentStartDate"].toString()) : <any>undefined;
            this.employeeCount = _data["employeeCount"];
            this.dateFounded = _data["dateFounded"] ? moment(_data["dateFounded"].toString()) : <any>undefined;
            this.ein = _data["ein"];
            this.annualRevenue = _data["annualRevenue"];
            this.industry = _data["industry"];
            this.companyPhone = _data["companyPhone"];
            this.companyPhoneExt = _data["companyPhoneExt"];
            this.companyFaxNumber = _data["companyFaxNumber"];
            this.companyEmail = _data["companyEmail"];
            this.companyFullAddress = _data["companyFullAddress"] ? ImportAddressInput.fromJS(_data["companyFullAddress"]) : <any>undefined;
            this.companyWebSiteUrl = _data["companyWebSiteUrl"];
            this.companyFacebookUrl = _data["companyFacebookUrl"];
            this.companyLinkedInUrl = _data["companyLinkedInUrl"];
            this.companyInstagramUrl = _data["companyInstagramUrl"];
            this.companyTwitterUrl = _data["companyTwitterUrl"];
            this.companyGooglePlusUrl = _data["companyGooglePlusUrl"];
            this.companyCrunchbaseUrl = _data["companyCrunchbaseUrl"];
            this.companyBBBUrl = _data["companyBBBUrl"];
            this.companyPinterestUrl = _data["companyPinterestUrl"];
            this.companyDomainUrl = _data["companyDomainUrl"];
            this.companyAlexaUrl = _data["companyAlexaUrl"];
            this.companyOpenCorporatesUrl = _data["companyOpenCorporatesUrl"];
            this.companyGlassDoorUrl = _data["companyGlassDoorUrl"];
            this.companyTrustpilotUrl = _data["companyTrustpilotUrl"];
            this.companyFollowersUrl = _data["companyFollowersUrl"];
            this.companyYoutubeUrl = _data["companyYoutubeUrl"];
            this.companyYelpUrl = _data["companyYelpUrl"];
            this.companyRSSUrl = _data["companyRSSUrl"];
            this.companyNavUrl = _data["companyNavUrl"];
            this.companyAngelListUrl = _data["companyAngelListUrl"];
            this.companyCalendlyUrl = _data["companyCalendlyUrl"];
            this.companyZoomUrl = _data["companyZoomUrl"];
            this.companyOtherLinkUrl = _data["companyOtherLinkUrl"];
            this.companyLogoUrl = _data["companyLogoUrl"];
            this.workPhone1 = _data["workPhone1"];
            this.workPhone1Ext = _data["workPhone1Ext"];
            this.workPhone2 = _data["workPhone2"];
            this.workPhone2Ext = _data["workPhone2Ext"];
            this.workEmail1 = _data["workEmail1"];
            this.workEmail2 = _data["workEmail2"];
            this.workEmail3 = _data["workEmail3"];
            this.workFullAddress = _data["workFullAddress"] ? ImportAddressInput.fromJS(_data["workFullAddress"]) : <any>undefined;
            this.affiliateCode = _data["affiliateCode"];
        }
    }

    static fromJS(data: any): ImportBusinessInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["organizationType"] = this.organizationType;
        data["jobTitle"] = this.jobTitle;
        data["isEmployed"] = this.isEmployed;
        data["employmentStartDate"] = this.employmentStartDate ? this.employmentStartDate.toISOString() : <any>undefined;
        data["employeeCount"] = this.employeeCount;
        data["dateFounded"] = this.dateFounded ? this.dateFounded.toISOString() : <any>undefined;
        data["ein"] = this.ein;
        data["annualRevenue"] = this.annualRevenue;
        data["industry"] = this.industry;
        data["companyPhone"] = this.companyPhone;
        data["companyPhoneExt"] = this.companyPhoneExt;
        data["companyFaxNumber"] = this.companyFaxNumber;
        data["companyEmail"] = this.companyEmail;
        data["companyFullAddress"] = this.companyFullAddress ? this.companyFullAddress.toJSON() : <any>undefined;
        data["companyWebSiteUrl"] = this.companyWebSiteUrl;
        data["companyFacebookUrl"] = this.companyFacebookUrl;
        data["companyLinkedInUrl"] = this.companyLinkedInUrl;
        data["companyInstagramUrl"] = this.companyInstagramUrl;
        data["companyTwitterUrl"] = this.companyTwitterUrl;
        data["companyGooglePlusUrl"] = this.companyGooglePlusUrl;
        data["companyCrunchbaseUrl"] = this.companyCrunchbaseUrl;
        data["companyBBBUrl"] = this.companyBBBUrl;
        data["companyPinterestUrl"] = this.companyPinterestUrl;
        data["companyDomainUrl"] = this.companyDomainUrl;
        data["companyAlexaUrl"] = this.companyAlexaUrl;
        data["companyOpenCorporatesUrl"] = this.companyOpenCorporatesUrl;
        data["companyGlassDoorUrl"] = this.companyGlassDoorUrl;
        data["companyTrustpilotUrl"] = this.companyTrustpilotUrl;
        data["companyFollowersUrl"] = this.companyFollowersUrl;
        data["companyYoutubeUrl"] = this.companyYoutubeUrl;
        data["companyYelpUrl"] = this.companyYelpUrl;
        data["companyRSSUrl"] = this.companyRSSUrl;
        data["companyNavUrl"] = this.companyNavUrl;
        data["companyAngelListUrl"] = this.companyAngelListUrl;
        data["companyCalendlyUrl"] = this.companyCalendlyUrl;
        data["companyZoomUrl"] = this.companyZoomUrl;
        data["companyOtherLinkUrl"] = this.companyOtherLinkUrl;
        data["companyLogoUrl"] = this.companyLogoUrl;
        data["workPhone1"] = this.workPhone1;
        data["workPhone1Ext"] = this.workPhone1Ext;
        data["workPhone2"] = this.workPhone2;
        data["workPhone2Ext"] = this.workPhone2Ext;
        data["workEmail1"] = this.workEmail1;
        data["workEmail2"] = this.workEmail2;
        data["workEmail3"] = this.workEmail3;
        data["workFullAddress"] = this.workFullAddress ? this.workFullAddress.toJSON() : <any>undefined;
        data["affiliateCode"] = this.affiliateCode;
        return data;
    }
}

export interface IImportBusinessInput {
    companyName: string | undefined;
    organizationType: string | undefined;
    jobTitle: string | undefined;
    isEmployed: boolean | undefined;
    employmentStartDate: moment.Moment | undefined;
    employeeCount: number | undefined;
    dateFounded: moment.Moment | undefined;
    ein: string | undefined;
    annualRevenue: number | undefined;
    industry: string | undefined;
    companyPhone: string | undefined;
    companyPhoneExt: string | undefined;
    companyFaxNumber: string | undefined;
    companyEmail: string | undefined;
    companyFullAddress: ImportAddressInput | undefined;
    companyWebSiteUrl: string | undefined;
    companyFacebookUrl: string | undefined;
    companyLinkedInUrl: string | undefined;
    companyInstagramUrl: string | undefined;
    companyTwitterUrl: string | undefined;
    companyGooglePlusUrl: string | undefined;
    companyCrunchbaseUrl: string | undefined;
    companyBBBUrl: string | undefined;
    companyPinterestUrl: string | undefined;
    companyDomainUrl: string | undefined;
    companyAlexaUrl: string | undefined;
    companyOpenCorporatesUrl: string | undefined;
    companyGlassDoorUrl: string | undefined;
    companyTrustpilotUrl: string | undefined;
    companyFollowersUrl: string | undefined;
    companyYoutubeUrl: string | undefined;
    companyYelpUrl: string | undefined;
    companyRSSUrl: string | undefined;
    companyNavUrl: string | undefined;
    companyAngelListUrl: string | undefined;
    companyCalendlyUrl: string | undefined;
    companyZoomUrl: string | undefined;
    companyOtherLinkUrl: string | undefined;
    companyLogoUrl: string | undefined;
    workPhone1: string | undefined;
    workPhone1Ext: string | undefined;
    workPhone2: string | undefined;
    workPhone2Ext: string | undefined;
    workEmail1: string | undefined;
    workEmail2: string | undefined;
    workEmail3: string | undefined;
    workFullAddress: ImportAddressInput | undefined;
    affiliateCode: string | undefined;
}

export class ImportClassificationInput implements IImportClassificationInput {
    rating!: string | undefined;
    lists!: string[] | undefined;
    tags!: string[] | undefined;
    partnerTypeName!: string | undefined;

    constructor(data?: IImportClassificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rating = _data["rating"];
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(item);
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.partnerTypeName = _data["partnerTypeName"];
        }
    }

    static fromJS(data: any): ImportClassificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportClassificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rating"] = this.rating;
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["partnerTypeName"] = this.partnerTypeName;
        return data;
    }
}

export interface IImportClassificationInput {
    rating: string | undefined;
    lists: string[] | undefined;
    tags: string[] | undefined;
    partnerTypeName: string | undefined;
}

export class ImportContactInput implements IImportContactInput {
    star!: string | undefined;
    importType!: ImportTypeInput;
    ignoreInvalidValues!: boolean;
    matchExisting!: boolean | undefined;
    overrideLists!: boolean;
    createUser!: boolean;
    sendWelcomeEmail!: boolean;
    welcomeEmailTemplateRef!: string | undefined;
    contactId!: number | undefined;
    contactXref!: string | undefined;
    userPassword!: string | undefined;
    personalInfo!: ImportPersonalInput | undefined;
    businessInfo!: ImportBusinessInput | undefined;
    propertyInfo!: ImportPropertyInput | undefined;
    assignedUser!: string | undefined;
    followUpDate!: moment.Moment | undefined;
    notes!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    leadStageName!: string | undefined;
    leadSource!: string | undefined;
    leadDealAmount!: number | undefined;
    affiliateCode!: string | undefined;
    campaignId!: string | undefined;
    channelId!: string | undefined;
    gclId!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    utmSource!: string | undefined;
    utmMedium!: string | undefined;
    utmCampaign!: string | undefined;
    utmTerm!: string | undefined;
    utmContent!: string | undefined;
    utmKeyword!: string | undefined;
    utmAdGroup!: string | undefined;
    utmName!: string | undefined;
    requestCustomInfo!: CustomFieldsInput | undefined;
    subscription1!: ImportSubscriptionInput | undefined;
    subscription2!: ImportSubscriptionInput | undefined;
    subscription3!: ImportSubscriptionInput | undefined;
    subscription4!: ImportSubscriptionInput | undefined;
    subscription5!: ImportSubscriptionInput | undefined;
    classificationInfo!: ImportClassificationInput | undefined;

    constructor(data?: IImportContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.overrideLists = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.star = _data["star"];
            this.importType = _data["importType"];
            this.ignoreInvalidValues = _data["ignoreInvalidValues"];
            this.matchExisting = _data["matchExisting"];
            this.overrideLists = _data["overrideLists"] !== undefined ? _data["overrideLists"] : false;
            this.createUser = _data["createUser"];
            this.sendWelcomeEmail = _data["sendWelcomeEmail"];
            this.welcomeEmailTemplateRef = _data["welcomeEmailTemplateRef"];
            this.contactId = _data["contactId"];
            this.contactXref = _data["contactXref"];
            this.userPassword = _data["userPassword"];
            this.personalInfo = _data["personalInfo"] ? ImportPersonalInput.fromJS(_data["personalInfo"]) : <any>undefined;
            this.businessInfo = _data["businessInfo"] ? ImportBusinessInput.fromJS(_data["businessInfo"]) : <any>undefined;
            this.propertyInfo = _data["propertyInfo"] ? ImportPropertyInput.fromJS(_data["propertyInfo"]) : <any>undefined;
            this.assignedUser = _data["assignedUser"];
            this.followUpDate = _data["followUpDate"] ? moment(_data["followUpDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.dateCreated = _data["dateCreated"] ? moment(_data["dateCreated"].toString()) : <any>undefined;
            this.leadStageName = _data["leadStageName"];
            this.leadSource = _data["leadSource"];
            this.leadDealAmount = _data["leadDealAmount"];
            this.affiliateCode = _data["affiliateCode"];
            this.campaignId = _data["campaignId"];
            this.channelId = _data["channelId"];
            this.gclId = _data["gclId"];
            this.refererUrl = _data["refererUrl"];
            this.entryUrl = _data["entryUrl"];
            this.applicantId = _data["applicantId"];
            this.applicationId = _data["applicationId"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
            this.siteId = _data["siteId"];
            this.siteUrl = _data["siteUrl"];
            this.utmSource = _data["utmSource"];
            this.utmMedium = _data["utmMedium"];
            this.utmCampaign = _data["utmCampaign"];
            this.utmTerm = _data["utmTerm"];
            this.utmContent = _data["utmContent"];
            this.utmKeyword = _data["utmKeyword"];
            this.utmAdGroup = _data["utmAdGroup"];
            this.utmName = _data["utmName"];
            this.requestCustomInfo = _data["requestCustomInfo"] ? CustomFieldsInput.fromJS(_data["requestCustomInfo"]) : <any>undefined;
            this.subscription1 = _data["subscription1"] ? ImportSubscriptionInput.fromJS(_data["subscription1"]) : <any>undefined;
            this.subscription2 = _data["subscription2"] ? ImportSubscriptionInput.fromJS(_data["subscription2"]) : <any>undefined;
            this.subscription3 = _data["subscription3"] ? ImportSubscriptionInput.fromJS(_data["subscription3"]) : <any>undefined;
            this.subscription4 = _data["subscription4"] ? ImportSubscriptionInput.fromJS(_data["subscription4"]) : <any>undefined;
            this.subscription5 = _data["subscription5"] ? ImportSubscriptionInput.fromJS(_data["subscription5"]) : <any>undefined;
            this.classificationInfo = _data["classificationInfo"] ? ImportClassificationInput.fromJS(_data["classificationInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["star"] = this.star;
        data["importType"] = this.importType;
        data["ignoreInvalidValues"] = this.ignoreInvalidValues;
        data["matchExisting"] = this.matchExisting;
        data["overrideLists"] = this.overrideLists;
        data["createUser"] = this.createUser;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["userPassword"] = this.userPassword;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        data["businessInfo"] = this.businessInfo ? this.businessInfo.toJSON() : <any>undefined;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["assignedUser"] = this.assignedUser;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["leadStageName"] = this.leadStageName;
        data["leadSource"] = this.leadSource;
        data["leadDealAmount"] = this.leadDealAmount;
        data["affiliateCode"] = this.affiliateCode;
        data["campaignId"] = this.campaignId;
        data["channelId"] = this.channelId;
        data["gclId"] = this.gclId;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["utmSource"] = this.utmSource;
        data["utmMedium"] = this.utmMedium;
        data["utmCampaign"] = this.utmCampaign;
        data["utmTerm"] = this.utmTerm;
        data["utmContent"] = this.utmContent;
        data["utmKeyword"] = this.utmKeyword;
        data["utmAdGroup"] = this.utmAdGroup;
        data["utmName"] = this.utmName;
        data["requestCustomInfo"] = this.requestCustomInfo ? this.requestCustomInfo.toJSON() : <any>undefined;
        data["subscription1"] = this.subscription1 ? this.subscription1.toJSON() : <any>undefined;
        data["subscription2"] = this.subscription2 ? this.subscription2.toJSON() : <any>undefined;
        data["subscription3"] = this.subscription3 ? this.subscription3.toJSON() : <any>undefined;
        data["subscription4"] = this.subscription4 ? this.subscription4.toJSON() : <any>undefined;
        data["subscription5"] = this.subscription5 ? this.subscription5.toJSON() : <any>undefined;
        data["classificationInfo"] = this.classificationInfo ? this.classificationInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IImportContactInput {
    star: string | undefined;
    importType: ImportTypeInput;
    ignoreInvalidValues: boolean;
    matchExisting: boolean | undefined;
    overrideLists: boolean;
    createUser: boolean;
    sendWelcomeEmail: boolean;
    welcomeEmailTemplateRef: string | undefined;
    contactId: number | undefined;
    contactXref: string | undefined;
    userPassword: string | undefined;
    personalInfo: ImportPersonalInput | undefined;
    businessInfo: ImportBusinessInput | undefined;
    propertyInfo: ImportPropertyInput | undefined;
    assignedUser: string | undefined;
    followUpDate: moment.Moment | undefined;
    notes: string | undefined;
    dateCreated: moment.Moment | undefined;
    leadStageName: string | undefined;
    leadSource: string | undefined;
    leadDealAmount: number | undefined;
    affiliateCode: string | undefined;
    campaignId: string | undefined;
    channelId: string | undefined;
    gclId: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    utmSource: string | undefined;
    utmMedium: string | undefined;
    utmCampaign: string | undefined;
    utmTerm: string | undefined;
    utmContent: string | undefined;
    utmKeyword: string | undefined;
    utmAdGroup: string | undefined;
    utmName: string | undefined;
    requestCustomInfo: CustomFieldsInput | undefined;
    subscription1: ImportSubscriptionInput | undefined;
    subscription2: ImportSubscriptionInput | undefined;
    subscription3: ImportSubscriptionInput | undefined;
    subscription4: ImportSubscriptionInput | undefined;
    subscription5: ImportSubscriptionInput | undefined;
    classificationInfo: ImportClassificationInput | undefined;
}

export class ImportExtensionDto implements IImportExtensionDto {
    code!: string;
    name!: string;
    description!: string | undefined;
    category!: string;
    logo!: string | undefined;
    url!: string | undefined;
    rank!: number | undefined;

    constructor(data?: IImportExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.logo = _data["logo"];
            this.url = _data["url"];
            this.rank = _data["rank"];
        }
    }

    static fromJS(data: any): ImportExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["logo"] = this.logo;
        data["url"] = this.url;
        data["rank"] = this.rank;
        return data;
    }
}

export interface IImportExtensionDto {
    code: string;
    name: string;
    description: string | undefined;
    category: string;
    logo: string | undefined;
    url: string | undefined;
    rank: number | undefined;
}

export class ImportFieldInfoDto implements IImportFieldInfoDto {
    inputFieldName!: string;
    outputFieldName!: string;

    constructor(data?: IImportFieldInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inputFieldName = _data["inputFieldName"];
            this.outputFieldName = _data["outputFieldName"];
        }
    }

    static fromJS(data: any): ImportFieldInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFieldInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputFieldName"] = this.inputFieldName;
        data["outputFieldName"] = this.outputFieldName;
        return data;
    }
}

export interface IImportFieldInfoDto {
    inputFieldName: string;
    outputFieldName: string;
}

export class ImportForecastInput implements IImportForecastInput {
    forecastDate!: moment.Moment;
    entity!: string;
    type!: ImportForecastInputType;
    categoryCoAId!: string | undefined;
    descriptor!: string | undefined;
    description!: string | undefined;
    model!: string | undefined;
    currencyId!: string;
    amount!: number;
    readonly cashFlowTypeId!: string | undefined;

    constructor(data?: IImportForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.forecastDate = _data["forecastDate"] ? moment(_data["forecastDate"].toString()) : <any>undefined;
            this.entity = _data["entity"];
            this.type = _data["type"];
            this.categoryCoAId = _data["categoryCoAId"];
            this.descriptor = _data["descriptor"];
            this.description = _data["description"];
            this.model = _data["model"];
            this.currencyId = _data["currencyId"];
            this.amount = _data["amount"];
            (<any>this).cashFlowTypeId = _data["cashFlowTypeId"];
        }
    }

    static fromJS(data: any): ImportForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastDate"] = this.forecastDate ? this.forecastDate.toISOString() : <any>undefined;
        data["entity"] = this.entity;
        data["type"] = this.type;
        data["categoryCoAId"] = this.categoryCoAId;
        data["descriptor"] = this.descriptor;
        data["description"] = this.description;
        data["model"] = this.model;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        return data;
    }
}

export interface IImportForecastInput {
    forecastDate: moment.Moment;
    entity: string;
    type: ImportForecastInputType;
    categoryCoAId: string | undefined;
    descriptor: string | undefined;
    description: string | undefined;
    model: string | undefined;
    currencyId: string;
    amount: number;
    cashFlowTypeId: string | undefined;
}

export enum ImportForecastInputType {
    Inflows = "Inflows",
    Outflows = "Outflows",
}

export class ImportFullName implements IImportFullName {
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;

    constructor(data?: IImportFullName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.namePrefix = _data["namePrefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
        }
    }

    static fromJS(data: any): ImportFullName {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFullName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        return data;
    }
}

export interface IImportFullName {
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
}

export class ImportInput implements IImportInput {
    items!: ImportItemInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    tags!: ContactTagInput[] | undefined;
    fields!: ImportFieldInfoDto[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    starId!: number | undefined;
    leadStageId!: number | undefined;
    importType!: ImportTypeInput;
    partnerTypeName!: string | undefined;
    fileName!: string;
    fileSize!: number;
    fileContent!: string;
    ignoreInvalidValues!: boolean;
    sendWelcomeEmail!: boolean;
    welcomeEmailTemplateRef!: string | undefined;

    constructor(data?: IImportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ImportItemInput.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ContactListInput.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ContactTagInput.fromJS(item));
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ImportFieldInfoDto.fromJS(item));
            }
            this.assignedUserId = _data["assignedUserId"];
            this.ratingId = _data["ratingId"];
            this.starId = _data["starId"];
            this.leadStageId = _data["leadStageId"];
            this.importType = _data["importType"];
            this.partnerTypeName = _data["partnerTypeName"];
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.fileContent = _data["fileContent"];
            this.ignoreInvalidValues = _data["ignoreInvalidValues"];
            this.sendWelcomeEmail = _data["sendWelcomeEmail"];
            this.welcomeEmailTemplateRef = _data["welcomeEmailTemplateRef"];
        }
    }

    static fromJS(data: any): ImportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["starId"] = this.starId;
        data["leadStageId"] = this.leadStageId;
        data["importType"] = this.importType;
        data["partnerTypeName"] = this.partnerTypeName;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["fileContent"] = this.fileContent;
        data["ignoreInvalidValues"] = this.ignoreInvalidValues;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        return data;
    }
}

export interface IImportInput {
    items: ImportItemInput[] | undefined;
    lists: ContactListInput[] | undefined;
    tags: ContactTagInput[] | undefined;
    fields: ImportFieldInfoDto[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    starId: number | undefined;
    leadStageId: number | undefined;
    importType: ImportTypeInput;
    partnerTypeName: string | undefined;
    fileName: string;
    fileSize: number;
    fileContent: string;
    ignoreInvalidValues: boolean;
    sendWelcomeEmail: boolean;
    welcomeEmailTemplateRef: string | undefined;
}

export class ImportItemInput implements IImportItemInput {
    contactId!: number | undefined;
    contactXref!: string | undefined;
    userPassword!: string | undefined;
    personalInfo!: ImportPersonalInput | undefined;
    businessInfo!: ImportBusinessInput | undefined;
    propertyInfo!: ImportPropertyInput | undefined;
    assignedUser!: string | undefined;
    followUpDate!: moment.Moment | undefined;
    notes!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    leadStageName!: string | undefined;
    leadSource!: string | undefined;
    leadDealAmount!: number | undefined;
    affiliateCode!: string | undefined;
    campaignId!: string | undefined;
    channelId!: string | undefined;
    gclId!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    utmSource!: string | undefined;
    utmMedium!: string | undefined;
    utmCampaign!: string | undefined;
    utmTerm!: string | undefined;
    utmContent!: string | undefined;
    utmKeyword!: string | undefined;
    utmAdGroup!: string | undefined;
    utmName!: string | undefined;
    requestCustomInfo!: CustomFieldsInput | undefined;
    subscription1!: ImportSubscriptionInput | undefined;
    subscription2!: ImportSubscriptionInput | undefined;
    subscription3!: ImportSubscriptionInput | undefined;
    subscription4!: ImportSubscriptionInput | undefined;
    subscription5!: ImportSubscriptionInput | undefined;
    classificationInfo!: ImportClassificationInput | undefined;

    constructor(data?: IImportItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.contactXref = _data["contactXref"];
            this.userPassword = _data["userPassword"];
            this.personalInfo = _data["personalInfo"] ? ImportPersonalInput.fromJS(_data["personalInfo"]) : <any>undefined;
            this.businessInfo = _data["businessInfo"] ? ImportBusinessInput.fromJS(_data["businessInfo"]) : <any>undefined;
            this.propertyInfo = _data["propertyInfo"] ? ImportPropertyInput.fromJS(_data["propertyInfo"]) : <any>undefined;
            this.assignedUser = _data["assignedUser"];
            this.followUpDate = _data["followUpDate"] ? moment(_data["followUpDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.dateCreated = _data["dateCreated"] ? moment(_data["dateCreated"].toString()) : <any>undefined;
            this.leadStageName = _data["leadStageName"];
            this.leadSource = _data["leadSource"];
            this.leadDealAmount = _data["leadDealAmount"];
            this.affiliateCode = _data["affiliateCode"];
            this.campaignId = _data["campaignId"];
            this.channelId = _data["channelId"];
            this.gclId = _data["gclId"];
            this.refererUrl = _data["refererUrl"];
            this.entryUrl = _data["entryUrl"];
            this.applicantId = _data["applicantId"];
            this.applicationId = _data["applicationId"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
            this.siteId = _data["siteId"];
            this.siteUrl = _data["siteUrl"];
            this.utmSource = _data["utmSource"];
            this.utmMedium = _data["utmMedium"];
            this.utmCampaign = _data["utmCampaign"];
            this.utmTerm = _data["utmTerm"];
            this.utmContent = _data["utmContent"];
            this.utmKeyword = _data["utmKeyword"];
            this.utmAdGroup = _data["utmAdGroup"];
            this.utmName = _data["utmName"];
            this.requestCustomInfo = _data["requestCustomInfo"] ? CustomFieldsInput.fromJS(_data["requestCustomInfo"]) : <any>undefined;
            this.subscription1 = _data["subscription1"] ? ImportSubscriptionInput.fromJS(_data["subscription1"]) : <any>undefined;
            this.subscription2 = _data["subscription2"] ? ImportSubscriptionInput.fromJS(_data["subscription2"]) : <any>undefined;
            this.subscription3 = _data["subscription3"] ? ImportSubscriptionInput.fromJS(_data["subscription3"]) : <any>undefined;
            this.subscription4 = _data["subscription4"] ? ImportSubscriptionInput.fromJS(_data["subscription4"]) : <any>undefined;
            this.subscription5 = _data["subscription5"] ? ImportSubscriptionInput.fromJS(_data["subscription5"]) : <any>undefined;
            this.classificationInfo = _data["classificationInfo"] ? ImportClassificationInput.fromJS(_data["classificationInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["userPassword"] = this.userPassword;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        data["businessInfo"] = this.businessInfo ? this.businessInfo.toJSON() : <any>undefined;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["assignedUser"] = this.assignedUser;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["leadStageName"] = this.leadStageName;
        data["leadSource"] = this.leadSource;
        data["leadDealAmount"] = this.leadDealAmount;
        data["affiliateCode"] = this.affiliateCode;
        data["campaignId"] = this.campaignId;
        data["channelId"] = this.channelId;
        data["gclId"] = this.gclId;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["utmSource"] = this.utmSource;
        data["utmMedium"] = this.utmMedium;
        data["utmCampaign"] = this.utmCampaign;
        data["utmTerm"] = this.utmTerm;
        data["utmContent"] = this.utmContent;
        data["utmKeyword"] = this.utmKeyword;
        data["utmAdGroup"] = this.utmAdGroup;
        data["utmName"] = this.utmName;
        data["requestCustomInfo"] = this.requestCustomInfo ? this.requestCustomInfo.toJSON() : <any>undefined;
        data["subscription1"] = this.subscription1 ? this.subscription1.toJSON() : <any>undefined;
        data["subscription2"] = this.subscription2 ? this.subscription2.toJSON() : <any>undefined;
        data["subscription3"] = this.subscription3 ? this.subscription3.toJSON() : <any>undefined;
        data["subscription4"] = this.subscription4 ? this.subscription4.toJSON() : <any>undefined;
        data["subscription5"] = this.subscription5 ? this.subscription5.toJSON() : <any>undefined;
        data["classificationInfo"] = this.classificationInfo ? this.classificationInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IImportItemInput {
    contactId: number | undefined;
    contactXref: string | undefined;
    userPassword: string | undefined;
    personalInfo: ImportPersonalInput | undefined;
    businessInfo: ImportBusinessInput | undefined;
    propertyInfo: ImportPropertyInput | undefined;
    assignedUser: string | undefined;
    followUpDate: moment.Moment | undefined;
    notes: string | undefined;
    dateCreated: moment.Moment | undefined;
    leadStageName: string | undefined;
    leadSource: string | undefined;
    leadDealAmount: number | undefined;
    affiliateCode: string | undefined;
    campaignId: string | undefined;
    channelId: string | undefined;
    gclId: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    utmSource: string | undefined;
    utmMedium: string | undefined;
    utmCampaign: string | undefined;
    utmTerm: string | undefined;
    utmContent: string | undefined;
    utmKeyword: string | undefined;
    utmAdGroup: string | undefined;
    utmName: string | undefined;
    requestCustomInfo: CustomFieldsInput | undefined;
    subscription1: ImportSubscriptionInput | undefined;
    subscription2: ImportSubscriptionInput | undefined;
    subscription3: ImportSubscriptionInput | undefined;
    subscription4: ImportSubscriptionInput | undefined;
    subscription5: ImportSubscriptionInput | undefined;
    classificationInfo: ImportClassificationInput | undefined;
}

export class ImportPersonalInput implements IImportPersonalInput {
    fullName!: ImportFullName | undefined;
    doB!: moment.Moment | undefined;
    mobilePhone!: string | undefined;
    mobilePhoneExt!: string | undefined;
    homePhone!: string | undefined;
    homePhoneExt!: string | undefined;
    phone1!: string | undefined;
    phoneExt1!: string | undefined;
    phone2!: string | undefined;
    phoneExt2!: string | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    email1!: string | undefined;
    email2!: string | undefined;
    email3!: string | undefined;
    email4!: string | undefined;
    email5!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    gender!: string | undefined;
    fullAddress!: ImportAddressInput | undefined;
    fullAddress2!: ImportAddressInput | undefined;
    fullAddress3!: ImportAddressInput | undefined;
    isUSCitizen!: boolean | undefined;
    webSiteUrl!: string | undefined;
    facebookUrl!: string | undefined;
    linkedInUrl!: string | undefined;
    instagramUrl!: string | undefined;
    twitterUrl!: string | undefined;
    googlePlusUrl!: string | undefined;
    angelListUrl!: string | undefined;
    zoomUrl!: string | undefined;
    otherLinkUrl!: string | undefined;
    photoUrl!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    interests!: string[] | undefined;
    affiliateCode!: string | undefined;
    isActive!: boolean | undefined;
    customFields!: CustomFieldsInput | undefined;

    constructor(data?: IImportPersonalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"] ? ImportFullName.fromJS(_data["fullName"]) : <any>undefined;
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"];
            this.mobilePhoneExt = _data["mobilePhoneExt"];
            this.homePhone = _data["homePhone"];
            this.homePhoneExt = _data["homePhoneExt"];
            this.phone1 = _data["phone1"];
            this.phoneExt1 = _data["phoneExt1"];
            this.phone2 = _data["phone2"];
            this.phoneExt2 = _data["phoneExt2"];
            this.ssn = _data["ssn"];
            this.bankCode = _data["bankCode"];
            this.email1 = _data["email1"];
            this.email2 = _data["email2"];
            this.email3 = _data["email3"];
            this.email4 = _data["email4"];
            this.email5 = _data["email5"];
            this.preferredToD = _data["preferredToD"];
            this.drivingLicense = _data["drivingLicense"];
            this.drivingLicenseState = _data["drivingLicenseState"];
            this.isActiveMilitaryDuty = _data["isActiveMilitaryDuty"];
            this.gender = _data["gender"];
            this.fullAddress = _data["fullAddress"] ? ImportAddressInput.fromJS(_data["fullAddress"]) : <any>undefined;
            this.fullAddress2 = _data["fullAddress2"] ? ImportAddressInput.fromJS(_data["fullAddress2"]) : <any>undefined;
            this.fullAddress3 = _data["fullAddress3"] ? ImportAddressInput.fromJS(_data["fullAddress3"]) : <any>undefined;
            this.isUSCitizen = _data["isUSCitizen"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.facebookUrl = _data["facebookUrl"];
            this.linkedInUrl = _data["linkedInUrl"];
            this.instagramUrl = _data["instagramUrl"];
            this.twitterUrl = _data["twitterUrl"];
            this.googlePlusUrl = _data["googlePlusUrl"];
            this.angelListUrl = _data["angelListUrl"];
            this.zoomUrl = _data["zoomUrl"];
            this.otherLinkUrl = _data["otherLinkUrl"];
            this.photoUrl = _data["photoUrl"];
            this.experience = _data["experience"];
            this.profileSummary = _data["profileSummary"];
            if (Array.isArray(_data["interests"])) {
                this.interests = [] as any;
                for (let item of _data["interests"])
                    this.interests!.push(item);
            }
            this.affiliateCode = _data["affiliateCode"];
            this.isActive = _data["isActive"];
            this.customFields = _data["customFields"] ? CustomFieldsInput.fromJS(_data["customFields"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportPersonalInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPersonalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName ? this.fullName.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["mobilePhoneExt"] = this.mobilePhoneExt;
        data["homePhone"] = this.homePhone;
        data["homePhoneExt"] = this.homePhoneExt;
        data["phone1"] = this.phone1;
        data["phoneExt1"] = this.phoneExt1;
        data["phone2"] = this.phone2;
        data["phoneExt2"] = this.phoneExt2;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["email1"] = this.email1;
        data["email2"] = this.email2;
        data["email3"] = this.email3;
        data["email4"] = this.email4;
        data["email5"] = this.email5;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        data["gender"] = this.gender;
        data["fullAddress"] = this.fullAddress ? this.fullAddress.toJSON() : <any>undefined;
        data["fullAddress2"] = this.fullAddress2 ? this.fullAddress2.toJSON() : <any>undefined;
        data["fullAddress3"] = this.fullAddress3 ? this.fullAddress3.toJSON() : <any>undefined;
        data["isUSCitizen"] = this.isUSCitizen;
        data["webSiteUrl"] = this.webSiteUrl;
        data["facebookUrl"] = this.facebookUrl;
        data["linkedInUrl"] = this.linkedInUrl;
        data["instagramUrl"] = this.instagramUrl;
        data["twitterUrl"] = this.twitterUrl;
        data["googlePlusUrl"] = this.googlePlusUrl;
        data["angelListUrl"] = this.angelListUrl;
        data["zoomUrl"] = this.zoomUrl;
        data["otherLinkUrl"] = this.otherLinkUrl;
        data["photoUrl"] = this.photoUrl;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        if (Array.isArray(this.interests)) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["affiliateCode"] = this.affiliateCode;
        data["isActive"] = this.isActive;
        data["customFields"] = this.customFields ? this.customFields.toJSON() : <any>undefined;
        return data;
    }
}

export interface IImportPersonalInput {
    fullName: ImportFullName | undefined;
    doB: moment.Moment | undefined;
    mobilePhone: string | undefined;
    mobilePhoneExt: string | undefined;
    homePhone: string | undefined;
    homePhoneExt: string | undefined;
    phone1: string | undefined;
    phoneExt1: string | undefined;
    phone2: string | undefined;
    phoneExt2: string | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    email1: string | undefined;
    email2: string | undefined;
    email3: string | undefined;
    email4: string | undefined;
    email5: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    gender: string | undefined;
    fullAddress: ImportAddressInput | undefined;
    fullAddress2: ImportAddressInput | undefined;
    fullAddress3: ImportAddressInput | undefined;
    isUSCitizen: boolean | undefined;
    webSiteUrl: string | undefined;
    facebookUrl: string | undefined;
    linkedInUrl: string | undefined;
    instagramUrl: string | undefined;
    twitterUrl: string | undefined;
    googlePlusUrl: string | undefined;
    angelListUrl: string | undefined;
    zoomUrl: string | undefined;
    otherLinkUrl: string | undefined;
    photoUrl: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    interests: string[] | undefined;
    affiliateCode: string | undefined;
    isActive: boolean | undefined;
    customFields: CustomFieldsInput | undefined;
}

export class ImportPropertyInput implements IImportPropertyInput {
    leadType!: string | undefined;
    name!: string | undefined;
    note!: string | undefined;
    propertyAddress!: ImportAddressInput | undefined;

    constructor(data?: IImportPropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadType = _data["leadType"];
            this.name = _data["name"];
            this.note = _data["note"];
            this.propertyAddress = _data["propertyAddress"] ? ImportAddressInput.fromJS(_data["propertyAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportPropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadType"] = this.leadType;
        data["name"] = this.name;
        data["note"] = this.note;
        data["propertyAddress"] = this.propertyAddress ? this.propertyAddress.toJSON() : <any>undefined;
        return data;
    }
}

export interface IImportPropertyInput {
    leadType: string | undefined;
    name: string | undefined;
    note: string | undefined;
    propertyAddress: ImportAddressInput | undefined;
}

export class ImportSubscriptionInput implements IImportSubscriptionInput {
    productCode!: string | undefined;
    paymentPeriodType!: RecurringPaymentFrequency | undefined;
    systemType!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    level!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IImportSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCode = _data["productCode"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.systemType = _data["systemType"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): ImportSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCode"] = this.productCode;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["systemType"] = this.systemType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IImportSubscriptionInput {
    productCode: string | undefined;
    paymentPeriodType: RecurringPaymentFrequency | undefined;
    systemType: string | undefined;
    code: string | undefined;
    name: string | undefined;
    level: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    amount: number | undefined;
}

export enum ImportTypeInput {
    Lead = "Lead",
    Client = "Client",
    Partner = "Partner",
    Investor = "Investor",
    Vendor = "Vendor",
    Employee = "Employee",
    Other = "Other",
    Order = "Order",
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment;
    amount: number;
}

export enum IncomeType {
    Employed = "Employed",
    Benefits = "Benefits",
    SelfEmployed = "SelfEmployed",
}

export class InquiryDto implements IInquiryDto {
    creditorName!: string | undefined;
    industry!: string | undefined;
    dateOfInquiry!: moment.Moment | undefined;

    constructor(data?: IInquiryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creditorName = _data["creditorName"];
            this.industry = _data["industry"];
            this.dateOfInquiry = _data["dateOfInquiry"] ? moment(_data["dateOfInquiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InquiryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquiryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditorName"] = this.creditorName;
        data["industry"] = this.industry;
        data["dateOfInquiry"] = this.dateOfInquiry ? this.dateOfInquiry.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInquiryDto {
    creditorName: string | undefined;
    industry: string | undefined;
    dateOfInquiry: moment.Moment | undefined;
}

export enum InstanceStatus {
    NotInitialized = "NotInitialized",
    Active = "Active",
    Inactive = "Inactive",
}

export enum InstanceType {
    User = "User",
    Main = "Main",
}

export class IntegrationsSettings implements IIntegrationsSettings {
    googleMapsJavascriptApiKey!: string | undefined;
    googleCloudTranslationApiKey!: string | undefined;

    constructor(data?: IIntegrationsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleMapsJavascriptApiKey = _data["googleMapsJavascriptApiKey"];
            this.googleCloudTranslationApiKey = _data["googleCloudTranslationApiKey"];
        }
    }

    static fromJS(data: any): IntegrationsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleMapsJavascriptApiKey"] = this.googleMapsJavascriptApiKey;
        data["googleCloudTranslationApiKey"] = this.googleCloudTranslationApiKey;
        return data;
    }
}

export interface IIntegrationsSettings {
    googleMapsJavascriptApiKey: string | undefined;
    googleCloudTranslationApiKey: string | undefined;
}

export enum InterestRate {
    Adjustable = "Adjustable",
    Fixed = "Fixed",
}

export class InviteUserInput implements IInviteUserInput {
    group!: UserGroup | undefined;
    name!: string;
    surname!: string;
    emailAddress!: string;
    assignedRoleNames!: string[];
    moduleType!: ModuleType;

    constructor(data?: IInviteUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.moduleType = _data["moduleType"];
        }
    }

    static fromJS(data: any): InviteUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new InviteUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["moduleType"] = this.moduleType;
        return data;
    }
}

export interface IInviteUserInput {
    group: UserGroup | undefined;
    name: string;
    surname: string;
    emailAddress: string;
    assignedRoleNames: string[];
    moduleType: ModuleType;
}

export class InvoiceAddressInfo implements IInvoiceAddressInfo {
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    city!: string | undefined;
    zip!: string | undefined;
    neighborhood!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    company!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    lastBillingDate!: moment.Moment | undefined;
    lastShippingDate!: moment.Moment | undefined;
    contactAddressId!: number;
    usageTypeId!: string | undefined;

    constructor(data?: IInvoiceAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.city = _data["city"];
            this.zip = _data["zip"];
            this.neighborhood = _data["neighborhood"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.company = _data["company"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.lastBillingDate = _data["lastBillingDate"] ? moment(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastShippingDate = _data["lastShippingDate"] ? moment(_data["lastShippingDate"].toString()) : <any>undefined;
            this.contactAddressId = _data["contactAddressId"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): InvoiceAddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["city"] = this.city;
        data["zip"] = this.zip;
        data["neighborhood"] = this.neighborhood;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["company"] = this.company;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastShippingDate"] = this.lastShippingDate ? this.lastShippingDate.toISOString() : <any>undefined;
        data["contactAddressId"] = this.contactAddressId;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface IInvoiceAddressInfo {
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    city: string | undefined;
    zip: string | undefined;
    neighborhood: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    company: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    lastBillingDate: moment.Moment | undefined;
    lastShippingDate: moment.Moment | undefined;
    contactAddressId: number;
    usageTypeId: string | undefined;
}

export class InvoiceAddressInput implements IInvoiceAddressInput {
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    city!: string | undefined;
    zip!: string | undefined;
    neighborhood!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    company!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;

    constructor(data?: IInvoiceAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.city = _data["city"];
            this.zip = _data["zip"];
            this.neighborhood = _data["neighborhood"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.company = _data["company"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): InvoiceAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["city"] = this.city;
        data["zip"] = this.zip;
        data["neighborhood"] = this.neighborhood;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["company"] = this.company;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IInvoiceAddressInput {
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    city: string | undefined;
    zip: string | undefined;
    neighborhood: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    company: string | undefined;
    email: string | undefined;
    phone: string | undefined;
}

export class InvoiceInfo implements IInvoiceInfo {
    contactName!: string | undefined;
    orderNumber!: string | undefined;
    id!: number;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment | undefined;
    grandTotal!: number;
    discountTotal!: number | undefined;
    shippingTotal!: number | undefined;
    taxTotal!: number | undefined;
    billingAddress!: InvoiceAddressInfo | undefined;
    shippingAddress!: InvoiceAddressInfo | undefined;
    description!: string | undefined;
    note!: string | undefined;
    validationErrors!: string | undefined;
    lines!: InvoiceLineInfo[] | undefined;

    constructor(data?: IInvoiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactName = _data["contactName"];
            this.orderNumber = _data["orderNumber"];
            this.id = _data["id"];
            this.status = _data["status"];
            this.number = _data["number"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.grandTotal = _data["grandTotal"];
            this.discountTotal = _data["discountTotal"];
            this.shippingTotal = _data["shippingTotal"];
            this.taxTotal = _data["taxTotal"];
            this.billingAddress = _data["billingAddress"] ? InvoiceAddressInfo.fromJS(_data["billingAddress"]) : <any>undefined;
            this.shippingAddress = _data["shippingAddress"] ? InvoiceAddressInfo.fromJS(_data["shippingAddress"]) : <any>undefined;
            this.description = _data["description"];
            this.note = _data["note"];
            this.validationErrors = _data["validationErrors"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(InvoiceLineInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactName"] = this.contactName;
        data["orderNumber"] = this.orderNumber;
        data["id"] = this.id;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["grandTotal"] = this.grandTotal;
        data["discountTotal"] = this.discountTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["taxTotal"] = this.taxTotal;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        data["validationErrors"] = this.validationErrors;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvoiceInfo {
    contactName: string | undefined;
    orderNumber: string | undefined;
    id: number;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment | undefined;
    grandTotal: number;
    discountTotal: number | undefined;
    shippingTotal: number | undefined;
    taxTotal: number | undefined;
    billingAddress: InvoiceAddressInfo | undefined;
    shippingAddress: InvoiceAddressInfo | undefined;
    description: string | undefined;
    note: string | undefined;
    validationErrors: string | undefined;
    lines: InvoiceLineInfo[] | undefined;
}

export class InvoiceLineInfo implements IInvoiceLineInfo {
    id!: number | undefined;
    quantity!: number;
    rate!: number;
    unitId!: ProductMeasurementUnit;
    unitName!: string | undefined;
    total!: number;
    commissionableAmount!: number | undefined;
    description!: string | undefined;
    sortOrder!: number;
    productId!: number | undefined;
    productCode!: string | undefined;
    productName!: string | undefined;
    productType!: ProductType | undefined;
    subscriptionXref!: string | undefined;

    constructor(data?: IInvoiceLineInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.unitId = _data["unitId"];
            this.unitName = _data["unitName"];
            this.total = _data["total"];
            this.commissionableAmount = _data["commissionableAmount"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productType = _data["productType"];
            this.subscriptionXref = _data["subscriptionXref"];
        }
    }

    static fromJS(data: any): InvoiceLineInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["total"] = this.total;
        data["commissionableAmount"] = this.commissionableAmount;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productType"] = this.productType;
        data["subscriptionXref"] = this.subscriptionXref;
        return data;
    }
}

export interface IInvoiceLineInfo {
    id: number | undefined;
    quantity: number;
    rate: number;
    unitId: ProductMeasurementUnit;
    unitName: string | undefined;
    total: number;
    commissionableAmount: number | undefined;
    description: string | undefined;
    sortOrder: number;
    productId: number | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productType: ProductType | undefined;
    subscriptionXref: string | undefined;
}

export class InvoiceSettings implements IInvoiceSettings {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;
    defaultTemplateId!: number | undefined;
    attachPDF!: boolean;
    defaultNote!: string | undefined;
    currency!: Currency;
    showShippingAddress!: boolean;
    defaultAffiliateRate!: number | undefined;
    defaultAffiliateRateTier2!: number | undefined;
    defaultAdvisorContactId!: number | undefined;
    tier2CommissionSource!: Tier2CommissionSource;
    commissionAffiliateAssignmentMode!: CommissionAffiliateAssignmentMode;
    disableProlongingSubscriptionByQuantity!: boolean;

    constructor(data?: IInvoiceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
            this.defaultTemplateId = _data["defaultTemplateId"];
            this.attachPDF = _data["attachPDF"];
            this.defaultNote = _data["defaultNote"];
            this.currency = _data["currency"];
            this.showShippingAddress = _data["showShippingAddress"];
            this.defaultAffiliateRate = _data["defaultAffiliateRate"];
            this.defaultAffiliateRateTier2 = _data["defaultAffiliateRateTier2"];
            this.defaultAdvisorContactId = _data["defaultAdvisorContactId"];
            this.tier2CommissionSource = _data["tier2CommissionSource"];
            this.commissionAffiliateAssignmentMode = _data["commissionAffiliateAssignmentMode"];
            this.disableProlongingSubscriptionByQuantity = _data["disableProlongingSubscriptionByQuantity"];
        }
    }

    static fromJS(data: any): InvoiceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        data["defaultTemplateId"] = this.defaultTemplateId;
        data["attachPDF"] = this.attachPDF;
        data["defaultNote"] = this.defaultNote;
        data["currency"] = this.currency;
        data["showShippingAddress"] = this.showShippingAddress;
        data["defaultAffiliateRate"] = this.defaultAffiliateRate;
        data["defaultAffiliateRateTier2"] = this.defaultAffiliateRateTier2;
        data["defaultAdvisorContactId"] = this.defaultAdvisorContactId;
        data["tier2CommissionSource"] = this.tier2CommissionSource;
        data["commissionAffiliateAssignmentMode"] = this.commissionAffiliateAssignmentMode;
        data["disableProlongingSubscriptionByQuantity"] = this.disableProlongingSubscriptionByQuantity;
        return data;
    }
}

export interface IInvoiceSettings {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
    defaultTemplateId: number | undefined;
    attachPDF: boolean;
    defaultNote: string | undefined;
    currency: Currency;
    showShippingAddress: boolean;
    defaultAffiliateRate: number | undefined;
    defaultAffiliateRateTier2: number | undefined;
    defaultAdvisorContactId: number | undefined;
    tier2CommissionSource: Tier2CommissionSource;
    commissionAffiliateAssignmentMode: CommissionAffiliateAssignmentMode;
    disableProlongingSubscriptionByQuantity: boolean;
}

export class InvoiceSettingsDto implements IInvoiceSettingsDto {
    advisorName!: string | undefined;
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;
    defaultTemplateId!: number | undefined;
    attachPDF!: boolean;
    defaultNote!: string | undefined;
    currency!: Currency;
    showShippingAddress!: boolean;
    defaultAffiliateRate!: number | undefined;
    defaultAffiliateRateTier2!: number | undefined;
    defaultAdvisorContactId!: number | undefined;
    tier2CommissionSource!: Tier2CommissionSource;
    commissionAffiliateAssignmentMode!: CommissionAffiliateAssignmentMode;
    disableProlongingSubscriptionByQuantity!: boolean;

    constructor(data?: IInvoiceSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advisorName = _data["advisorName"];
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
            this.defaultTemplateId = _data["defaultTemplateId"];
            this.attachPDF = _data["attachPDF"];
            this.defaultNote = _data["defaultNote"];
            this.currency = _data["currency"];
            this.showShippingAddress = _data["showShippingAddress"];
            this.defaultAffiliateRate = _data["defaultAffiliateRate"];
            this.defaultAffiliateRateTier2 = _data["defaultAffiliateRateTier2"];
            this.defaultAdvisorContactId = _data["defaultAdvisorContactId"];
            this.tier2CommissionSource = _data["tier2CommissionSource"];
            this.commissionAffiliateAssignmentMode = _data["commissionAffiliateAssignmentMode"];
            this.disableProlongingSubscriptionByQuantity = _data["disableProlongingSubscriptionByQuantity"];
        }
    }

    static fromJS(data: any): InvoiceSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advisorName"] = this.advisorName;
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        data["defaultTemplateId"] = this.defaultTemplateId;
        data["attachPDF"] = this.attachPDF;
        data["defaultNote"] = this.defaultNote;
        data["currency"] = this.currency;
        data["showShippingAddress"] = this.showShippingAddress;
        data["defaultAffiliateRate"] = this.defaultAffiliateRate;
        data["defaultAffiliateRateTier2"] = this.defaultAffiliateRateTier2;
        data["defaultAdvisorContactId"] = this.defaultAdvisorContactId;
        data["tier2CommissionSource"] = this.tier2CommissionSource;
        data["commissionAffiliateAssignmentMode"] = this.commissionAffiliateAssignmentMode;
        data["disableProlongingSubscriptionByQuantity"] = this.disableProlongingSubscriptionByQuantity;
        return data;
    }
}

export interface IInvoiceSettingsDto {
    advisorName: string | undefined;
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
    defaultTemplateId: number | undefined;
    attachPDF: boolean;
    defaultNote: string | undefined;
    currency: Currency;
    showShippingAddress: boolean;
    defaultAffiliateRate: number | undefined;
    defaultAffiliateRateTier2: number | undefined;
    defaultAdvisorContactId: number | undefined;
    tier2CommissionSource: Tier2CommissionSource;
    commissionAffiliateAssignmentMode: CommissionAffiliateAssignmentMode;
    disableProlongingSubscriptionByQuantity: boolean;
}

export enum InvoiceStatus {
    Draft = "Draft",
    Final = "Final",
    Sent = "Sent",
    Paid = "Paid",
    Canceled = "Canceled",
    PartiallyPaid = "PartiallyPaid",
    Refunded = "Refunded",
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = this.attributes[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
    claim!: string | undefined;
    key!: string | undefined;

    constructor(data?: IJsonClaimMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): JsonClaimMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new JsonClaimMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["key"] = this.key;
        return data;
    }
}

export interface IJsonClaimMapDto {
    claim: string | undefined;
    key: string | undefined;
}

export class KBAResult implements IKBAResult {
    memberId!: string;
    passed!: boolean;
    error!: string | undefined;

    constructor(data?: IKBAResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.passed = _data["passed"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): KBAResult {
        data = typeof data === 'object' ? data : {};
        let result = new KBAResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["passed"] = this.passed;
        data["error"] = this.error;
        return data;
    }
}

export interface IKBAResult {
    memberId: string;
    passed: boolean;
    error: string | undefined;
}

export class KeyValuePairOfBureauListOfScoreHistoryDto implements IKeyValuePairOfBureauListOfScoreHistoryDto {
    key!: Bureau;
    value!: ScoreHistoryDto[] | undefined;

    constructor(data?: IKeyValuePairOfBureauListOfScoreHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(ScoreHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KeyValuePairOfBureauListOfScoreHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfBureauListOfScoreHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKeyValuePairOfBureauListOfScoreHistoryDto {
    key: Bureau;
    value: ScoreHistoryDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export enum LayoutType {
    Default = "Default",
    LendSpace = "LendSpace",
    AdvicePeriod = "AdvicePeriod",
    BankCode = "BankCode",
    Rapid = "Rapid",
    HOA = "HOA",
    Sperser = "Sperser",
    GhostDrive = "GhostDrive",
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export enum LeadAgeRange {
    UpTo30Days = "UpTo30Days",
    UpTo60Days = "UpTo60Days",
    UpTo90Days = "UpTo90Days",
    UpTo6Months = "UpTo6Months",
    UpTo12Months = "UpTo12Months",
    MoreThanYear = "MoreThanYear",
}

export class LeadCancellationReasonDto implements ILeadCancellationReasonDto {
    id!: string | undefined;
    name!: string | undefined;
    isCommentRequired!: boolean;
    sortOrder!: number;

    constructor(data?: ILeadCancellationReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isCommentRequired = _data["isCommentRequired"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): LeadCancellationReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadCancellationReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCommentRequired"] = this.isCommentRequired;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ILeadCancellationReasonDto {
    id: string | undefined;
    name: string | undefined;
    isCommentRequired: boolean;
    sortOrder: number;
}

export class LeaderInfo implements ILeaderInfo {
    rank!: number;
    fullName!: string | undefined;
    publicPhotoId!: string | undefined;
    bankCode!: string | undefined;
    codesCracked!: number;

    constructor(data?: ILeaderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rank = _data["rank"];
            this.fullName = _data["fullName"];
            this.publicPhotoId = _data["publicPhotoId"];
            this.bankCode = _data["bankCode"];
            this.codesCracked = _data["codesCracked"];
        }
    }

    static fromJS(data: any): LeaderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["fullName"] = this.fullName;
        data["publicPhotoId"] = this.publicPhotoId;
        data["bankCode"] = this.bankCode;
        data["codesCracked"] = this.codesCracked;
        return data;
    }
}

export interface ILeaderInfo {
    rank: number;
    fullName: string | undefined;
    publicPhotoId: string | undefined;
    bankCode: string | undefined;
    codesCracked: number;
}

export class LeadInfoDto implements ILeadInfoDto {
    id!: number;
    contactGroupId!: string | undefined;
    typeId!: number;
    typeName!: string | undefined;
    typeSysId!: string | undefined;
    pipelineId!: number;
    stageId!: number;
    stage!: string | undefined;
    dealAmount!: number | undefined;
    creationDate!: moment.Moment;
    modificationDate!: moment.Moment | undefined;
    sourceCode!: string | undefined;
    campaignCode!: string | undefined;
    affiliateCode!: string | undefined;
    channelCode!: string | undefined;
    comments!: string | undefined;
    clientIp!: string | undefined;
    userAgent!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    clickId!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    primaryLeadRequestId!: number;
    sourceContactId!: number | undefined;
    sourceContactName!: string | undefined;
    sourceContactAffiliateCode!: string | undefined;
    sourceContactPhotoPublicId!: string | undefined;
    sourceOrganizationUnitId!: number | undefined;
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;
    importId!: number | undefined;
    importFileName!: string | undefined;
    propertyId!: number | undefined;

    constructor(data?: ILeadInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactGroupId = _data["contactGroupId"];
            this.typeId = _data["typeId"];
            this.typeName = _data["typeName"];
            this.typeSysId = _data["typeSysId"];
            this.pipelineId = _data["pipelineId"];
            this.stageId = _data["stageId"];
            this.stage = _data["stage"];
            this.dealAmount = _data["dealAmount"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? moment(_data["modificationDate"].toString()) : <any>undefined;
            this.sourceCode = _data["sourceCode"];
            this.campaignCode = _data["campaignCode"];
            this.affiliateCode = _data["affiliateCode"];
            this.channelCode = _data["channelCode"];
            this.comments = _data["comments"];
            this.clientIp = _data["clientIp"];
            this.userAgent = _data["userAgent"];
            this.applicantId = _data["applicantId"];
            this.applicationId = _data["applicationId"];
            this.clickId = _data["clickId"];
            this.siteId = _data["siteId"];
            this.siteUrl = _data["siteUrl"];
            this.refererUrl = _data["refererUrl"];
            this.entryUrl = _data["entryUrl"];
            this.primaryLeadRequestId = _data["primaryLeadRequestId"];
            this.sourceContactId = _data["sourceContactId"];
            this.sourceContactName = _data["sourceContactName"];
            this.sourceContactAffiliateCode = _data["sourceContactAffiliateCode"];
            this.sourceContactPhotoPublicId = _data["sourceContactPhotoPublicId"];
            this.sourceOrganizationUnitId = _data["sourceOrganizationUnitId"];
            this.customField1 = _data["customField1"];
            this.customField2 = _data["customField2"];
            this.customField3 = _data["customField3"];
            this.customField4 = _data["customField4"];
            this.customField5 = _data["customField5"];
            this.importId = _data["importId"];
            this.importFileName = _data["importFileName"];
            this.propertyId = _data["propertyId"];
        }
    }

    static fromJS(data: any): LeadInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactGroupId"] = this.contactGroupId;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["typeSysId"] = this.typeSysId;
        data["pipelineId"] = this.pipelineId;
        data["stageId"] = this.stageId;
        data["stage"] = this.stage;
        data["dealAmount"] = this.dealAmount;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["sourceCode"] = this.sourceCode;
        data["campaignCode"] = this.campaignCode;
        data["affiliateCode"] = this.affiliateCode;
        data["channelCode"] = this.channelCode;
        data["comments"] = this.comments;
        data["clientIp"] = this.clientIp;
        data["userAgent"] = this.userAgent;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["clickId"] = this.clickId;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["primaryLeadRequestId"] = this.primaryLeadRequestId;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceContactName"] = this.sourceContactName;
        data["sourceContactAffiliateCode"] = this.sourceContactAffiliateCode;
        data["sourceContactPhotoPublicId"] = this.sourceContactPhotoPublicId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        data["importId"] = this.importId;
        data["importFileName"] = this.importFileName;
        data["propertyId"] = this.propertyId;
        return data;
    }
}

export interface ILeadInfoDto {
    id: number;
    contactGroupId: string | undefined;
    typeId: number;
    typeName: string | undefined;
    typeSysId: string | undefined;
    pipelineId: number;
    stageId: number;
    stage: string | undefined;
    dealAmount: number | undefined;
    creationDate: moment.Moment;
    modificationDate: moment.Moment | undefined;
    sourceCode: string | undefined;
    campaignCode: string | undefined;
    affiliateCode: string | undefined;
    channelCode: string | undefined;
    comments: string | undefined;
    clientIp: string | undefined;
    userAgent: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    clickId: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    primaryLeadRequestId: number;
    sourceContactId: number | undefined;
    sourceContactName: string | undefined;
    sourceContactAffiliateCode: string | undefined;
    sourceContactPhotoPublicId: string | undefined;
    sourceOrganizationUnitId: number | undefined;
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
    importId: number | undefined;
    importFileName: string | undefined;
    propertyId: number | undefined;
}

export class LeadInfoForMerge implements ILeadInfoForMerge {
    id!: number;
    typeId!: number;
    contactGroupId!: string | undefined;
    contactId!: number;
    stage!: string | undefined;
    sourceContactId!: number | undefined;
    sourceContactName!: string | undefined;
    sourceOrganizationUnitId!: number | undefined;
    sourceOrganizationUnitName!: string | undefined;
    leadDate!: moment.Moment;
    dateCompleted!: moment.Moment | undefined;
    leadCancellationReasonId!: string | undefined;

    constructor(data?: ILeadInfoForMerge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.contactGroupId = _data["contactGroupId"];
            this.contactId = _data["contactId"];
            this.stage = _data["stage"];
            this.sourceContactId = _data["sourceContactId"];
            this.sourceContactName = _data["sourceContactName"];
            this.sourceOrganizationUnitId = _data["sourceOrganizationUnitId"];
            this.sourceOrganizationUnitName = _data["sourceOrganizationUnitName"];
            this.leadDate = _data["leadDate"] ? moment(_data["leadDate"].toString()) : <any>undefined;
            this.dateCompleted = _data["dateCompleted"] ? moment(_data["dateCompleted"].toString()) : <any>undefined;
            this.leadCancellationReasonId = _data["leadCancellationReasonId"];
        }
    }

    static fromJS(data: any): LeadInfoForMerge {
        data = typeof data === 'object' ? data : {};
        let result = new LeadInfoForMerge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["contactGroupId"] = this.contactGroupId;
        data["contactId"] = this.contactId;
        data["stage"] = this.stage;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceContactName"] = this.sourceContactName;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["sourceOrganizationUnitName"] = this.sourceOrganizationUnitName;
        data["leadDate"] = this.leadDate ? this.leadDate.toISOString() : <any>undefined;
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["leadCancellationReasonId"] = this.leadCancellationReasonId;
        return data;
    }
}

export interface ILeadInfoForMerge {
    id: number;
    typeId: number;
    contactGroupId: string | undefined;
    contactId: number;
    stage: string | undefined;
    sourceContactId: number | undefined;
    sourceContactName: string | undefined;
    sourceOrganizationUnitId: number | undefined;
    sourceOrganizationUnitName: string | undefined;
    leadDate: moment.Moment;
    dateCompleted: moment.Moment | undefined;
    leadCancellationReasonId: string | undefined;
}

export class LeadTypeDto implements ILeadTypeDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: ILeadTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LeadTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ILeadTypeDto {
    id: number;
    name: string | undefined;
}

export class LearningResourceGroupInfoOutput implements ILearningResourceGroupInfoOutput {
    groupId!: number;
    groupName!: string | undefined;
    groupImageUrl!: string | undefined;
    groupHtmlColor!: string | undefined;
    groupSortOrder!: number;
    groupIsActive!: boolean;
    resources!: LearningResourceInfoOutput[] | undefined;

    constructor(data?: ILearningResourceGroupInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.groupImageUrl = _data["groupImageUrl"];
            this.groupHtmlColor = _data["groupHtmlColor"];
            this.groupSortOrder = _data["groupSortOrder"];
            this.groupIsActive = _data["groupIsActive"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(LearningResourceInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LearningResourceGroupInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LearningResourceGroupInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["groupImageUrl"] = this.groupImageUrl;
        data["groupHtmlColor"] = this.groupHtmlColor;
        data["groupSortOrder"] = this.groupSortOrder;
        data["groupIsActive"] = this.groupIsActive;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILearningResourceGroupInfoOutput {
    groupId: number;
    groupName: string | undefined;
    groupImageUrl: string | undefined;
    groupHtmlColor: string | undefined;
    groupSortOrder: number;
    groupIsActive: boolean;
    resources: LearningResourceInfoOutput[] | undefined;
}

export class LearningResourceInfoOutput implements ILearningResourceInfoOutput {
    id!: number;
    imageUrl!: string | undefined;
    isParent!: boolean;
    parentId!: number | undefined;
    memberServiceAssignments!: MemberServiceAssignmentInfoOutput[] | undefined;
    children!: LearningResourceInfoOutput[] | undefined;
    type!: LearningResourceType | undefined;
    name!: string | undefined;
    url!: string | undefined;
    sortOrder!: number;
    isActive!: boolean;

    constructor(data?: ILearningResourceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imageUrl = _data["imageUrl"];
            this.isParent = _data["isParent"];
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["memberServiceAssignments"])) {
                this.memberServiceAssignments = [] as any;
                for (let item of _data["memberServiceAssignments"])
                    this.memberServiceAssignments!.push(MemberServiceAssignmentInfoOutput.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(LearningResourceInfoOutput.fromJS(item));
            }
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.sortOrder = _data["sortOrder"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LearningResourceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LearningResourceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageUrl"] = this.imageUrl;
        data["isParent"] = this.isParent;
        data["parentId"] = this.parentId;
        if (Array.isArray(this.memberServiceAssignments)) {
            data["memberServiceAssignments"] = [];
            for (let item of this.memberServiceAssignments)
                data["memberServiceAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["sortOrder"] = this.sortOrder;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILearningResourceInfoOutput {
    id: number;
    imageUrl: string | undefined;
    isParent: boolean;
    parentId: number | undefined;
    memberServiceAssignments: MemberServiceAssignmentInfoOutput[] | undefined;
    children: LearningResourceInfoOutput[] | undefined;
    type: LearningResourceType | undefined;
    name: string | undefined;
    url: string | undefined;
    sortOrder: number;
    isActive: boolean;
}

export enum LearningResourceType {
    Link = "Link",
    Video = "Video",
    Audio = "Audio",
    Image = "Image",
    File = "File",
}

export class LegalInformation implements ILegalInformation {
    isTCPAChecked!: boolean | undefined;

    constructor(data?: ILegalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTCPAChecked = _data["isTCPAChecked"];
        }
    }

    static fromJS(data: any): LegalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new LegalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTCPAChecked"] = this.isTCPAChecked;
        return data;
    }
}

export interface ILegalInformation {
    isTCPAChecked: boolean | undefined;
}

export class LinkDto implements ILinkDto {
    id!: number;
    linkTypeId!: string | undefined;
    url!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;

    constructor(data?: ILinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.linkTypeId = _data["linkTypeId"];
            this.url = _data["url"];
            this.isActive = _data["isActive"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): LinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ILinkDto {
    id: number;
    linkTypeId: string | undefined;
    url: string | undefined;
    isActive: boolean;
    comment: string | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class ListResultDtoOfAddressOwnershipTypeDto implements IListResultDtoOfAddressOwnershipTypeDto {
    items!: AddressOwnershipTypeDto[] | undefined;

    constructor(data?: IListResultDtoOfAddressOwnershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AddressOwnershipTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAddressOwnershipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAddressOwnershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfAddressOwnershipTypeDto {
    items: AddressOwnershipTypeDto[] | undefined;
}

export class ListResultDtoOfAddressUsageTypeDto implements IListResultDtoOfAddressUsageTypeDto {
    items!: AddressUsageTypeDto[] | undefined;

    constructor(data?: IListResultDtoOfAddressUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AddressUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAddressUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAddressUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfAddressUsageTypeDto {
    items: AddressUsageTypeDto[] | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ListResultDtoOfContactLinkTypeDto implements IListResultDtoOfContactLinkTypeDto {
    items!: ContactLinkTypeDto[] | undefined;

    constructor(data?: IListResultDtoOfContactLinkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactLinkTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfContactLinkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfContactLinkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfContactLinkTypeDto {
    items: ContactLinkTypeDto[] | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class ListResultDtoOfEmailUsageTypeDto implements IListResultDtoOfEmailUsageTypeDto {
    items!: EmailUsageTypeDto[] | undefined;

    constructor(data?: IListResultDtoOfEmailUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmailUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEmailUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEmailUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEmailUsageTypeDto {
    items: EmailUsageTypeDto[] | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class ListResultDtoOfLeadCancellationReasonDto implements IListResultDtoOfLeadCancellationReasonDto {
    items!: LeadCancellationReasonDto[] | undefined;

    constructor(data?: IListResultDtoOfLeadCancellationReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LeadCancellationReasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLeadCancellationReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLeadCancellationReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLeadCancellationReasonDto {
    items: LeadCancellationReasonDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class ListResultDtoOfPackageDto implements IListResultDtoOfPackageDto {
    items!: PackageDto[] | undefined;

    constructor(data?: IListResultDtoOfPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfPackageDto {
    items: PackageDto[] | undefined;
}

export class ListResultDtoOfPhoneUsageTypeDto implements IListResultDtoOfPhoneUsageTypeDto {
    items!: PhoneUsageTypeDto[] | undefined;

    constructor(data?: IListResultDtoOfPhoneUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PhoneUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPhoneUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPhoneUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfPhoneUsageTypeDto {
    items: PhoneUsageTypeDto[] | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class ListResultDtoOfUserListDto implements IListResultDtoOfUserListDto {
    items!: UserListDto[] | undefined;

    constructor(data?: IListResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfUserListDto {
    items: UserListDto[] | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class LoanInformation implements ILoanInformation {
    requestedLoanAmount!: number | undefined;
    loanReason!: LoanReason | undefined;

    constructor(data?: ILoanInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestedLoanAmount = _data["requestedLoanAmount"];
            this.loanReason = _data["loanReason"];
        }
    }

    static fromJS(data: any): LoanInformation {
        data = typeof data === 'object' ? data : {};
        let result = new LoanInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedLoanAmount"] = this.requestedLoanAmount;
        data["loanReason"] = this.loanReason;
        return data;
    }
}

export interface ILoanInformation {
    requestedLoanAmount: number | undefined;
    loanReason: LoanReason | undefined;
}

export class LoanInformationExtended implements ILoanInformationExtended {
    approvedLoanAmount!: number | undefined;
    requestedLoanAmount!: number | undefined;
    loanReason!: LoanReason | undefined;

    constructor(data?: ILoanInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvedLoanAmount = _data["approvedLoanAmount"];
            this.requestedLoanAmount = _data["requestedLoanAmount"];
            this.loanReason = _data["loanReason"];
        }
    }

    static fromJS(data: any): LoanInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new LoanInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvedLoanAmount"] = this.approvedLoanAmount;
        data["requestedLoanAmount"] = this.requestedLoanAmount;
        data["loanReason"] = this.loanReason;
        return data;
    }
}

export interface ILoanInformationExtended {
    approvedLoanAmount: number | undefined;
    requestedLoanAmount: number | undefined;
    loanReason: LoanReason | undefined;
}

export enum LoanReason {
    DebtConsolidation = "DebtConsolidation",
    EmergencySituation = "EmergencySituation",
    AutoRepairs = "AutoRepairs",
    AutoPurchase = "AutoPurchase",
    Moving = "Moving",
    HomeImprovement = "HomeImprovement",
    Medical = "Medical",
    Business = "Business",
    Vacation = "Vacation",
    RentOrMortgage = "RentOrMortgage",
    Wedding = "Wedding",
    MajorPurchases = "MajorPurchases",
    Other = "Other",
    CreditCardDebtRelief = "CreditCardDebtRelief",
    StudentLoanDebtRelief = "StudentLoanDebtRelief",
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableString implements ILocalizableString {
    sourceName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ILocalizableString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceName = _data["sourceName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LocalizableString {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceName"] = this.sourceName;
        data["name"] = this.name;
        return data;
    }
}

export interface ILocalizableString {
    sourceName: string | undefined;
    name: string | undefined;
}

export class LocalizationAndCurrencyDto implements ILocalizationAndCurrencyDto {
    numberFormatting!: string;
    currency!: string;

    constructor(data?: ILocalizationAndCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberFormatting = _data["numberFormatting"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): LocalizationAndCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationAndCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberFormatting"] = this.numberFormatting;
        data["currency"] = this.currency;
        return data;
    }
}

export interface ILocalizationAndCurrencyDto {
    numberFormatting: string;
    currency: string;
}

export class LocalizationSourceDto implements ILocalizationSourceDto {
    values!: { [key: string]: string; } | undefined;
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: ILocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): LocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key];
            }
        }
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface ILocalizationSourceDto {
    values: { [key: string]: string; } | undefined;
    name: string | undefined;
    type: string | undefined;
}

export enum MailSenderType {
    EPCVIP = "EPCVIP",
    IAge = "IAge",
    Ongage = "Ongage",
    Platform = "Platform",
}

export class MaintenanceSettingsDto implements IMaintenanceSettingsDto {
    version!: string | undefined;
    releaseDate!: moment.Moment;
    maintenanceMessage!: string | undefined;
    maintenanceEmailAddress!: string | undefined;
    showMaintenanceMessage!: boolean;

    constructor(data?: IMaintenanceSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.maintenanceMessage = _data["maintenanceMessage"];
            this.maintenanceEmailAddress = _data["maintenanceEmailAddress"];
            this.showMaintenanceMessage = _data["showMaintenanceMessage"];
        }
    }

    static fromJS(data: any): MaintenanceSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["maintenanceMessage"] = this.maintenanceMessage;
        data["maintenanceEmailAddress"] = this.maintenanceEmailAddress;
        data["showMaintenanceMessage"] = this.showMaintenanceMessage;
        return data;
    }
}

export interface IMaintenanceSettingsDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    maintenanceMessage: string | undefined;
    maintenanceEmailAddress: string | undefined;
    showMaintenanceMessage: boolean;
}

export class MaintenanceSettingsEditDto implements IMaintenanceSettingsEditDto {
    maintenanceMessage!: string | undefined;
    maintenanceEmailAddress!: string | undefined;
    showMaintenanceMessage!: boolean;

    constructor(data?: IMaintenanceSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maintenanceMessage = _data["maintenanceMessage"];
            this.maintenanceEmailAddress = _data["maintenanceEmailAddress"];
            this.showMaintenanceMessage = _data["showMaintenanceMessage"];
        }
    }

    static fromJS(data: any): MaintenanceSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenanceMessage"] = this.maintenanceMessage;
        data["maintenanceEmailAddress"] = this.maintenanceEmailAddress;
        data["showMaintenanceMessage"] = this.showMaintenanceMessage;
        return data;
    }
}

export interface IMaintenanceSettingsEditDto {
    maintenanceMessage: string | undefined;
    maintenanceEmailAddress: string | undefined;
    showMaintenanceMessage: boolean;
}

export enum MaritalStatus {
    Single = "Single",
    Married = "Married",
    Divorced = "Divorced",
    Widowed = "Widowed",
    Separated = "Separated",
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class MarkContactInput implements IMarkContactInput {
    contactId!: number;
    starId!: number | undefined;

    constructor(data?: IMarkContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.starId = _data["starId"];
        }
    }

    static fromJS(data: any): MarkContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["starId"] = this.starId;
        return data;
    }
}

export interface IMarkContactInput {
    contactId: number;
    starId: number | undefined;
}

export class MarkContactsInput implements IMarkContactsInput {
    contactIds!: number[] | undefined;
    starId!: number | undefined;

    constructor(data?: IMarkContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            this.starId = _data["starId"];
        }
    }

    static fromJS(data: any): MarkContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["starId"] = this.starId;
        return data;
    }
}

export interface IMarkContactsInput {
    contactIds: number[] | undefined;
    starId: number | undefined;
}

export enum MeasurementUnit {
    GB = "GB",
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
}

export class MemberAddressDto implements IMemberAddressDto {
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IMemberAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): MemberAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IMemberAddressDto {
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    countryId: string | undefined;
}

export class MemberInfoDto implements IMemberInfoDto {
    registrationId!: string;
    name!: string;
    surname!: string;
    email!: string;
    phone!: string | undefined;
    address!: MemberAddressDto | undefined;
    doB!: moment.Moment;
    ssn!: string;
    gender!: Gender;
    isUSCitizen!: boolean;
    packageId!: number;
    utmParameter!: UTMParameterInfo | undefined;
    trackingInfo!: TrackingInfo | undefined;

    constructor(data?: IMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationId = _data["registrationId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"] ? MemberAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.gender = _data["gender"];
            this.isUSCitizen = _data["isUSCitizen"];
            this.packageId = _data["packageId"];
            this.utmParameter = _data["utmParameter"] ? UTMParameterInfo.fromJS(_data["utmParameter"]) : <any>undefined;
            this.trackingInfo = _data["trackingInfo"] ? TrackingInfo.fromJS(_data["trackingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMemberInfoDto {
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string | undefined;
    address: MemberAddressDto | undefined;
    doB: moment.Moment;
    ssn: string;
    gender: Gender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo | undefined;
    trackingInfo: TrackingInfo | undefined;
}

export class MemberPaymentAuthorizeRequestDto implements IMemberPaymentAuthorizeRequestDto {
    registrationId!: string;
    packageId!: number;
    paymentInfoType!: PaymentInfoType;
    bankCard!: BankCardDto | undefined;
    achCustomer!: ACHCustomerDto | undefined;
    payPal!: PayPalDto | undefined;

    constructor(data?: IMemberPaymentAuthorizeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationId = _data["registrationId"];
            this.packageId = _data["packageId"];
            this.paymentInfoType = _data["paymentInfoType"];
            this.bankCard = _data["bankCard"] ? BankCardDto.fromJS(_data["bankCard"]) : <any>undefined;
            this.achCustomer = _data["achCustomer"] ? ACHCustomerDto.fromJS(_data["achCustomer"]) : <any>undefined;
            this.payPal = _data["payPal"] ? PayPalDto.fromJS(_data["payPal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberPaymentAuthorizeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPaymentAuthorizeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["packageId"] = this.packageId;
        data["paymentInfoType"] = this.paymentInfoType;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["payPal"] = this.payPal ? this.payPal.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMemberPaymentAuthorizeRequestDto {
    registrationId: string;
    packageId: number;
    paymentInfoType: PaymentInfoType;
    bankCard: BankCardDto | undefined;
    achCustomer: ACHCustomerDto | undefined;
    payPal: PayPalDto | undefined;
}

export class MemberPortalSettingsDto implements IMemberPortalSettingsDto {
    url!: string | undefined;

    constructor(data?: IMemberPortalSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): MemberPortalSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPortalSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface IMemberPortalSettingsDto {
    url: string | undefined;
}

export class MemberServiceAssignmentInfoOutput implements IMemberServiceAssignmentInfoOutput {
    memberServiceLevelIds!: number[] | undefined;
    memberServiceId!: number;

    constructor(data?: IMemberServiceAssignmentInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberServiceLevelIds"])) {
                this.memberServiceLevelIds = [] as any;
                for (let item of _data["memberServiceLevelIds"])
                    this.memberServiceLevelIds!.push(item);
            }
            this.memberServiceId = _data["memberServiceId"];
        }
    }

    static fromJS(data: any): MemberServiceAssignmentInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceAssignmentInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberServiceLevelIds)) {
            data["memberServiceLevelIds"] = [];
            for (let item of this.memberServiceLevelIds)
                data["memberServiceLevelIds"].push(item);
        }
        data["memberServiceId"] = this.memberServiceId;
        return data;
    }
}

export interface IMemberServiceAssignmentInfoOutput {
    memberServiceLevelIds: number[] | undefined;
    memberServiceId: number;
}

export class MemberServiceAssignmentInput implements IMemberServiceAssignmentInput {
    memberServiceId!: number;
    memberServiceLevelId!: number | undefined;

    constructor(data?: IMemberServiceAssignmentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberServiceId = _data["memberServiceId"];
            this.memberServiceLevelId = _data["memberServiceLevelId"];
        }
    }

    static fromJS(data: any): MemberServiceAssignmentInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceAssignmentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberServiceId"] = this.memberServiceId;
        data["memberServiceLevelId"] = this.memberServiceLevelId;
        return data;
    }
}

export interface IMemberServiceAssignmentInput {
    memberServiceId: number;
    memberServiceLevelId: number | undefined;
}

export class MemberServiceDto implements IMemberServiceDto {
    id!: number | undefined;
    systemType!: string;
    code!: string;
    name!: string;
    monthlyFee!: number | undefined;
    activationTime!: moment.Moment | undefined;
    deactivationTime!: moment.Moment | undefined;
    features!: { [key: string]: string; } | undefined;
    memberServiceLevels!: MemberServiceLevelDto[] | undefined;

    constructor(data?: IMemberServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.systemType = _data["systemType"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.monthlyFee = _data["monthlyFee"];
            this.activationTime = _data["activationTime"] ? moment(_data["activationTime"].toString()) : <any>undefined;
            this.deactivationTime = _data["deactivationTime"] ? moment(_data["deactivationTime"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
            if (Array.isArray(_data["memberServiceLevels"])) {
                this.memberServiceLevels = [] as any;
                for (let item of _data["memberServiceLevels"])
                    this.memberServiceLevels!.push(MemberServiceLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemType"] = this.systemType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["monthlyFee"] = this.monthlyFee;
        data["activationTime"] = this.activationTime ? this.activationTime.toISOString() : <any>undefined;
        data["deactivationTime"] = this.deactivationTime ? this.deactivationTime.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        if (Array.isArray(this.memberServiceLevels)) {
            data["memberServiceLevels"] = [];
            for (let item of this.memberServiceLevels)
                data["memberServiceLevels"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMemberServiceDto {
    id: number | undefined;
    systemType: string;
    code: string;
    name: string;
    monthlyFee: number | undefined;
    activationTime: moment.Moment | undefined;
    deactivationTime: moment.Moment | undefined;
    features: { [key: string]: string; } | undefined;
    memberServiceLevels: MemberServiceLevelDto[] | undefined;
}

export class MemberServiceLevelBaseDto implements IMemberServiceLevelBaseDto {
    id!: number | undefined;
    code!: string;

    constructor(data?: IMemberServiceLevelBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): MemberServiceLevelBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceLevelBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        return data;
    }
}

export interface IMemberServiceLevelBaseDto {
    id: number | undefined;
    code: string;
}

export class MemberServiceLevelDto implements IMemberServiceLevelDto {
    name!: string;
    monthlyFee!: number | undefined;
    activationTime!: moment.Moment | undefined;
    deactivationTime!: moment.Moment | undefined;
    features!: { [key: string]: string; } | undefined;
    id!: number | undefined;
    code!: string;

    constructor(data?: IMemberServiceLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.monthlyFee = _data["monthlyFee"];
            this.activationTime = _data["activationTime"] ? moment(_data["activationTime"].toString()) : <any>undefined;
            this.deactivationTime = _data["deactivationTime"] ? moment(_data["deactivationTime"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
            this.id = _data["id"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): MemberServiceLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["monthlyFee"] = this.monthlyFee;
        data["activationTime"] = this.activationTime ? this.activationTime.toISOString() : <any>undefined;
        data["deactivationTime"] = this.deactivationTime ? this.deactivationTime.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        data["id"] = this.id;
        data["code"] = this.code;
        return data;
    }
}

export interface IMemberServiceLevelDto {
    name: string;
    monthlyFee: number | undefined;
    activationTime: moment.Moment | undefined;
    deactivationTime: moment.Moment | undefined;
    features: { [key: string]: string; } | undefined;
    id: number | undefined;
    code: string;
}

export enum MemberSimulatorAccessStatus {
    Ok = "Ok",
    NoMember = "NoMember",
    MemberIsCancelled = "MemberIsCancelled",
    KbaIsNotPassed = "KbaIsNotPassed",
    UnsupportedPackage = "UnsupportedPackage",
    NoPayment = "NoPayment",
}

export class MergeContactInput implements IMergeContactInput {
    contactId!: number;
    contactLeadId!: number | undefined;
    contactMergeOptions!: ContactMergeOptions | undefined;
    targetContactId!: number;
    targetContactLeadId!: number | undefined;
    targetContactMergeOptions!: TargetContactMergeOptions | undefined;
    primaryContactInfo!: PrimaryContactInfo | undefined;
    mergeLeadMode!: MergeLeadMode | undefined;

    constructor(data?: IMergeContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.contactLeadId = _data["contactLeadId"];
            this.contactMergeOptions = _data["contactMergeOptions"] ? ContactMergeOptions.fromJS(_data["contactMergeOptions"]) : <any>undefined;
            this.targetContactId = _data["targetContactId"];
            this.targetContactLeadId = _data["targetContactLeadId"];
            this.targetContactMergeOptions = _data["targetContactMergeOptions"] ? TargetContactMergeOptions.fromJS(_data["targetContactMergeOptions"]) : <any>undefined;
            this.primaryContactInfo = _data["primaryContactInfo"] ? PrimaryContactInfo.fromJS(_data["primaryContactInfo"]) : <any>undefined;
            this.mergeLeadMode = _data["mergeLeadMode"];
        }
    }

    static fromJS(data: any): MergeContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactLeadId"] = this.contactLeadId;
        data["contactMergeOptions"] = this.contactMergeOptions ? this.contactMergeOptions.toJSON() : <any>undefined;
        data["targetContactId"] = this.targetContactId;
        data["targetContactLeadId"] = this.targetContactLeadId;
        data["targetContactMergeOptions"] = this.targetContactMergeOptions ? this.targetContactMergeOptions.toJSON() : <any>undefined;
        data["primaryContactInfo"] = this.primaryContactInfo ? this.primaryContactInfo.toJSON() : <any>undefined;
        data["mergeLeadMode"] = this.mergeLeadMode;
        return data;
    }
}

export interface IMergeContactInput {
    contactId: number;
    contactLeadId: number | undefined;
    contactMergeOptions: ContactMergeOptions | undefined;
    targetContactId: number;
    targetContactLeadId: number | undefined;
    targetContactMergeOptions: TargetContactMergeOptions | undefined;
    primaryContactInfo: PrimaryContactInfo | undefined;
    mergeLeadMode: MergeLeadMode | undefined;
}

export enum MergeLeadMode {
    KeepSource = "KeepSource",
    KeepTarget = "KeepTarget",
    KeepBoth = "KeepBoth",
}

export class MergeStagesInput implements IMergeStagesInput {
    pipelineId!: number;
    sourceStageId!: number;
    destinationStageId!: number | undefined;

    constructor(data?: IMergeStagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pipelineId = _data["pipelineId"];
            this.sourceStageId = _data["sourceStageId"];
            this.destinationStageId = _data["destinationStageId"];
        }
    }

    static fromJS(data: any): MergeStagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeStagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelineId"] = this.pipelineId;
        data["sourceStageId"] = this.sourceStageId;
        data["destinationStageId"] = this.destinationStageId;
        return data;
    }
}

export interface IMergeStagesInput {
    pipelineId: number;
    sourceStageId: number;
    destinationStageId: number | undefined;
}

export class MessageDto implements IMessageDto {
    body!: string | undefined;
    attachments!: AttachmentDto[] | undefined;
    parentId!: number | undefined;
    fromUserId!: number | undefined;
    fromUserName!: string | undefined;
    fromUserContactPhotoPublicId!: string | undefined;
    from!: string | undefined;
    to!: string | undefined;
    replyTo!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    creationTime!: moment.Moment;
    deliveryType!: CommunicationMessageDeliveryType;
    status!: CommunicationMessageSendingStatus;
    recepients!: RecepientInfo[] | undefined;
    hasChildren!: boolean;
    hasAttachments!: boolean;
    isInbound!: boolean;
    id!: number;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentDto.fromJS(item));
            }
            this.parentId = _data["parentId"];
            this.fromUserId = _data["fromUserId"];
            this.fromUserName = _data["fromUserName"];
            this.fromUserContactPhotoPublicId = _data["fromUserContactPhotoPublicId"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.replyTo = _data["replyTo"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.deliveryType = _data["deliveryType"];
            this.status = _data["status"];
            if (Array.isArray(_data["recepients"])) {
                this.recepients = [] as any;
                for (let item of _data["recepients"])
                    this.recepients!.push(RecepientInfo.fromJS(item));
            }
            this.hasChildren = _data["hasChildren"];
            this.hasAttachments = _data["hasAttachments"];
            this.isInbound = _data["isInbound"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["parentId"] = this.parentId;
        data["fromUserId"] = this.fromUserId;
        data["fromUserName"] = this.fromUserName;
        data["fromUserContactPhotoPublicId"] = this.fromUserContactPhotoPublicId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["replyTo"] = this.replyTo;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["deliveryType"] = this.deliveryType;
        data["status"] = this.status;
        if (Array.isArray(this.recepients)) {
            data["recepients"] = [];
            for (let item of this.recepients)
                data["recepients"].push(item.toJSON());
        }
        data["hasChildren"] = this.hasChildren;
        data["hasAttachments"] = this.hasAttachments;
        data["isInbound"] = this.isInbound;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageDto {
    body: string | undefined;
    attachments: AttachmentDto[] | undefined;
    parentId: number | undefined;
    fromUserId: number | undefined;
    fromUserName: string | undefined;
    fromUserContactPhotoPublicId: string | undefined;
    from: string | undefined;
    to: string | undefined;
    replyTo: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    creationTime: moment.Moment;
    deliveryType: CommunicationMessageDeliveryType;
    status: CommunicationMessageSendingStatus;
    recepients: RecepientInfo[] | undefined;
    hasChildren: boolean;
    hasAttachments: boolean;
    isInbound: boolean;
    id: number;
}

export class MessageListDto implements IMessageListDto {
    parentId!: number | undefined;
    fromUserId!: number | undefined;
    fromUserName!: string | undefined;
    fromUserContactPhotoPublicId!: string | undefined;
    from!: string | undefined;
    to!: string | undefined;
    replyTo!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    creationTime!: moment.Moment;
    deliveryType!: CommunicationMessageDeliveryType;
    status!: CommunicationMessageSendingStatus;
    recepients!: RecepientInfo[] | undefined;
    hasChildren!: boolean;
    hasAttachments!: boolean;
    isInbound!: boolean;
    id!: number;

    constructor(data?: IMessageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.fromUserId = _data["fromUserId"];
            this.fromUserName = _data["fromUserName"];
            this.fromUserContactPhotoPublicId = _data["fromUserContactPhotoPublicId"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.replyTo = _data["replyTo"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.deliveryType = _data["deliveryType"];
            this.status = _data["status"];
            if (Array.isArray(_data["recepients"])) {
                this.recepients = [] as any;
                for (let item of _data["recepients"])
                    this.recepients!.push(RecepientInfo.fromJS(item));
            }
            this.hasChildren = _data["hasChildren"];
            this.hasAttachments = _data["hasAttachments"];
            this.isInbound = _data["isInbound"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["fromUserId"] = this.fromUserId;
        data["fromUserName"] = this.fromUserName;
        data["fromUserContactPhotoPublicId"] = this.fromUserContactPhotoPublicId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["replyTo"] = this.replyTo;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["deliveryType"] = this.deliveryType;
        data["status"] = this.status;
        if (Array.isArray(this.recepients)) {
            data["recepients"] = [];
            for (let item of this.recepients)
                data["recepients"].push(item.toJSON());
        }
        data["hasChildren"] = this.hasChildren;
        data["hasAttachments"] = this.hasAttachments;
        data["isInbound"] = this.isInbound;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageListDto {
    parentId: number | undefined;
    fromUserId: number | undefined;
    fromUserName: string | undefined;
    fromUserContactPhotoPublicId: string | undefined;
    from: string | undefined;
    to: string | undefined;
    replyTo: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    creationTime: moment.Moment;
    deliveryType: CommunicationMessageDeliveryType;
    status: CommunicationMessageSendingStatus;
    recepients: RecepientInfo[] | undefined;
    hasChildren: boolean;
    hasAttachments: boolean;
    isInbound: boolean;
    id: number;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IMicrosoftExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MicrosoftExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface IMicrosoftExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class ModuleSubscriptionInfo implements IModuleSubscriptionInfo {
    editionId!: number;
    maxUserCount!: number | undefined;
    frequency!: PaymentPeriodType;

    constructor(data?: IModuleSubscriptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.maxUserCount = _data["maxUserCount"];
            this.frequency = _data["frequency"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["frequency"] = this.frequency;
        return data;
    }
}

export interface IModuleSubscriptionInfo {
    editionId: number;
    maxUserCount: number | undefined;
    frequency: PaymentPeriodType;
}

export class ModuleSubscriptionInfoDto implements IModuleSubscriptionInfoDto {
    module!: ModuleType;
    statusId!: string | undefined;
    productId!: number | undefined;
    productName!: string | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    endDate!: moment.Moment | undefined;
    editionName!: string | undefined;
    isTrial!: boolean;
    isLocked!: boolean;
    trackingCode!: string | undefined;
    hasRecurringBilling!: boolean;
    isUpgradable!: boolean;
    invoiceId!: number | undefined;

    constructor(data?: IModuleSubscriptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.statusId = _data["statusId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.editionName = _data["editionName"];
            this.isTrial = _data["isTrial"];
            this.isLocked = _data["isLocked"];
            this.trackingCode = _data["trackingCode"];
            this.hasRecurringBilling = _data["hasRecurringBilling"];
            this.isUpgradable = _data["isUpgradable"];
            this.invoiceId = _data["invoiceId"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["statusId"] = this.statusId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["editionName"] = this.editionName;
        data["isTrial"] = this.isTrial;
        data["isLocked"] = this.isLocked;
        data["trackingCode"] = this.trackingCode;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["isUpgradable"] = this.isUpgradable;
        data["invoiceId"] = this.invoiceId;
        return data;
    }
}

export interface IModuleSubscriptionInfoDto {
    module: ModuleType;
    statusId: string | undefined;
    productId: number | undefined;
    productName: string | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    endDate: moment.Moment | undefined;
    editionName: string | undefined;
    isTrial: boolean;
    isLocked: boolean;
    trackingCode: string | undefined;
    hasRecurringBilling: boolean;
    isUpgradable: boolean;
    invoiceId: number | undefined;
}

export class ModuleSubscriptionInfoExtended implements IModuleSubscriptionInfoExtended {
    isTrial!: boolean;
    editionId!: number;
    maxUserCount!: number | undefined;
    frequency!: PaymentPeriodType;

    constructor(data?: IModuleSubscriptionInfoExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTrial = _data["isTrial"];
            this.editionId = _data["editionId"];
            this.maxUserCount = _data["maxUserCount"];
            this.frequency = _data["frequency"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfoExtended {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfoExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTrial"] = this.isTrial;
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["frequency"] = this.frequency;
        return data;
    }
}

export interface IModuleSubscriptionInfoExtended {
    isTrial: boolean;
    editionId: number;
    maxUserCount: number | undefined;
    frequency: PaymentPeriodType;
}

export enum ModuleType {
    CFO = "CFO",
    CRM = "CRM",
    CFO_CRM = "CFO_CRM",
    PFM = "PFM",
    CFO_Partner = "CFO_Partner",
}

export enum MonthPeriodScope {
    Days = "Days",
    Weeks = "Weeks",
}

export class MoveActivityDto implements IMoveActivityDto {
    id!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean;
    sortOrder!: number | undefined;

    constructor(data?: IMoveActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.allDay = _data["allDay"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): MoveActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IMoveActivityDto {
    id: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean;
    sortOrder: number | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class MoveRuleDto implements IMoveRuleDto {
    parentId!: number | undefined;
    sortOrder!: number;
    isRecategorize!: boolean;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption;
    id!: number;

    constructor(data?: IMoveRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.sortOrder = _data["sortOrder"];
            this.isRecategorize = _data["isRecategorize"];
            if (Array.isArray(_data["sourceTransactionList"])) {
                this.sourceTransactionList = [] as any;
                for (let item of _data["sourceTransactionList"])
                    this.sourceTransactionList!.push(item);
            }
            this.applyOption = _data["applyOption"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MoveRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["sortOrder"] = this.sortOrder;
        data["isRecategorize"] = this.isRecategorize;
        if (Array.isArray(this.sourceTransactionList)) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        data["id"] = this.id;
        return data;
    }
}

export interface IMoveRuleDto {
    parentId: number | undefined;
    sortOrder: number;
    isRecategorize: boolean;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption;
    id: number;
}

export class NameInput implements INameInput {
    name!: string;

    constructor(data?: INameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NameInput {
        data = typeof data === 'object' ? data : {};
        let result = new NameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface INameInput {
    name: string;
}

export class NameIsAvailableDto implements INameIsAvailableDto {
    name!: string | undefined;
    isAvailable!: boolean;

    constructor(data?: INameIsAvailableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): NameIsAvailableDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameIsAvailableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface INameIsAvailableDto {
    name: string | undefined;
    isAvailable: boolean;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NoteInfoDto implements INoteInfoDto {
    contactId!: number;
    id!: number;
    text!: string | undefined;
    dateTime!: moment.Moment;
    noteType!: NoteType | undefined;
    noteTypeName!: string | undefined;
    contactPhoneId!: number | undefined;
    contactPhoneNumber!: string | undefined;
    contactName!: string | undefined;
    orderId!: number | undefined;
    leadId!: number | undefined;
    followUpDateTime!: moment.Moment | undefined;
    addedByUserId!: number;
    addedByUserName!: string | undefined;
    addedByUserPhotoPublicId!: string | undefined;
    pinnedByUserName!: string | undefined;
    pinnedDateTime!: moment.Moment | undefined;

    constructor(data?: INoteInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.id = _data["id"];
            this.text = _data["text"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.noteType = _data["noteType"];
            this.noteTypeName = _data["noteTypeName"];
            this.contactPhoneId = _data["contactPhoneId"];
            this.contactPhoneNumber = _data["contactPhoneNumber"];
            this.contactName = _data["contactName"];
            this.orderId = _data["orderId"];
            this.leadId = _data["leadId"];
            this.followUpDateTime = _data["followUpDateTime"] ? moment(_data["followUpDateTime"].toString()) : <any>undefined;
            this.addedByUserId = _data["addedByUserId"];
            this.addedByUserName = _data["addedByUserName"];
            this.addedByUserPhotoPublicId = _data["addedByUserPhotoPublicId"];
            this.pinnedByUserName = _data["pinnedByUserName"];
            this.pinnedDateTime = _data["pinnedDateTime"] ? moment(_data["pinnedDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NoteInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoteInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["text"] = this.text;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["noteType"] = this.noteType;
        data["noteTypeName"] = this.noteTypeName;
        data["contactPhoneId"] = this.contactPhoneId;
        data["contactPhoneNumber"] = this.contactPhoneNumber;
        data["contactName"] = this.contactName;
        data["orderId"] = this.orderId;
        data["leadId"] = this.leadId;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        data["addedByUserName"] = this.addedByUserName;
        data["addedByUserPhotoPublicId"] = this.addedByUserPhotoPublicId;
        data["pinnedByUserName"] = this.pinnedByUserName;
        data["pinnedDateTime"] = this.pinnedDateTime ? this.pinnedDateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface INoteInfoDto {
    contactId: number;
    id: number;
    text: string | undefined;
    dateTime: moment.Moment;
    noteType: NoteType | undefined;
    noteTypeName: string | undefined;
    contactPhoneId: number | undefined;
    contactPhoneNumber: string | undefined;
    contactName: string | undefined;
    orderId: number | undefined;
    leadId: number | undefined;
    followUpDateTime: moment.Moment | undefined;
    addedByUserId: number;
    addedByUserName: string | undefined;
    addedByUserPhotoPublicId: string | undefined;
    pinnedByUserName: string | undefined;
    pinnedDateTime: moment.Moment | undefined;
}

export enum NoteType {
    Note = "Note",
    IncomingCall = "IncomingCall",
    OutcomingCall = "OutcomingCall",
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;
    group!: string | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        data["group"] = this.group;
        return data;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
    group: string | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;
    group!: string | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        data["group"] = this.group;
        return data;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
    group: string | undefined;
}

export class OfferApplicationDto implements IOfferApplicationDto {
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformation | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformation | undefined;
    employmentInformation!: EmploymentInformation | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IOfferApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trackingInformation = _data["trackingInformation"] ? TrackingInformation.fromJS(_data["trackingInformation"]) : <any>undefined;
            this.personalInformation = _data["personalInformation"] ? PersonalInformation.fromJS(_data["personalInformation"]) : <any>undefined;
            this.debtInformation = _data["debtInformation"] ? DebtInformation.fromJS(_data["debtInformation"]) : <any>undefined;
            this.loanInformation = _data["loanInformation"] ? LoanInformation.fromJS(_data["loanInformation"]) : <any>undefined;
            this.employmentInformation = _data["employmentInformation"] ? EmploymentInformation.fromJS(_data["employmentInformation"]) : <any>undefined;
            this.bankInformation = _data["bankInformation"] ? BankInformation.fromJS(_data["bankInformation"]) : <any>undefined;
            this.legalInformation = _data["legalInformation"] ? LegalInformation.fromJS(_data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OfferApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOfferApplicationDto {
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformation | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformation | undefined;
    employmentInformation: EmploymentInformation | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class OfferApplicationGroup implements IOfferApplicationGroup {
    date!: moment.Moment;
    count!: number;

    constructor(data?: IOfferApplicationGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): OfferApplicationGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OfferApplicationGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["count"] = this.count;
        return data;
    }
}

export interface IOfferApplicationGroup {
    date: moment.Moment;
    count: number;
}

export enum OfferAttributeType {
    SubId = "SubId",
    IsPublished = "IsPublished",
    OverallRating = "OverallRating",
    IssuingBank = "IssuingBank",
    AnnualFee = "AnnualFee",
    RewardsRate = "RewardsRate",
    IntroRewardsBonus = "IntroRewardsBonus",
    RegularAPR = "RegularAPR",
    CampaignProviderType = "CampaignProviderType",
    OfferCollection = "OfferCollection",
    MinLoanAmount = "MinLoanAmount",
    MaxLoanAmount = "MaxLoanAmount",
    MinLoanTermMonths = "MinLoanTermMonths",
    MaxLoanTermMonths = "MaxLoanTermMonths",
    MinAnnualIncome = "MinAnnualIncome",
    MaxAnnualIncome = "MaxAnnualIncome",
    States = "States",
    ParameterHandlerType = "ParameterHandlerType",
}

export class OfferCategoryDto implements IOfferCategoryDto {
    name!: string | undefined;
    category!: CampaignCategory | undefined;

    constructor(data?: IOfferCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): OfferCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        return data;
    }
}

export interface IOfferCategoryDto {
    name: string | undefined;
    category: CampaignCategory | undefined;
}

export enum OfferCollection {
    Best = "Best",
    BalanceTransfer = "BalanceTransfer",
    CashBack = "CashBack",
    RewardPoints = "RewardPoints",
    ZeroPercentageOnPurchases = "ZeroPercentageOnPurchases",
    TravelAirlineHotel = "TravelAirlineHotel",
    SecuredOrPrepaid = "SecuredOrPrepaid",
    BusinessCards = "BusinessCards",
    NoAnnualFees = "NoAnnualFees",
    Excellent = "Excellent",
    Good = "Good",
    Fair = "Fair",
    Bad = "Bad",
    NoCredit = "NoCredit",
    Newest = "Newest",
    SpecialDeals = "SpecialDeals",
}

export class OfferDetailsDto implements IOfferDetailsDto {
    description!: string | undefined;
    introAPR!: string | undefined;
    creditScores!: CreditScoreRating[] | undefined;
    pros!: string[] | undefined;
    cons!: string[] | undefined;
    campaignId!: number;
    name!: string | undefined;
    systemType!: OfferProviderType;
    redirectUrl!: string | undefined;
    logoUrl!: string | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    annualFee!: string | undefined;
    rewardsRate!: string | undefined;
    introRewardsBonus!: string | undefined;
    regularAPR!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    details!: string[] | undefined;

    constructor(data?: IOfferDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.introAPR = _data["introAPR"];
            if (Array.isArray(_data["creditScores"])) {
                this.creditScores = [] as any;
                for (let item of _data["creditScores"])
                    this.creditScores!.push(item);
            }
            if (Array.isArray(_data["pros"])) {
                this.pros = [] as any;
                for (let item of _data["pros"])
                    this.pros!.push(item);
            }
            if (Array.isArray(_data["cons"])) {
                this.cons = [] as any;
                for (let item of _data["cons"])
                    this.cons!.push(item);
            }
            this.campaignId = _data["campaignId"];
            this.name = _data["name"];
            this.systemType = _data["systemType"];
            this.redirectUrl = _data["redirectUrl"];
            this.logoUrl = _data["logoUrl"];
            this.overallRating = _data["overallRating"];
            this.issuingBank = _data["issuingBank"];
            this.annualFee = _data["annualFee"];
            this.rewardsRate = _data["rewardsRate"];
            this.introRewardsBonus = _data["introRewardsBonus"];
            this.regularAPR = _data["regularAPR"];
            this.offerCollection = _data["offerCollection"];
            this.minLoanAmount = _data["minLoanAmount"];
            this.maxLoanAmount = _data["maxLoanAmount"];
            this.campaignProviderType = _data["campaignProviderType"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(item);
            }
        }
    }

    static fromJS(data: any): OfferDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["introAPR"] = this.introAPR;
        if (Array.isArray(this.creditScores)) {
            data["creditScores"] = [];
            for (let item of this.creditScores)
                data["creditScores"].push(item);
        }
        if (Array.isArray(this.pros)) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (Array.isArray(this.cons)) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["redirectUrl"] = this.redirectUrl;
        data["logoUrl"] = this.logoUrl;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        data["annualFee"] = this.annualFee;
        data["rewardsRate"] = this.rewardsRate;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["regularAPR"] = this.regularAPR;
        data["offerCollection"] = this.offerCollection;
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["campaignProviderType"] = this.campaignProviderType;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data;
    }
}

export interface IOfferDetailsDto {
    description: string | undefined;
    introAPR: string | undefined;
    creditScores: CreditScoreRating[] | undefined;
    pros: string[] | undefined;
    cons: string[] | undefined;
    campaignId: number;
    name: string | undefined;
    systemType: OfferProviderType;
    redirectUrl: string | undefined;
    logoUrl: string | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    annualFee: string | undefined;
    rewardsRate: string | undefined;
    introRewardsBonus: string | undefined;
    regularAPR: string | undefined;
    offerCollection: OfferCollection | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    details: string[] | undefined;
}

export class OfferDetailsForEditDto implements IOfferDetailsForEditDto {
    daysOfWeekAvailability!: string | undefined;
    effectiveTimeOfDay!: string | undefined;
    expireTimeOfDay!: string | undefined;
    termsOfService!: string | undefined;
    trafficSource!: CampaignTrafficSource;
    categories!: OfferCategoryDto[] | undefined;
    description!: string | undefined;
    countries!: string[] | undefined;
    extendedInfo!: ExtendOfferDto | undefined;
    campaignId!: number;
    name!: string | undefined;
    systemType!: OfferProviderType;
    campaignUrl!: string | undefined;
    logoUrl!: string | undefined;
    status!: CampaignStatus;
    type!: CampaignType;
    isPublished!: boolean;

    constructor(data?: IOfferDetailsForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.daysOfWeekAvailability = _data["daysOfWeekAvailability"];
            this.effectiveTimeOfDay = _data["effectiveTimeOfDay"];
            this.expireTimeOfDay = _data["expireTimeOfDay"];
            this.termsOfService = _data["termsOfService"];
            this.trafficSource = _data["trafficSource"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(OfferCategoryDto.fromJS(item));
            }
            this.description = _data["description"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(item);
            }
            this.extendedInfo = _data["extendedInfo"] ? ExtendOfferDto.fromJS(_data["extendedInfo"]) : <any>undefined;
            this.campaignId = _data["campaignId"];
            this.name = _data["name"];
            this.systemType = _data["systemType"];
            this.campaignUrl = _data["campaignUrl"];
            this.logoUrl = _data["logoUrl"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): OfferDetailsForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysOfWeekAvailability"] = this.daysOfWeekAvailability;
        data["effectiveTimeOfDay"] = this.effectiveTimeOfDay;
        data["expireTimeOfDay"] = this.expireTimeOfDay;
        data["termsOfService"] = this.termsOfService;
        data["trafficSource"] = this.trafficSource;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item);
        }
        data["extendedInfo"] = this.extendedInfo ? this.extendedInfo.toJSON() : <any>undefined;
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["campaignUrl"] = this.campaignUrl;
        data["logoUrl"] = this.logoUrl;
        data["status"] = this.status;
        data["type"] = this.type;
        data["isPublished"] = this.isPublished;
        return data;
    }
}

export interface IOfferDetailsForEditDto {
    daysOfWeekAvailability: string | undefined;
    effectiveTimeOfDay: string | undefined;
    expireTimeOfDay: string | undefined;
    termsOfService: string | undefined;
    trafficSource: CampaignTrafficSource;
    categories: OfferCategoryDto[] | undefined;
    description: string | undefined;
    countries: string[] | undefined;
    extendedInfo: ExtendOfferDto | undefined;
    campaignId: number;
    name: string | undefined;
    systemType: OfferProviderType;
    campaignUrl: string | undefined;
    logoUrl: string | undefined;
    status: CampaignStatus;
    type: CampaignType;
    isPublished: boolean;
}

export class OfferDto implements IOfferDto {
    campaignId!: number;
    name!: string | undefined;
    systemType!: OfferProviderType;
    redirectUrl!: string | undefined;
    logoUrl!: string | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    annualFee!: string | undefined;
    rewardsRate!: string | undefined;
    introRewardsBonus!: string | undefined;
    regularAPR!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    details!: string[] | undefined;

    constructor(data?: IOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.campaignId = _data["campaignId"];
            this.name = _data["name"];
            this.systemType = _data["systemType"];
            this.redirectUrl = _data["redirectUrl"];
            this.logoUrl = _data["logoUrl"];
            this.overallRating = _data["overallRating"];
            this.issuingBank = _data["issuingBank"];
            this.annualFee = _data["annualFee"];
            this.rewardsRate = _data["rewardsRate"];
            this.introRewardsBonus = _data["introRewardsBonus"];
            this.regularAPR = _data["regularAPR"];
            this.offerCollection = _data["offerCollection"];
            this.minLoanAmount = _data["minLoanAmount"];
            this.maxLoanAmount = _data["maxLoanAmount"];
            this.campaignProviderType = _data["campaignProviderType"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(item);
            }
        }
    }

    static fromJS(data: any): OfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["redirectUrl"] = this.redirectUrl;
        data["logoUrl"] = this.logoUrl;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        data["annualFee"] = this.annualFee;
        data["rewardsRate"] = this.rewardsRate;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["regularAPR"] = this.regularAPR;
        data["offerCollection"] = this.offerCollection;
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["campaignProviderType"] = this.campaignProviderType;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data;
    }
}

export interface IOfferDto {
    campaignId: number;
    name: string | undefined;
    systemType: OfferProviderType;
    redirectUrl: string | undefined;
    logoUrl: string | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    annualFee: string | undefined;
    rewardsRate: string | undefined;
    introRewardsBonus: string | undefined;
    regularAPR: string | undefined;
    offerCollection: OfferCollection | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    details: string[] | undefined;
}

export class OfferFilter implements IOfferFilter {
    status!: CampaignStatus | undefined;
    type!: CampaignType | undefined;
    category!: CampaignCategory | undefined;
    country!: string | undefined;
    state!: string | undefined;
    creditScore!: CreditScoreRating | undefined;
    isOfferCollection!: boolean | undefined;
    itemOfOfferCollection!: OfferCollection | undefined;
    loanAmount!: number | undefined;
    cardNetworks!: CardNetwork[] | undefined;
    cardType!: CardType | undefined;
    securingType!: SecuringType | undefined;
    targetAudience!: TargetAudience | undefined;
    annualIncome!: number | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    campaignIds!: number[] | undefined;
    campaignUrls!: string[] | undefined;
    strictMatch!: boolean;

    constructor(data?: IOfferFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.type = _data["type"];
            this.category = _data["category"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.creditScore = _data["creditScore"];
            this.isOfferCollection = _data["isOfferCollection"];
            this.itemOfOfferCollection = _data["itemOfOfferCollection"];
            this.loanAmount = _data["loanAmount"];
            if (Array.isArray(_data["cardNetworks"])) {
                this.cardNetworks = [] as any;
                for (let item of _data["cardNetworks"])
                    this.cardNetworks!.push(item);
            }
            this.cardType = _data["cardType"];
            this.securingType = _data["securingType"];
            this.targetAudience = _data["targetAudience"];
            this.annualIncome = _data["annualIncome"];
            this.overallRating = _data["overallRating"];
            this.issuingBank = _data["issuingBank"];
            if (Array.isArray(_data["campaignIds"])) {
                this.campaignIds = [] as any;
                for (let item of _data["campaignIds"])
                    this.campaignIds!.push(item);
            }
            if (Array.isArray(_data["campaignUrls"])) {
                this.campaignUrls = [] as any;
                for (let item of _data["campaignUrls"])
                    this.campaignUrls!.push(item);
            }
            this.strictMatch = _data["strictMatch"];
        }
    }

    static fromJS(data: any): OfferFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OfferFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["type"] = this.type;
        data["category"] = this.category;
        data["country"] = this.country;
        data["state"] = this.state;
        data["creditScore"] = this.creditScore;
        data["isOfferCollection"] = this.isOfferCollection;
        data["itemOfOfferCollection"] = this.itemOfOfferCollection;
        data["loanAmount"] = this.loanAmount;
        if (Array.isArray(this.cardNetworks)) {
            data["cardNetworks"] = [];
            for (let item of this.cardNetworks)
                data["cardNetworks"].push(item);
        }
        data["cardType"] = this.cardType;
        data["securingType"] = this.securingType;
        data["targetAudience"] = this.targetAudience;
        data["annualIncome"] = this.annualIncome;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        if (Array.isArray(this.campaignIds)) {
            data["campaignIds"] = [];
            for (let item of this.campaignIds)
                data["campaignIds"].push(item);
        }
        if (Array.isArray(this.campaignUrls)) {
            data["campaignUrls"] = [];
            for (let item of this.campaignUrls)
                data["campaignUrls"].push(item);
        }
        data["strictMatch"] = this.strictMatch;
        return data;
    }
}

export interface IOfferFilter {
    status: CampaignStatus | undefined;
    type: CampaignType | undefined;
    category: CampaignCategory | undefined;
    country: string | undefined;
    state: string | undefined;
    creditScore: CreditScoreRating | undefined;
    isOfferCollection: boolean | undefined;
    itemOfOfferCollection: OfferCollection | undefined;
    loanAmount: number | undefined;
    cardNetworks: CardNetwork[] | undefined;
    cardType: CardType | undefined;
    securingType: SecuringType | undefined;
    targetAudience: TargetAudience | undefined;
    annualIncome: number | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    campaignIds: number[] | undefined;
    campaignUrls: string[] | undefined;
    strictMatch: boolean;
}

export enum OfferFlagType {
    Choice = "Choice",
    Best = "Best",
    TravelAndAirlineMiles = "TravelAndAirlineMiles",
    DinigRewards = "DinigRewards",
    GasRewards = "GasRewards",
    CashBackRewards = "CashBackRewards",
    InstantDecision = "InstantDecision",
    InstantResponse = "InstantResponse",
    NoCreditCheck = "NoCreditCheck",
    GuaranteedApproval = "GuaranteedApproval",
    RebuildCredit = "RebuildCredit",
    ChipCard = "ChipCard",
    ApplePay = "ApplePay",
    GroceryRewards = "GroceryRewards",
    EntertainmentRewards = "EntertainmentRewards",
    HotelRewards = "HotelRewards",
    HasNoRewards = "HasNoRewards",
    ZeroPercentageOnPurchases = "ZeroPercentageOnPurchases",
    ZeroPercentageInterestTransfers = "ZeroPercentageInterestTransfers",
    Special = "Special",
    Newest = "Newest",
}

export enum OfferProviderType {
    EPCVIP = "EPCVIP",
}

export class OngageSettingsEditDto implements IOngageSettingsEditDto {
    userName!: string | undefined;
    password!: string | undefined;
    accountCode!: string | undefined;
    defaultListId!: number | undefined;
    activationEmailMessageId!: number | undefined;
    isEnabled!: boolean;
    offerAnnouncementCampaignId!: string | undefined;

    constructor(data?: IOngageSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.accountCode = _data["accountCode"];
            this.defaultListId = _data["defaultListId"];
            this.activationEmailMessageId = _data["activationEmailMessageId"];
            this.isEnabled = _data["isEnabled"];
            this.offerAnnouncementCampaignId = _data["offerAnnouncementCampaignId"];
        }
    }

    static fromJS(data: any): OngageSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OngageSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["accountCode"] = this.accountCode;
        data["defaultListId"] = this.defaultListId;
        data["activationEmailMessageId"] = this.activationEmailMessageId;
        data["isEnabled"] = this.isEnabled;
        data["offerAnnouncementCampaignId"] = this.offerAnnouncementCampaignId;
        return data;
    }
}

export interface IOngageSettingsEditDto {
    userName: string | undefined;
    password: string | undefined;
    accountCode: string | undefined;
    defaultListId: number | undefined;
    activationEmailMessageId: number | undefined;
    isEnabled: boolean;
    offerAnnouncementCampaignId: string | undefined;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    authority!: string | undefined;
    loginUrl!: string | undefined;
    validateIssuer!: boolean;

    constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.loginUrl = _data["loginUrl"];
            this.validateIssuer = _data["validateIssuer"];
        }
    }

    static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIdConnectExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["loginUrl"] = this.loginUrl;
        data["validateIssuer"] = this.validateIssuer;
        return data;
    }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    authority: string | undefined;
    loginUrl: string | undefined;
    validateIssuer: boolean;
}

export class OptionDto implements IOptionDto {
    id!: number;
    questionId!: number;
    sortOrder!: number;
    text!: string | undefined;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.sortOrder = _data["sortOrder"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["sortOrder"] = this.sortOrder;
        data["text"] = this.text;
        return data;
    }
}

export interface IOptionDto {
    id: number;
    questionId: number;
    sortOrder: number;
    text: string | undefined;
}

export class OrderHistoryInfo implements IOrderHistoryInfo {
    time!: moment.Moment;
    type!: string | undefined;
    userId!: number | undefined;
    userFullName!: string | undefined;
    action!: string | undefined;
    stage!: string | undefined;

    constructor(data?: IOrderHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? moment(_data["time"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.userId = _data["userId"];
            this.userFullName = _data["userFullName"];
            this.action = _data["action"];
            this.stage = _data["stage"];
        }
    }

    static fromJS(data: any): OrderHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrderHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["userId"] = this.userId;
        data["userFullName"] = this.userFullName;
        data["action"] = this.action;
        data["stage"] = this.stage;
        return data;
    }
}

export interface IOrderHistoryInfo {
    time: moment.Moment;
    type: string | undefined;
    userId: number | undefined;
    userFullName: string | undefined;
    action: string | undefined;
    stage: string | undefined;
}

export class OrderSubscriptionDto implements IOrderSubscriptionDto {
    id!: number;
    originalStartDate!: moment.Moment;
    originalTrialEndDate!: moment.Moment | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;
    trialEndDate!: moment.Moment | undefined;
    gracePeriodDayCount!: number;
    readonly gracePeriodEndDate!: moment.Moment | undefined;
    productCode!: string | undefined;
    productName!: string | undefined;
    productThumbnailUrl!: string | undefined;
    fee!: number;
    statusCode!: string | undefined;
    status!: string | undefined;
    cancelationReason!: string | undefined;
    systemType!: string | undefined;
    systemMemberId!: string | undefined;
    previousSubscriptionId!: number | undefined;
    services!: SubscriptionServiceDto[] | undefined;
    payments!: SubscriptionPaymentDto[] | undefined;

    constructor(data?: IOrderSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.originalStartDate = _data["originalStartDate"] ? moment(_data["originalStartDate"].toString()) : <any>undefined;
            this.originalTrialEndDate = _data["originalTrialEndDate"] ? moment(_data["originalTrialEndDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.trialEndDate = _data["trialEndDate"] ? moment(_data["trialEndDate"].toString()) : <any>undefined;
            this.gracePeriodDayCount = _data["gracePeriodDayCount"];
            (<any>this).gracePeriodEndDate = _data["gracePeriodEndDate"] ? moment(_data["gracePeriodEndDate"].toString()) : <any>undefined;
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productThumbnailUrl = _data["productThumbnailUrl"];
            this.fee = _data["fee"];
            this.statusCode = _data["statusCode"];
            this.status = _data["status"];
            this.cancelationReason = _data["cancelationReason"];
            this.systemType = _data["systemType"];
            this.systemMemberId = _data["systemMemberId"];
            this.previousSubscriptionId = _data["previousSubscriptionId"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(SubscriptionServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(SubscriptionPaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["originalStartDate"] = this.originalStartDate ? this.originalStartDate.toISOString() : <any>undefined;
        data["originalTrialEndDate"] = this.originalTrialEndDate ? this.originalTrialEndDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trialEndDate"] = this.trialEndDate ? this.trialEndDate.toISOString() : <any>undefined;
        data["gracePeriodDayCount"] = this.gracePeriodDayCount;
        data["gracePeriodEndDate"] = this.gracePeriodEndDate ? this.gracePeriodEndDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productThumbnailUrl"] = this.productThumbnailUrl;
        data["fee"] = this.fee;
        data["statusCode"] = this.statusCode;
        data["status"] = this.status;
        data["cancelationReason"] = this.cancelationReason;
        data["systemType"] = this.systemType;
        data["systemMemberId"] = this.systemMemberId;
        data["previousSubscriptionId"] = this.previousSubscriptionId;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderSubscriptionDto {
    id: number;
    originalStartDate: moment.Moment;
    originalTrialEndDate: moment.Moment | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    trialEndDate: moment.Moment | undefined;
    gracePeriodDayCount: number;
    gracePeriodEndDate: moment.Moment | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productThumbnailUrl: string | undefined;
    fee: number;
    statusCode: string | undefined;
    status: string | undefined;
    cancelationReason: string | undefined;
    systemType: string | undefined;
    systemMemberId: string | undefined;
    previousSubscriptionId: number | undefined;
    services: SubscriptionServiceDto[] | undefined;
    payments: SubscriptionPaymentDto[] | undefined;
}

export class OrganizationContactInfoDto implements IOrganizationContactInfoDto {
    organization!: OrganizationInfoDto | undefined;
    contactPersons!: PersonShortInfoDto[] | undefined;
    isUpdatable!: boolean;
    id!: number;
    fullName!: string | undefined;
    userId!: number | undefined;
    primaryEmailId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryPhoto!: string | undefined;
    details!: ContactInfoDetailsDto | undefined;
    comment!: string | undefined;

    constructor(data?: IOrganizationContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"] ? OrganizationInfoDto.fromJS(_data["organization"]) : <any>undefined;
            if (Array.isArray(_data["contactPersons"])) {
                this.contactPersons = [] as any;
                for (let item of _data["contactPersons"])
                    this.contactPersons!.push(PersonShortInfoDto.fromJS(item));
            }
            this.isUpdatable = _data["isUpdatable"];
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.userId = _data["userId"];
            this.primaryEmailId = _data["primaryEmailId"];
            this.primaryPhoneId = _data["primaryPhoneId"];
            this.primaryAddressId = _data["primaryAddressId"];
            this.primaryPhoto = _data["primaryPhoto"];
            this.details = _data["details"] ? ContactInfoDetailsDto.fromJS(_data["details"]) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): OrganizationContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        if (Array.isArray(this.contactPersons)) {
            data["contactPersons"] = [];
            for (let item of this.contactPersons)
                data["contactPersons"].push(item.toJSON());
        }
        data["isUpdatable"] = this.isUpdatable;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userId"] = this.userId;
        data["primaryEmailId"] = this.primaryEmailId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryPhoto"] = this.primaryPhoto;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IOrganizationContactInfoDto {
    organization: OrganizationInfoDto | undefined;
    contactPersons: PersonShortInfoDto[] | undefined;
    isUpdatable: boolean;
    id: number;
    fullName: string | undefined;
    userId: number | undefined;
    primaryEmailId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
    primaryPhoto: string | undefined;
    details: ContactInfoDetailsDto | undefined;
    comment: string | undefined;
}

export class OrganizationInfoDto implements IOrganizationInfoDto {
    rootOrganizationUnitId!: number | undefined;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    affiliateCode!: string | undefined;
    departmentCode!: string | undefined;

    constructor(data?: IOrganizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootOrganizationUnitId = _data["rootOrganizationUnitId"];
            this.companyName = _data["companyName"];
            this.shortName = _data["shortName"];
            this.typeId = _data["typeId"];
            this.industry = _data["industry"];
            this.annualRevenue = _data["annualRevenue"];
            this.ein = _data["ein"];
            this.businessSicCode = _data["businessSicCode"];
            this.formedCountryId = _data["formedCountryId"];
            this.formedStateId = _data["formedStateId"];
            this.description = _data["description"];
            this.formedDate = _data["formedDate"] ? moment(_data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = _data["sizeFrom"];
            this.sizeTo = _data["sizeTo"];
            this.duns = _data["duns"];
            this.ticker = _data["ticker"];
            this.affiliateCode = _data["affiliateCode"];
            this.departmentCode = _data["departmentCode"];
        }
    }

    static fromJS(data: any): OrganizationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootOrganizationUnitId"] = this.rootOrganizationUnitId;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["affiliateCode"] = this.affiliateCode;
        data["departmentCode"] = this.departmentCode;
        return data;
    }
}

export interface IOrganizationInfoDto {
    rootOrganizationUnitId: number | undefined;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    affiliateCode: string | undefined;
    departmentCode: string | undefined;
}

export class OrganizationShortInfo implements IOrganizationShortInfo {
    id!: number;
    name!: string | undefined;
    thumbnail!: string | undefined;
    rootOrganizationUnitId!: number | undefined;

    constructor(data?: IOrganizationShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.thumbnail = _data["thumbnail"];
            this.rootOrganizationUnitId = _data["rootOrganizationUnitId"];
        }
    }

    static fromJS(data: any): OrganizationShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["thumbnail"] = this.thumbnail;
        data["rootOrganizationUnitId"] = this.rootOrganizationUnitId;
        return data;
    }
}

export interface IOrganizationShortInfo {
    id: number;
    name: string | undefined;
    thumbnail: string | undefined;
    rootOrganizationUnitId: number | undefined;
}

export class OrganizationTypeDto implements IOrganizationTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IOrganizationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OrganizationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IOrganizationTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? moment(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class OrganizationUnitShortDto implements IOrganizationUnitShortDto {
    id!: number;
    displayName!: string | undefined;
    parentId!: number | undefined;

    constructor(data?: IOrganizationUnitShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): OrganizationUnitShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IOrganizationUnitShortDto {
    id: number;
    displayName: string | undefined;
    parentId: number | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? moment(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class PackageConfigDto implements IPackageConfigDto {
    id!: number;
    module!: ModuleType;
    moduleName!: string | undefined;
    name!: string | undefined;
    bestValue!: boolean;
    sortOrder!: number;
    editions!: PackageEditionConfigDto[] | undefined;

    constructor(data?: IPackageConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.module = _data["module"];
            this.moduleName = _data["moduleName"];
            this.name = _data["name"];
            this.bestValue = _data["bestValue"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["editions"])) {
                this.editions = [] as any;
                for (let item of _data["editions"])
                    this.editions!.push(PackageEditionConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["module"] = this.module;
        data["moduleName"] = this.moduleName;
        data["name"] = this.name;
        data["bestValue"] = this.bestValue;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.editions)) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPackageConfigDto {
    id: number;
    module: ModuleType;
    moduleName: string | undefined;
    name: string | undefined;
    bestValue: boolean;
    sortOrder: number;
    editions: PackageEditionConfigDto[] | undefined;
}

export class PackageDto implements IPackageDto {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;
    initialPaymentAmount!: number;
    trialPeriodDays!: number;
    monthlyPaymentAmount!: number;
    isActive!: boolean;
    isDemo!: boolean;
    isSimulatorEnabled!: boolean;

    constructor(data?: IPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.initialPaymentAmount = _data["initialPaymentAmount"];
            this.trialPeriodDays = _data["trialPeriodDays"];
            this.monthlyPaymentAmount = _data["monthlyPaymentAmount"];
            this.isActive = _data["isActive"];
            this.isDemo = _data["isDemo"];
            this.isSimulatorEnabled = _data["isSimulatorEnabled"];
        }
    }

    static fromJS(data: any): PackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["initialPaymentAmount"] = this.initialPaymentAmount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["monthlyPaymentAmount"] = this.monthlyPaymentAmount;
        data["isActive"] = this.isActive;
        data["isDemo"] = this.isDemo;
        data["isSimulatorEnabled"] = this.isSimulatorEnabled;
        return data;
    }
}

export interface IPackageDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
    initialPaymentAmount: number;
    trialPeriodDays: number;
    monthlyPaymentAmount: number;
    isActive: boolean;
    isDemo: boolean;
    isSimulatorEnabled: boolean;
}

export class PackageEditionConfigDto implements IPackageEditionConfigDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number;
    annualPrice!: number;
    trialDayCount!: number;
    maxUserCount!: number;
    features!: PackageEditionConfigFeatureDto[] | undefined;

    constructor(data?: IPackageEditionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.maxUserCount = _data["maxUserCount"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(PackageEditionConfigFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageEditionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageEditionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["maxUserCount"] = this.maxUserCount;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPackageEditionConfigDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number;
    annualPrice: number;
    trialDayCount: number;
    maxUserCount: number;
    features: PackageEditionConfigFeatureDto[] | undefined;
}

export class PackageEditionConfigFeatureDto implements IPackageEditionConfigFeatureDto {
    definition!: PricingTableFeatureDefinition | undefined;
    value!: string | undefined;

    constructor(data?: IPackageEditionConfigFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.definition = _data["definition"] ? PricingTableFeatureDefinition.fromJS(_data["definition"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PackageEditionConfigFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageEditionConfigFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definition"] = this.definition ? this.definition.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

export interface IPackageEditionConfigFeatureDto {
    definition: PricingTableFeatureDefinition | undefined;
    value: string | undefined;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class PagedResultDtoOfMessageListDto implements IPagedResultDtoOfMessageListDto {
    totalCount!: number;
    items!: MessageListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMessageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMessageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMessageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMessageListDto {
    totalCount: number;
    items: MessageListDto[] | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;
}

export class PagedResultDtoOfUserLoginAttemptDto implements IPagedResultDtoOfUserLoginAttemptDto {
    totalCount!: number;
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserLoginAttemptDto {
    totalCount: number;
    items: UserLoginAttemptDto[] | undefined;
}

export enum ParameterHandlerType {
    Default = "Default",
}

export enum ParkingType {
    DedicatedPad = 1,
    Garage = 2,
    OutdoorLot = 4,
    Street = 8,
    Underground = 16,
}

export class PartnerInfoDto implements IPartnerInfoDto {
    typeId!: number | undefined;

    constructor(data?: IPartnerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): PartnerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        return data;
    }
}

export interface IPartnerInfoDto {
    typeId: number | undefined;
}

export class PartnerTypeDto implements IPartnerTypeDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IPartnerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PartnerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPartnerTypeDto {
    id: number;
    name: string | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PasswordComplexitySettingsEditDto implements IPasswordComplexitySettingsEditDto {
    current!: PasswordComplexitySetting | undefined;
    default!: PasswordComplexitySetting | undefined;
    isDefaultUsed!: boolean;

    constructor(data?: IPasswordComplexitySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.current = _data["current"] ? PasswordComplexitySetting.fromJS(_data["current"]) : <any>undefined;
            this.default = _data["default"] ? PasswordComplexitySetting.fromJS(_data["default"]) : <any>undefined;
            this.isDefaultUsed = _data["isDefaultUsed"];
        }
    }

    static fromJS(data: any): PasswordComplexitySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current"] = this.current ? this.current.toJSON() : <any>undefined;
        data["default"] = this.default ? this.default.toJSON() : <any>undefined;
        data["isDefaultUsed"] = this.isDefaultUsed;
        return data;
    }
}

export interface IPasswordComplexitySettingsEditDto {
    current: PasswordComplexitySetting | undefined;
    default: PasswordComplexitySetting | undefined;
    isDefaultUsed: boolean;
}

export enum PayFrequency {
    Weekly = "Weekly",
    BiWeekly = "BiWeekly",
    Monthly = "Monthly",
    SemiMonthly = "SemiMonthly",
}

export class PaymentAuthorizeResponseDto implements IPaymentAuthorizeResponseDto {
    success!: boolean;
    errors!: string[] | undefined;

    constructor(data?: IPaymentAuthorizeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): PaymentAuthorizeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAuthorizeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IPaymentAuthorizeResponseDto {
    success: boolean;
    errors: string[] | undefined;
}

export enum PaymentInfoType {
    BankCard = "BankCard",
    ACH = "ACH",
    PayPal = "PayPal",
}

export enum PaymentMethod {
    Recurring = "Recurring",
    Charge = "Charge",
    Capture = "Capture",
    Void = "Void",
    Manual = "Manual",
}

export class PaymentMethodInfo implements IPaymentMethodInfo {
    type!: PaymentInfoType;
    achCustomerInfo!: ACHCustomerShortInfo | undefined;
    bankCardInfo!: BankCardShortInfo | undefined;

    constructor(data?: IPaymentMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.achCustomerInfo = _data["achCustomerInfo"] ? ACHCustomerShortInfo.fromJS(_data["achCustomerInfo"]) : <any>undefined;
            this.bankCardInfo = _data["bankCardInfo"] ? BankCardShortInfo.fromJS(_data["bankCardInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentMethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["achCustomerInfo"] = this.achCustomerInfo ? this.achCustomerInfo.toJSON() : <any>undefined;
        data["bankCardInfo"] = this.bankCardInfo ? this.bankCardInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentMethodInfo {
    type: PaymentInfoType;
    achCustomerInfo: ACHCustomerShortInfo | undefined;
    bankCardInfo: BankCardShortInfo | undefined;
}

export enum PaymentPeriodType {
    Monthly = "Monthly",
    Annual = "Annual",
    LifeTime = "LifeTime",
}

export class PaymentRequestInfoDto implements IPaymentRequestInfoDto {
    paymentMethod!: PaymentMethod;
    paymentInfoType!: PaymentInfoType;
    bankCard!: BankCardInfoDto | undefined;
    achCustomer!: ACHCustomerInfoDto | undefined;
    payPal!: PayPalInfoDto | undefined;

    constructor(data?: IPaymentRequestInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethod = _data["paymentMethod"];
            this.paymentInfoType = _data["paymentInfoType"];
            this.bankCard = _data["bankCard"] ? BankCardInfoDto.fromJS(_data["bankCard"]) : <any>undefined;
            this.achCustomer = _data["achCustomer"] ? ACHCustomerInfoDto.fromJS(_data["achCustomer"]) : <any>undefined;
            this.payPal = _data["payPal"] ? PayPalInfoDto.fromJS(_data["payPal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentRequestInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod;
        data["paymentInfoType"] = this.paymentInfoType;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["payPal"] = this.payPal ? this.payPal.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentRequestInfoDto {
    paymentMethod: PaymentMethod;
    paymentInfoType: PaymentInfoType;
    bankCard: BankCardInfoDto | undefined;
    achCustomer: ACHCustomerInfoDto | undefined;
    payPal: PayPalInfoDto | undefined;
}

export enum PaymentSystem {
    CheckPayment = "CheckPayment",
    CreditAccountBalance = "CreditAccountBalance",
    CryptoBitcoin = "CryptoBitcoin",
    DebitCardTransfer = "DebitCardTransfer",
    TransferBankACH = "TransferBankACH",
    TransferBankSEPA = "TransferBankSEPA",
    TransferBankWire = "TransferBankWire",
    PayQuicker = "PayQuicker",
    PayPal = "PayPal",
    SpersePay = "SpersePay",
    Tipalti = "Tipalti",
}

export enum PaymentTransactionType {
    Authorize = "Authorize",
    Capture = "Capture",
    Refund = "Refund",
    Chargeback = "Chargeback",
    Sale = "Sale",
    Manual = "Manual",
}

export class PayPalDto implements IPayPalDto {
    paymentId!: string;
    payerId!: string;

    constructor(data?: IPayPalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
        }
    }

    static fromJS(data: any): PayPalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        return data;
    }
}

export interface IPayPalDto {
    paymentId: string;
    payerId: string;
}

export class PayPalInfoDto implements IPayPalInfoDto {
    paymentId!: string | undefined;
    payerId!: string | undefined;

    constructor(data?: IPayPalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
        }
    }

    static fromJS(data: any): PayPalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        return data;
    }
}

export interface IPayPalInfoDto {
    paymentId: string | undefined;
    payerId: string | undefined;
}

export class PayPalSettings implements IPayPalSettings {
    environment!: string | undefined;
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IPayPalSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.environment = _data["environment"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): PayPalSettings {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environment"] = this.environment;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface IPayPalSettings {
    environment: string | undefined;
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class PayPalSettingsDto implements IPayPalSettingsDto {
    clientId!: string | undefined;

    constructor(data?: IPayPalSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): PayPalSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        return data;
    }
}

export interface IPayPalSettingsDto {
    clientId: string | undefined;
}

export class PendingCommissionContactInfo implements IPendingCommissionContactInfo {
    id!: number;
    name!: string | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: IPendingCommissionContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.affiliateCode = _data["affiliateCode"];
        }
    }

    static fromJS(data: any): PendingCommissionContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PendingCommissionContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["affiliateCode"] = this.affiliateCode;
        return data;
    }
}

export interface IPendingCommissionContactInfo {
    id: number;
    name: string | undefined;
    affiliateCode: string | undefined;
}

export class Period implements IPeriod {
    start!: moment.Moment;
    end!: moment.Moment;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? moment(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? moment(_data["end"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPeriod {
    start: moment.Moment;
    end: moment.Moment;
}

export enum PeriodScope {
    Days = "Days",
    Weeks = "Weeks",
    Months = "Months",
    Quarters = "Quarters",
    Years = "Years",
    None = "None",
}

export enum Permissions {
    None = "None",
    Read = "Read",
    Write = "Write",
    All = "All",
}

export class PersonalInfoDto implements IPersonalInfoDto {
    name!: string | undefined;
    doB!: moment.Moment | undefined;
    currentAddress!: AddressDto | undefined;
    previousAddresses!: AddressDto[] | undefined;
    employers!: EmployerDto[] | undefined;

    constructor(data?: IPersonalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.currentAddress = _data["currentAddress"] ? AddressDto.fromJS(_data["currentAddress"]) : <any>undefined;
            if (Array.isArray(_data["previousAddresses"])) {
                this.previousAddresses = [] as any;
                for (let item of _data["previousAddresses"])
                    this.previousAddresses!.push(AddressDto.fromJS(item));
            }
            if (Array.isArray(_data["employers"])) {
                this.employers = [] as any;
                for (let item of _data["employers"])
                    this.employers!.push(EmployerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["currentAddress"] = this.currentAddress ? this.currentAddress.toJSON() : <any>undefined;
        if (Array.isArray(this.previousAddresses)) {
            data["previousAddresses"] = [];
            for (let item of this.previousAddresses)
                data["previousAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.employers)) {
            data["employers"] = [];
            for (let item of this.employers)
                data["employers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPersonalInfoDto {
    name: string | undefined;
    doB: moment.Moment | undefined;
    currentAddress: AddressDto | undefined;
    previousAddresses: AddressDto[] | undefined;
    employers: EmployerDto[] | undefined;
}

export class PersonalInformation implements IPersonalInformation {
    firstName!: string;
    lastName!: string;
    middleName!: string | undefined;
    email!: string;
    alternateEmail!: string | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    licenseNumber!: string | undefined;
    licenseState!: string | undefined;
    isActiveMilitary!: boolean | undefined;
    phone!: string | undefined;
    phoneMobile!: string | undefined;
    preferredContactTOD!: TimeOfDay | undefined;
    address1!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isHomeOwner!: boolean | undefined;
    monthsAtAddress!: number | undefined;
    creditScoreRating!: CreditScoreRating | undefined;
    gender!: Gender | undefined;
    timezone!: string | undefined;

    constructor(data?: IPersonalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.email = _data["email"];
            this.alternateEmail = _data["alternateEmail"];
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.licenseNumber = _data["licenseNumber"];
            this.licenseState = _data["licenseState"];
            this.isActiveMilitary = _data["isActiveMilitary"];
            this.phone = _data["phone"];
            this.phoneMobile = _data["phoneMobile"];
            this.preferredContactTOD = _data["preferredContactTOD"];
            this.address1 = _data["address1"];
            this.city = _data["city"];
            this.stateCode = _data["stateCode"];
            this.postalCode = _data["postalCode"];
            this.countryCode = _data["countryCode"];
            this.isHomeOwner = _data["isHomeOwner"];
            this.monthsAtAddress = _data["monthsAtAddress"];
            this.creditScoreRating = _data["creditScoreRating"];
            this.gender = _data["gender"];
            this.timezone = _data["timezone"];
        }
    }

    static fromJS(data: any): PersonalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["alternateEmail"] = this.alternateEmail;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseState"] = this.licenseState;
        data["isActiveMilitary"] = this.isActiveMilitary;
        data["phone"] = this.phone;
        data["phoneMobile"] = this.phoneMobile;
        data["preferredContactTOD"] = this.preferredContactTOD;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isHomeOwner"] = this.isHomeOwner;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["creditScoreRating"] = this.creditScoreRating;
        data["gender"] = this.gender;
        data["timezone"] = this.timezone;
        return data;
    }
}

export interface IPersonalInformation {
    firstName: string;
    lastName: string;
    middleName: string | undefined;
    email: string;
    alternateEmail: string | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    licenseNumber: string | undefined;
    licenseState: string | undefined;
    isActiveMilitary: boolean | undefined;
    phone: string | undefined;
    phoneMobile: string | undefined;
    preferredContactTOD: TimeOfDay | undefined;
    address1: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isHomeOwner: boolean | undefined;
    monthsAtAddress: number | undefined;
    creditScoreRating: CreditScoreRating | undefined;
    gender: Gender | undefined;
    timezone: string | undefined;
}

export class PersonalInformationExtended implements IPersonalInformationExtended {
    address2!: string | undefined;
    firstName!: string;
    lastName!: string;
    middleName!: string | undefined;
    email!: string;
    alternateEmail!: string | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    licenseNumber!: string | undefined;
    licenseState!: string | undefined;
    isActiveMilitary!: boolean | undefined;
    phone!: string | undefined;
    phoneMobile!: string | undefined;
    preferredContactTOD!: TimeOfDay | undefined;
    address1!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isHomeOwner!: boolean | undefined;
    monthsAtAddress!: number | undefined;
    creditScoreRating!: CreditScoreRating | undefined;
    gender!: Gender | undefined;
    timezone!: string | undefined;

    constructor(data?: IPersonalInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address2 = _data["address2"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.email = _data["email"];
            this.alternateEmail = _data["alternateEmail"];
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.licenseNumber = _data["licenseNumber"];
            this.licenseState = _data["licenseState"];
            this.isActiveMilitary = _data["isActiveMilitary"];
            this.phone = _data["phone"];
            this.phoneMobile = _data["phoneMobile"];
            this.preferredContactTOD = _data["preferredContactTOD"];
            this.address1 = _data["address1"];
            this.city = _data["city"];
            this.stateCode = _data["stateCode"];
            this.postalCode = _data["postalCode"];
            this.countryCode = _data["countryCode"];
            this.isHomeOwner = _data["isHomeOwner"];
            this.monthsAtAddress = _data["monthsAtAddress"];
            this.creditScoreRating = _data["creditScoreRating"];
            this.gender = _data["gender"];
            this.timezone = _data["timezone"];
        }
    }

    static fromJS(data: any): PersonalInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["alternateEmail"] = this.alternateEmail;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseState"] = this.licenseState;
        data["isActiveMilitary"] = this.isActiveMilitary;
        data["phone"] = this.phone;
        data["phoneMobile"] = this.phoneMobile;
        data["preferredContactTOD"] = this.preferredContactTOD;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isHomeOwner"] = this.isHomeOwner;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["creditScoreRating"] = this.creditScoreRating;
        data["gender"] = this.gender;
        data["timezone"] = this.timezone;
        return data;
    }
}

export interface IPersonalInformationExtended {
    address2: string | undefined;
    firstName: string;
    lastName: string;
    middleName: string | undefined;
    email: string;
    alternateEmail: string | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    licenseNumber: string | undefined;
    licenseState: string | undefined;
    isActiveMilitary: boolean | undefined;
    phone: string | undefined;
    phoneMobile: string | undefined;
    preferredContactTOD: TimeOfDay | undefined;
    address1: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isHomeOwner: boolean | undefined;
    monthsAtAddress: number | undefined;
    creditScoreRating: CreditScoreRating | undefined;
    gender: Gender | undefined;
    timezone: string | undefined;
}

export class PersonContactInfoDto implements IPersonContactInfoDto {
    person!: PersonInfoDto | undefined;
    jobTitle!: string | undefined;
    orgRelationId!: number | undefined;
    xref!: string | undefined;
    userEmailAddress!: string | undefined;
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;
    stripeCustomerId!: string | undefined;
    orgRelations!: PersonOrgRelationShortInfo[] | undefined;
    id!: number;
    fullName!: string | undefined;
    userId!: number | undefined;
    primaryEmailId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryPhoto!: string | undefined;
    details!: ContactInfoDetailsDto | undefined;
    comment!: string | undefined;

    constructor(data?: IPersonContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.person = _data["person"] ? PersonInfoDto.fromJS(_data["person"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"];
            this.orgRelationId = _data["orgRelationId"];
            this.xref = _data["xref"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.customField1 = _data["customField1"];
            this.customField2 = _data["customField2"];
            this.customField3 = _data["customField3"];
            this.customField4 = _data["customField4"];
            this.customField5 = _data["customField5"];
            this.stripeCustomerId = _data["stripeCustomerId"];
            if (Array.isArray(_data["orgRelations"])) {
                this.orgRelations = [] as any;
                for (let item of _data["orgRelations"])
                    this.orgRelations!.push(PersonOrgRelationShortInfo.fromJS(item));
            }
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.userId = _data["userId"];
            this.primaryEmailId = _data["primaryEmailId"];
            this.primaryPhoneId = _data["primaryPhoneId"];
            this.primaryAddressId = _data["primaryAddressId"];
            this.primaryPhoto = _data["primaryPhoto"];
            this.details = _data["details"] ? ContactInfoDetailsDto.fromJS(_data["details"]) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): PersonContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["orgRelationId"] = this.orgRelationId;
        data["xref"] = this.xref;
        data["userEmailAddress"] = this.userEmailAddress;
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        data["stripeCustomerId"] = this.stripeCustomerId;
        if (Array.isArray(this.orgRelations)) {
            data["orgRelations"] = [];
            for (let item of this.orgRelations)
                data["orgRelations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userId"] = this.userId;
        data["primaryEmailId"] = this.primaryEmailId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryPhoto"] = this.primaryPhoto;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IPersonContactInfoDto {
    person: PersonInfoDto | undefined;
    jobTitle: string | undefined;
    orgRelationId: number | undefined;
    xref: string | undefined;
    userEmailAddress: string | undefined;
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
    stripeCustomerId: string | undefined;
    orgRelations: PersonOrgRelationShortInfo[] | undefined;
    id: number;
    fullName: string | undefined;
    userId: number | undefined;
    primaryEmailId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
    primaryPhoto: string | undefined;
    details: ContactInfoDetailsDto | undefined;
    comment: string | undefined;
}

export class PersonHistoryDto implements IPersonHistoryDto {
    id!: number;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    creatorUserName!: string | undefined;
    creatorUserPhotoPublicId!: string | undefined;
    source!: string | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    monthlyGoal!: number | undefined;

    constructor(data?: IPersonHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creatorUserPhotoPublicId = _data["creatorUserPhotoPublicId"];
            this.source = _data["source"];
            this.namePrefix = _data["namePrefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
            this.dob = _data["dob"] ? moment(_data["dob"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.bankCode = _data["bankCode"];
            this.timeZone = _data["timeZone"];
            this.maritalStatus = _data["maritalStatus"];
            this.marriageDate = _data["marriageDate"] ? moment(_data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.isUSCitizen = _data["isUSCitizen"];
            this.citizenship = _data["citizenship"];
            this.experience = _data["experience"];
            this.profileSummary = _data["profileSummary"];
            this.preferredToD = _data["preferredToD"];
            this.drivingLicense = _data["drivingLicense"];
            this.drivingLicenseState = _data["drivingLicenseState"];
            this.isActiveMilitaryDuty = _data["isActiveMilitaryDuty"];
            this.monthlyGoal = _data["monthlyGoal"];
        }
    }

    static fromJS(data: any): PersonHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creatorUserPhotoPublicId"] = this.creatorUserPhotoPublicId;
        data["source"] = this.source;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        data["monthlyGoal"] = this.monthlyGoal;
        return data;
    }
}

export interface IPersonHistoryDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creatorUserPhotoPublicId: string | undefined;
    source: string | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    monthlyGoal: number | undefined;
}

export class PersonInfo implements IPersonInfo {
    fullName!: string | undefined;
    email!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;

    constructor(data?: IPersonInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.companyName = _data["companyName"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): PersonInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface IPersonInfo {
    fullName: string | undefined;
    email: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
}

export class PersonInfoDto implements IPersonInfoDto {
    namePrefix!: string | undefined;
    middleName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    identityConfirmationDate!: moment.Moment | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    interests!: string[] | undefined;
    contactId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IPersonInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.namePrefix = _data["namePrefix"];
            this.middleName = _data["middleName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
            this.dob = _data["dob"] ? moment(_data["dob"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.bankCode = _data["bankCode"];
            this.identityConfirmationDate = _data["identityConfirmationDate"] ? moment(_data["identityConfirmationDate"].toString()) : <any>undefined;
            this.timeZone = _data["timeZone"];
            this.maritalStatus = _data["maritalStatus"];
            this.marriageDate = _data["marriageDate"] ? moment(_data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.isUSCitizen = _data["isUSCitizen"];
            this.citizenship = _data["citizenship"];
            this.experience = _data["experience"];
            this.profileSummary = _data["profileSummary"];
            this.preferredToD = _data["preferredToD"];
            this.drivingLicense = _data["drivingLicense"];
            this.drivingLicenseState = _data["drivingLicenseState"];
            this.isActiveMilitaryDuty = _data["isActiveMilitaryDuty"];
            if (Array.isArray(_data["interests"])) {
                this.interests = [] as any;
                for (let item of _data["interests"])
                    this.interests!.push(item);
            }
            this.contactId = _data["contactId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): PersonInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["middleName"] = this.middleName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["identityConfirmationDate"] = this.identityConfirmationDate ? this.identityConfirmationDate.toISOString() : <any>undefined;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (Array.isArray(this.interests)) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IPersonInfoDto {
    namePrefix: string | undefined;
    middleName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    identityConfirmationDate: moment.Moment | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    interests: string[] | undefined;
    contactId: number;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class PersonOrgRelationShortInfo implements IPersonOrgRelationShortInfo {
    id!: number;
    isActive!: boolean;
    isPrimary!: boolean;
    organization!: OrganizationShortInfo | undefined;
    relationType!: PersonOrgRelationTypeInfo | undefined;
    jobTitle!: string | undefined;

    constructor(data?: IPersonOrgRelationShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
            this.isPrimary = _data["isPrimary"];
            this.organization = _data["organization"] ? OrganizationShortInfo.fromJS(_data["organization"]) : <any>undefined;
            this.relationType = _data["relationType"] ? PersonOrgRelationTypeInfo.fromJS(_data["relationType"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): PersonOrgRelationShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isPrimary"] = this.isPrimary;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["relationType"] = this.relationType ? this.relationType.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface IPersonOrgRelationShortInfo {
    id: number;
    isActive: boolean;
    isPrimary: boolean;
    organization: OrganizationShortInfo | undefined;
    relationType: PersonOrgRelationTypeInfo | undefined;
    jobTitle: string | undefined;
}

export class PersonOrgRelationTypeInfo implements IPersonOrgRelationTypeInfo {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IPersonOrgRelationTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PersonOrgRelationTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPersonOrgRelationTypeInfo {
    id: string | undefined;
    name: string | undefined;
}

export class PersonShortInfoDto implements IPersonShortInfoDto {
    id!: number;
    fullName!: string | undefined;
    jobTitle!: string | undefined;
    ratingId!: number | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IPersonShortInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.jobTitle = _data["jobTitle"];
            this.ratingId = _data["ratingId"];
            this.photoPublicId = _data["photoPublicId"];
        }
    }

    static fromJS(data: any): PersonShortInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonShortInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["jobTitle"] = this.jobTitle;
        data["ratingId"] = this.ratingId;
        data["photoPublicId"] = this.photoPublicId;
        return data;
    }
}

export interface IPersonShortInfoDto {
    id: number;
    fullName: string | undefined;
    jobTitle: string | undefined;
    ratingId: number | undefined;
    photoPublicId: string | undefined;
}

export enum PestsType {
    Termites = "Termites",
    Rodents = "Rodents",
    Insects = "Insects",
    Other = "Other",
}

export enum PetFeeType {
    OneTime = "OneTime",
    Monthly = "Monthly",
    Refundable = "Refundable",
}

export class PhoneUsageTypeDto implements IPhoneUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean;

    constructor(data?: IPhoneUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isCompany = _data["isCompany"];
        }
    }

    static fromJS(data: any): PhoneUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data;
    }
}

export interface IPhoneUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean;
}

export class PinNoteInput implements IPinNoteInput {
    contactId!: number;
    noteId!: number;

    constructor(data?: IPinNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.noteId = _data["noteId"];
        }
    }

    static fromJS(data: any): PinNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new PinNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["noteId"] = this.noteId;
        return data;
    }
}

export interface IPinNoteInput {
    contactId: number;
    noteId: number;
}

export class PipelineCreateInput implements IPipelineCreateInput {
    name!: string | undefined;
    purposeId!: string;
    contactGroupId!: string;
    entityTypeId!: number | undefined;

    constructor(data?: IPipelineCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.purposeId = _data["purposeId"];
            this.contactGroupId = _data["contactGroupId"];
            this.entityTypeId = _data["entityTypeId"];
        }
    }

    static fromJS(data: any): PipelineCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["purposeId"] = this.purposeId;
        data["contactGroupId"] = this.contactGroupId;
        data["entityTypeId"] = this.entityTypeId;
        return data;
    }
}

export interface IPipelineCreateInput {
    name: string | undefined;
    purposeId: string;
    contactGroupId: string;
    entityTypeId: number | undefined;
}

export class PipelineDto implements IPipelineDto {
    id!: number;
    name!: string | undefined;
    purposeId!: string | undefined;
    purpose!: string | undefined;
    contactGroupId!: string | undefined;
    entityTypeId!: number | undefined;
    entityTypeSysId!: string | undefined;
    stages!: StageDto[] | undefined;

    constructor(data?: IPipelineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.purposeId = _data["purposeId"];
            this.purpose = _data["purpose"];
            this.contactGroupId = _data["contactGroupId"];
            this.entityTypeId = _data["entityTypeId"];
            this.entityTypeSysId = _data["entityTypeSysId"];
            if (Array.isArray(_data["stages"])) {
                this.stages = [] as any;
                for (let item of _data["stages"])
                    this.stages!.push(StageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PipelineDto {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["purposeId"] = this.purposeId;
        data["purpose"] = this.purpose;
        data["contactGroupId"] = this.contactGroupId;
        data["entityTypeId"] = this.entityTypeId;
        data["entityTypeSysId"] = this.entityTypeSysId;
        if (Array.isArray(this.stages)) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPipelineDto {
    id: number;
    name: string | undefined;
    purposeId: string | undefined;
    purpose: string | undefined;
    contactGroupId: string | undefined;
    entityTypeId: number | undefined;
    entityTypeSysId: string | undefined;
    stages: StageDto[] | undefined;
}

export class PipelineRenameInput implements IPipelineRenameInput {
    id!: number;
    name!: string;

    constructor(data?: IPipelineRenameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PipelineRenameInput {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineRenameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPipelineRenameInput {
    id: number;
    name: string;
}

export enum PlatformDayOfWeek {
    Sunday = 1,
    Monday = 2,
    Tuesday = 4,
    Wednesday = 8,
    Thursday = 16,
    Friday = 32,
    Saturday = 64,
}

export enum PreferredProperties {
    FullName = 1,
    ContactDate = 2,
    BANKCode = 4,
}

export class PricingTableFeatureDefinition implements IPricingTableFeatureDefinition {
    name!: string | undefined;
    displayName!: LocalizableString | undefined;
    isVariable!: boolean;
    sortOrder!: number;
    isStatic!: boolean;
    measurementUnit!: MeasurementUnit | undefined;
    isCommon!: boolean;

    constructor(data?: IPricingTableFeatureDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"] ? LocalizableString.fromJS(_data["displayName"]) : <any>undefined;
            this.isVariable = _data["isVariable"];
            this.sortOrder = _data["sortOrder"];
            this.isStatic = _data["isStatic"];
            this.measurementUnit = _data["measurementUnit"];
            this.isCommon = _data["isCommon"];
        }
    }

    static fromJS(data: any): PricingTableFeatureDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new PricingTableFeatureDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["isVariable"] = this.isVariable;
        data["sortOrder"] = this.sortOrder;
        data["isStatic"] = this.isStatic;
        data["measurementUnit"] = this.measurementUnit;
        data["isCommon"] = this.isCommon;
        return data;
    }
}

export interface IPricingTableFeatureDefinition {
    name: string | undefined;
    displayName: LocalizableString | undefined;
    isVariable: boolean;
    sortOrder: number;
    isStatic: boolean;
    measurementUnit: MeasurementUnit | undefined;
    isCommon: boolean;
}

export class PrimaryContactInfo implements IPrimaryContactInfo {
    primaryEmailId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;

    constructor(data?: IPrimaryContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primaryEmailId = _data["primaryEmailId"];
            this.primaryPhoneId = _data["primaryPhoneId"];
            this.primaryAddressId = _data["primaryAddressId"];
        }
    }

    static fromJS(data: any): PrimaryContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PrimaryContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryEmailId"] = this.primaryEmailId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        return data;
    }
}

export interface IPrimaryContactInfo {
    primaryEmailId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
}

export class ProcessLeadConfiguration implements IProcessLeadConfiguration {

    constructor(data?: IProcessLeadConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ProcessLeadConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLeadConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IProcessLeadConfiguration {
}

export class ProcessLeadInput implements IProcessLeadInput {
    leadId!: number;
    orderStageId!: number | undefined;
    amount!: number | undefined;
    comment!: string | undefined;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean;

    constructor(data?: IProcessLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.orderStageId = _data["orderStageId"];
            this.amount = _data["amount"];
            this.comment = _data["comment"];
            this.sortOrder = _data["sortOrder"];
            this.ignoreChecklist = _data["ignoreChecklist"];
        }
    }

    static fromJS(data: any): ProcessLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["orderStageId"] = this.orderStageId;
        data["amount"] = this.amount;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        return data;
    }
}

export interface IProcessLeadInput {
    leadId: number;
    orderStageId: number | undefined;
    amount: number | undefined;
    comment: string | undefined;
    sortOrder: number | undefined;
    ignoreChecklist: boolean;
}

export class ProcessOrderInfo implements IProcessOrderInfo {
    id!: number;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean;

    constructor(data?: IProcessOrderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.ignoreChecklist = _data["ignoreChecklist"];
        }
    }

    static fromJS(data: any): ProcessOrderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        return data;
    }
}

export interface IProcessOrderInfo {
    id: number;
    sortOrder: number | undefined;
    ignoreChecklist: boolean;
}

export class ProductDto implements IProductDto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    group!: string | undefined;
    paymentPeriodTypes!: RecurringPaymentFrequency[] | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.group = _data["group"];
            if (Array.isArray(_data["paymentPeriodTypes"])) {
                this.paymentPeriodTypes = [] as any;
                for (let item of _data["paymentPeriodTypes"])
                    this.paymentPeriodTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["group"] = this.group;
        if (Array.isArray(this.paymentPeriodTypes)) {
            data["paymentPeriodTypes"] = [];
            for (let item of this.paymentPeriodTypes)
                data["paymentPeriodTypes"].push(item);
        }
        return data;
    }
}

export interface IProductDto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    group: string | undefined;
    paymentPeriodTypes: RecurringPaymentFrequency[] | undefined;
}

export class ProductGroupInfo implements IProductGroupInfo {
    id!: number;
    name!: string | undefined;

    constructor(data?: IProductGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProductGroupInfo {
    id: number;
    name: string | undefined;
}

export class ProductInfo implements IProductInfo {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    groupId!: number | undefined;
    type!: ProductType;
    price!: number;
    commissionableAmount!: number | undefined;
    maxCommissionRate!: number | undefined;
    maxCommissionRateTier2!: number | undefined;
    unit!: ProductMeasurementUnit | undefined;
    imageUrl!: string | undefined;
    productServices!: ProductServiceInfo[] | undefined;
    productSubscriptionOptions!: ProductSubscriptionOptionInfo[] | undefined;

    constructor(data?: IProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.groupId = _data["groupId"];
            this.type = _data["type"];
            this.price = _data["price"];
            this.commissionableAmount = _data["commissionableAmount"];
            this.maxCommissionRate = _data["maxCommissionRate"];
            this.maxCommissionRateTier2 = _data["maxCommissionRateTier2"];
            this.unit = _data["unit"];
            this.imageUrl = _data["imageUrl"];
            if (Array.isArray(_data["productServices"])) {
                this.productServices = [] as any;
                for (let item of _data["productServices"])
                    this.productServices!.push(ProductServiceInfo.fromJS(item));
            }
            if (Array.isArray(_data["productSubscriptionOptions"])) {
                this.productSubscriptionOptions = [] as any;
                for (let item of _data["productSubscriptionOptions"])
                    this.productSubscriptionOptions!.push(ProductSubscriptionOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupId"] = this.groupId;
        data["type"] = this.type;
        data["price"] = this.price;
        data["commissionableAmount"] = this.commissionableAmount;
        data["maxCommissionRate"] = this.maxCommissionRate;
        data["maxCommissionRateTier2"] = this.maxCommissionRateTier2;
        data["unit"] = this.unit;
        data["imageUrl"] = this.imageUrl;
        if (Array.isArray(this.productServices)) {
            data["productServices"] = [];
            for (let item of this.productServices)
                data["productServices"].push(item.toJSON());
        }
        if (Array.isArray(this.productSubscriptionOptions)) {
            data["productSubscriptionOptions"] = [];
            for (let item of this.productSubscriptionOptions)
                data["productSubscriptionOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductInfo {
    id: number;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    groupId: number | undefined;
    type: ProductType;
    price: number;
    commissionableAmount: number | undefined;
    maxCommissionRate: number | undefined;
    maxCommissionRateTier2: number | undefined;
    unit: ProductMeasurementUnit | undefined;
    imageUrl: string | undefined;
    productServices: ProductServiceInfo[] | undefined;
    productSubscriptionOptions: ProductSubscriptionOptionInfo[] | undefined;
}

export enum ProductMeasurementUnit {
    Day = "Day",
    Feet = "Feet",
    Hour = "Hour",
    Kilogram = "Kilogram",
    Pound = "Pound",
    Month = "Month",
    Package = "Package",
    Piece = "Piece",
    Unit = "Unit",
    Year = "Year",
    Zone = "Zone",
}

export class ProductPaymentOptionInfo implements IProductPaymentOptionInfo {
    unitId!: ProductMeasurementUnit;
    unitName!: string | undefined;
    price!: number;

    constructor(data?: IProductPaymentOptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitId = _data["unitId"];
            this.unitName = _data["unitName"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ProductPaymentOptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPaymentOptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["price"] = this.price;
        return data;
    }
}

export interface IProductPaymentOptionInfo {
    unitId: ProductMeasurementUnit;
    unitName: string | undefined;
    price: number;
}

export class ProductPaymentOptionsInfo implements IProductPaymentOptionsInfo {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    type!: ProductType;
    paymentOptions!: ProductPaymentOptionInfo[] | undefined;

    constructor(data?: IProductPaymentOptionsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (Array.isArray(_data["paymentOptions"])) {
                this.paymentOptions = [] as any;
                for (let item of _data["paymentOptions"])
                    this.paymentOptions!.push(ProductPaymentOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPaymentOptionsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPaymentOptionsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        if (Array.isArray(this.paymentOptions)) {
            data["paymentOptions"] = [];
            for (let item of this.paymentOptions)
                data["paymentOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductPaymentOptionsInfo {
    id: number;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    type: ProductType;
    paymentOptions: ProductPaymentOptionInfo[] | undefined;
}

export class ProductServiceInfo implements IProductServiceInfo {
    memberServiceId!: number;
    memberServiceLevelId!: number | undefined;

    constructor(data?: IProductServiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberServiceId = _data["memberServiceId"];
            this.memberServiceLevelId = _data["memberServiceLevelId"];
        }
    }

    static fromJS(data: any): ProductServiceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductServiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberServiceId"] = this.memberServiceId;
        data["memberServiceLevelId"] = this.memberServiceLevelId;
        return data;
    }
}

export interface IProductServiceInfo {
    memberServiceId: number;
    memberServiceLevelId: number | undefined;
}

export class ProductShortInfo implements IProductShortInfo {
    description!: string | undefined;
    unitId!: ProductMeasurementUnit;
    rate!: number;

    constructor(data?: IProductShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.unitId = _data["unitId"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): ProductShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["unitId"] = this.unitId;
        data["rate"] = this.rate;
        return data;
    }
}

export interface IProductShortInfo {
    description: string | undefined;
    unitId: ProductMeasurementUnit;
    rate: number;
}

export class ProductSubscriptionOptionInfo implements IProductSubscriptionOptionInfo {
    frequency!: RecurringPaymentFrequency;
    signupFee!: number;
    commissionableSignupFeeAmount!: number | undefined;
    fee!: number;
    commissionableFeeAmount!: number | undefined;
    trialDayCount!: number;
    gracePeriodDayCount!: number | undefined;

    constructor(data?: IProductSubscriptionOptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.frequency = _data["frequency"];
            this.signupFee = _data["signupFee"];
            this.commissionableSignupFeeAmount = _data["commissionableSignupFeeAmount"];
            this.fee = _data["fee"];
            this.commissionableFeeAmount = _data["commissionableFeeAmount"];
            this.trialDayCount = _data["trialDayCount"];
            this.gracePeriodDayCount = _data["gracePeriodDayCount"];
        }
    }

    static fromJS(data: any): ProductSubscriptionOptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSubscriptionOptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frequency"] = this.frequency;
        data["signupFee"] = this.signupFee;
        data["commissionableSignupFeeAmount"] = this.commissionableSignupFeeAmount;
        data["fee"] = this.fee;
        data["commissionableFeeAmount"] = this.commissionableFeeAmount;
        data["trialDayCount"] = this.trialDayCount;
        data["gracePeriodDayCount"] = this.gracePeriodDayCount;
        return data;
    }
}

export interface IProductSubscriptionOptionInfo {
    frequency: RecurringPaymentFrequency;
    signupFee: number;
    commissionableSignupFeeAmount: number | undefined;
    fee: number;
    commissionableFeeAmount: number | undefined;
    trialDayCount: number;
    gracePeriodDayCount: number | undefined;
}

export enum ProductType {
    General = "General",
    Subscription = "Subscription",
}

export class ProfileAddress implements IProfileAddress {
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IProfileAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ProfileAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IProfileAddress {
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
}

export class ProfileAddressDto implements IProfileAddressDto {
    id!: number | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    city!: string | undefined;
    streetAddress!: string | undefined;
    zip!: string | undefined;

    constructor(data?: IProfileAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.city = _data["city"];
            this.streetAddress = _data["streetAddress"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): ProfileAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        return data;
    }
}

export interface IProfileAddressDto {
    id: number | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    city: string | undefined;
    streetAddress: string | undefined;
    zip: string | undefined;
}

export class ProfileContactBaseDto implements IProfileContactBaseDto {
    address!: ProfileAddressDto | undefined;
    primaryPhone!: ProfilePhoneDto | undefined;
    mobilePhone!: ProfilePhoneDto | undefined;

    constructor(data?: IProfileContactBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] ? ProfileAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.primaryPhone = _data["primaryPhone"] ? ProfilePhoneDto.fromJS(_data["primaryPhone"]) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"] ? ProfilePhoneDto.fromJS(_data["mobilePhone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfileContactBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileContactBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["primaryPhone"] = this.primaryPhone ? this.primaryPhone.toJSON() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone ? this.mobilePhone.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProfileContactBaseDto {
    address: ProfileAddressDto | undefined;
    primaryPhone: ProfilePhoneDto | undefined;
    mobilePhone: ProfilePhoneDto | undefined;
}

export class ProfileEmail implements IProfileEmail {
    emailAddress!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IProfileEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): ProfileEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface IProfileEmail {
    emailAddress: string | undefined;
    usageTypeId: string | undefined;
}

export class ProfileLink implements IProfileLink {
    linkTypeId!: string | undefined;
    url!: string | undefined;

    constructor(data?: IProfileLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkTypeId = _data["linkTypeId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ProfileLink {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        return data;
    }
}

export interface IProfileLink {
    linkTypeId: string | undefined;
    url: string | undefined;
}

export class ProfilePhone implements IProfilePhone {
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IProfilePhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): ProfilePhone {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface IProfilePhone {
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    usageTypeId: string | undefined;
}

export class ProfilePhoneDto implements IProfilePhoneDto {
    id!: number | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IProfilePhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
            this.isConfirmed = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.isConfirmed = _data["isConfirmed"] !== undefined ? _data["isConfirmed"] : true;
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): ProfilePhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface IProfilePhoneDto {
    id: number | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class ProfilePhoto implements IProfilePhoto {
    fileUrl!: string | undefined;

    constructor(data?: IProfilePhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
        }
    }

    static fromJS(data: any): ProfilePhoto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        return data;
    }
}

export interface IProfilePhoto {
    fileUrl: string | undefined;
}

export class ProfilePhotoDto implements IProfilePhotoDto {
    id!: number;
    providerKey!: string | undefined;
    fileUrl!: string | undefined;
    thumbnailUrl!: string | undefined;
    isPublished!: boolean;

    constructor(data?: IProfilePhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerKey = _data["providerKey"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): ProfilePhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerKey"] = this.providerKey;
        data["fileUrl"] = this.fileUrl;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["isPublished"] = this.isPublished;
        return data;
    }
}

export interface IProfilePhotoDto {
    id: number;
    providerKey: string | undefined;
    fileUrl: string | undefined;
    thumbnailUrl: string | undefined;
    isPublished: boolean;
}

export class ProhibitPermissionInput implements IProhibitPermissionInput {
    id!: number;
    permissionName!: string;

    constructor(data?: IProhibitPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): ProhibitPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProhibitPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionName"] = this.permissionName;
        return data;
    }
}

export interface IProhibitPermissionInput {
    id: number;
    permissionName: string;
}

export class PropertyAcquisitionDto implements IPropertyAcquisitionDto {
    id!: number;
    ownersOnTitle!: string | undefined;
    mortgageHolder!: string | undefined;
    propertyResident!: PropertyResident | undefined;
    houseOwningTime!: number | undefined;
    annualHOACondoFees!: number | undefined;
    depositPutAmount!: number | undefined;
    isHomeListed!: boolean | undefined;
    priceListed!: number | undefined;
    listedDate!: moment.Moment | undefined;
    listingExpires!: moment.Moment | undefined;
    realtorName!: string | undefined;
    realtorContactNumber!: string | undefined;
    offersFromListing!: boolean | undefined;
    offersFromListingAmount!: number | undefined;
    anythingRecentlyUpgraded!: string | undefined;
    needRepairs!: string | undefined;
    structural!: string | undefined;
    mechanical!: string | undefined;
    waterIssues!: string | undefined;
    roof!: string | undefined;
    plumbing!: string | undefined;
    electrical!: string | undefined;
    hvac!: string | undefined;
    repairsOrIssuesPool!: string | undefined;
    landscaping!: string | undefined;
    pests!: PestsType | undefined;
    pestsResolved!: boolean | undefined;
    repairsOrIssuesOther!: string | undefined;
    whySell!: string | undefined;
    howQuicklyWantToSell!: SellPeriod | undefined;
    didntSellActions!: string | undefined;
    tenantLeaseTerm!: moment.Moment | undefined;
    tenantMonthlyRent!: number | undefined;
    tenantDepositReceived!: number | undefined;
    tenantPetAddendum!: boolean | undefined;
    tenantPetFeeType!: PetFeeType | undefined;
    tenantPetFee!: number | undefined;
    currentOwningAmount!: number | undefined;
    hasAdditionalMortgage!: boolean | undefined;
    otherLienAmount!: number | undefined;
    areMortgagePaymentsCurrent!: boolean | undefined;
    monthsBehindOnMortgage!: number | undefined;
    amountBehindOnMortgages!: number | undefined;
    backTaxes!: number | undefined;
    monthlyPrincipleMortgagePayment!: number | undefined;
    monthlyInterestMortgagePayment!: number | undefined;
    includeTaxesAndInsurance!: boolean | undefined;
    annualPropertyTaxes!: number | undefined;
    annualPropertyInsurance!: number | undefined;
    interestRateMTG1!: number | undefined;
    interestRateMTG1Type!: InterestRate | undefined;
    interestRateMTG2!: number | undefined;
    interestRateMTG2Type!: InterestRate | undefined;
    prepaymentPenalty!: number | undefined;
    mortgageLender1!: string | undefined;
    mortgageLender2!: string | undefined;
    mortgageTermRenewal1!: moment.Moment | undefined;
    mortgageTermRenewal2!: moment.Moment | undefined;
    sellerFinancing!: string | undefined;
    lastSoldPrice!: number | undefined;
    yearLastSold!: string | undefined;
    cityAssessedValue!: number | undefined;
    asIsValue!: number | undefined;
    approxRepairCost!: number | undefined;
    afterRepairValue!: number | undefined;
    walkthroughDate!: moment.Moment | undefined;
    exitStrategy!: ExitStrategy | undefined;
    exitStrategyNotes!: string | undefined;
    depositToPayToSeller!: number | undefined;
    depositToPayToSellerDate!: moment.Moment | undefined;

    constructor(data?: IPropertyAcquisitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ownersOnTitle = _data["ownersOnTitle"];
            this.mortgageHolder = _data["mortgageHolder"];
            this.propertyResident = _data["propertyResident"];
            this.houseOwningTime = _data["houseOwningTime"];
            this.annualHOACondoFees = _data["annualHOACondoFees"];
            this.depositPutAmount = _data["depositPutAmount"];
            this.isHomeListed = _data["isHomeListed"];
            this.priceListed = _data["priceListed"];
            this.listedDate = _data["listedDate"] ? moment(_data["listedDate"].toString()) : <any>undefined;
            this.listingExpires = _data["listingExpires"] ? moment(_data["listingExpires"].toString()) : <any>undefined;
            this.realtorName = _data["realtorName"];
            this.realtorContactNumber = _data["realtorContactNumber"];
            this.offersFromListing = _data["offersFromListing"];
            this.offersFromListingAmount = _data["offersFromListingAmount"];
            this.anythingRecentlyUpgraded = _data["anythingRecentlyUpgraded"];
            this.needRepairs = _data["needRepairs"];
            this.structural = _data["structural"];
            this.mechanical = _data["mechanical"];
            this.waterIssues = _data["waterIssues"];
            this.roof = _data["roof"];
            this.plumbing = _data["plumbing"];
            this.electrical = _data["electrical"];
            this.hvac = _data["hvac"];
            this.repairsOrIssuesPool = _data["repairsOrIssuesPool"];
            this.landscaping = _data["landscaping"];
            this.pests = _data["pests"];
            this.pestsResolved = _data["pestsResolved"];
            this.repairsOrIssuesOther = _data["repairsOrIssuesOther"];
            this.whySell = _data["whySell"];
            this.howQuicklyWantToSell = _data["howQuicklyWantToSell"];
            this.didntSellActions = _data["didntSellActions"];
            this.tenantLeaseTerm = _data["tenantLeaseTerm"] ? moment(_data["tenantLeaseTerm"].toString()) : <any>undefined;
            this.tenantMonthlyRent = _data["tenantMonthlyRent"];
            this.tenantDepositReceived = _data["tenantDepositReceived"];
            this.tenantPetAddendum = _data["tenantPetAddendum"];
            this.tenantPetFeeType = _data["tenantPetFeeType"];
            this.tenantPetFee = _data["tenantPetFee"];
            this.currentOwningAmount = _data["currentOwningAmount"];
            this.hasAdditionalMortgage = _data["hasAdditionalMortgage"];
            this.otherLienAmount = _data["otherLienAmount"];
            this.areMortgagePaymentsCurrent = _data["areMortgagePaymentsCurrent"];
            this.monthsBehindOnMortgage = _data["monthsBehindOnMortgage"];
            this.amountBehindOnMortgages = _data["amountBehindOnMortgages"];
            this.backTaxes = _data["backTaxes"];
            this.monthlyPrincipleMortgagePayment = _data["monthlyPrincipleMortgagePayment"];
            this.monthlyInterestMortgagePayment = _data["monthlyInterestMortgagePayment"];
            this.includeTaxesAndInsurance = _data["includeTaxesAndInsurance"];
            this.annualPropertyTaxes = _data["annualPropertyTaxes"];
            this.annualPropertyInsurance = _data["annualPropertyInsurance"];
            this.interestRateMTG1 = _data["interestRateMTG1"];
            this.interestRateMTG1Type = _data["interestRateMTG1Type"];
            this.interestRateMTG2 = _data["interestRateMTG2"];
            this.interestRateMTG2Type = _data["interestRateMTG2Type"];
            this.prepaymentPenalty = _data["prepaymentPenalty"];
            this.mortgageLender1 = _data["mortgageLender1"];
            this.mortgageLender2 = _data["mortgageLender2"];
            this.mortgageTermRenewal1 = _data["mortgageTermRenewal1"] ? moment(_data["mortgageTermRenewal1"].toString()) : <any>undefined;
            this.mortgageTermRenewal2 = _data["mortgageTermRenewal2"] ? moment(_data["mortgageTermRenewal2"].toString()) : <any>undefined;
            this.sellerFinancing = _data["sellerFinancing"];
            this.lastSoldPrice = _data["lastSoldPrice"];
            this.yearLastSold = _data["yearLastSold"];
            this.cityAssessedValue = _data["cityAssessedValue"];
            this.asIsValue = _data["asIsValue"];
            this.approxRepairCost = _data["approxRepairCost"];
            this.afterRepairValue = _data["afterRepairValue"];
            this.walkthroughDate = _data["walkthroughDate"] ? moment(_data["walkthroughDate"].toString()) : <any>undefined;
            this.exitStrategy = _data["exitStrategy"];
            this.exitStrategyNotes = _data["exitStrategyNotes"];
            this.depositToPayToSeller = _data["depositToPayToSeller"];
            this.depositToPayToSellerDate = _data["depositToPayToSellerDate"] ? moment(_data["depositToPayToSellerDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyAcquisitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAcquisitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownersOnTitle"] = this.ownersOnTitle;
        data["mortgageHolder"] = this.mortgageHolder;
        data["propertyResident"] = this.propertyResident;
        data["houseOwningTime"] = this.houseOwningTime;
        data["annualHOACondoFees"] = this.annualHOACondoFees;
        data["depositPutAmount"] = this.depositPutAmount;
        data["isHomeListed"] = this.isHomeListed;
        data["priceListed"] = this.priceListed;
        data["listedDate"] = this.listedDate ? this.listedDate.toISOString() : <any>undefined;
        data["listingExpires"] = this.listingExpires ? this.listingExpires.toISOString() : <any>undefined;
        data["realtorName"] = this.realtorName;
        data["realtorContactNumber"] = this.realtorContactNumber;
        data["offersFromListing"] = this.offersFromListing;
        data["offersFromListingAmount"] = this.offersFromListingAmount;
        data["anythingRecentlyUpgraded"] = this.anythingRecentlyUpgraded;
        data["needRepairs"] = this.needRepairs;
        data["structural"] = this.structural;
        data["mechanical"] = this.mechanical;
        data["waterIssues"] = this.waterIssues;
        data["roof"] = this.roof;
        data["plumbing"] = this.plumbing;
        data["electrical"] = this.electrical;
        data["hvac"] = this.hvac;
        data["repairsOrIssuesPool"] = this.repairsOrIssuesPool;
        data["landscaping"] = this.landscaping;
        data["pests"] = this.pests;
        data["pestsResolved"] = this.pestsResolved;
        data["repairsOrIssuesOther"] = this.repairsOrIssuesOther;
        data["whySell"] = this.whySell;
        data["howQuicklyWantToSell"] = this.howQuicklyWantToSell;
        data["didntSellActions"] = this.didntSellActions;
        data["tenantLeaseTerm"] = this.tenantLeaseTerm ? this.tenantLeaseTerm.toISOString() : <any>undefined;
        data["tenantMonthlyRent"] = this.tenantMonthlyRent;
        data["tenantDepositReceived"] = this.tenantDepositReceived;
        data["tenantPetAddendum"] = this.tenantPetAddendum;
        data["tenantPetFeeType"] = this.tenantPetFeeType;
        data["tenantPetFee"] = this.tenantPetFee;
        data["currentOwningAmount"] = this.currentOwningAmount;
        data["hasAdditionalMortgage"] = this.hasAdditionalMortgage;
        data["otherLienAmount"] = this.otherLienAmount;
        data["areMortgagePaymentsCurrent"] = this.areMortgagePaymentsCurrent;
        data["monthsBehindOnMortgage"] = this.monthsBehindOnMortgage;
        data["amountBehindOnMortgages"] = this.amountBehindOnMortgages;
        data["backTaxes"] = this.backTaxes;
        data["monthlyPrincipleMortgagePayment"] = this.monthlyPrincipleMortgagePayment;
        data["monthlyInterestMortgagePayment"] = this.monthlyInterestMortgagePayment;
        data["includeTaxesAndInsurance"] = this.includeTaxesAndInsurance;
        data["annualPropertyTaxes"] = this.annualPropertyTaxes;
        data["annualPropertyInsurance"] = this.annualPropertyInsurance;
        data["interestRateMTG1"] = this.interestRateMTG1;
        data["interestRateMTG1Type"] = this.interestRateMTG1Type;
        data["interestRateMTG2"] = this.interestRateMTG2;
        data["interestRateMTG2Type"] = this.interestRateMTG2Type;
        data["prepaymentPenalty"] = this.prepaymentPenalty;
        data["mortgageLender1"] = this.mortgageLender1;
        data["mortgageLender2"] = this.mortgageLender2;
        data["mortgageTermRenewal1"] = this.mortgageTermRenewal1 ? this.mortgageTermRenewal1.toISOString() : <any>undefined;
        data["mortgageTermRenewal2"] = this.mortgageTermRenewal2 ? this.mortgageTermRenewal2.toISOString() : <any>undefined;
        data["sellerFinancing"] = this.sellerFinancing;
        data["lastSoldPrice"] = this.lastSoldPrice;
        data["yearLastSold"] = this.yearLastSold;
        data["cityAssessedValue"] = this.cityAssessedValue;
        data["asIsValue"] = this.asIsValue;
        data["approxRepairCost"] = this.approxRepairCost;
        data["afterRepairValue"] = this.afterRepairValue;
        data["walkthroughDate"] = this.walkthroughDate ? this.walkthroughDate.toISOString() : <any>undefined;
        data["exitStrategy"] = this.exitStrategy;
        data["exitStrategyNotes"] = this.exitStrategyNotes;
        data["depositToPayToSeller"] = this.depositToPayToSeller;
        data["depositToPayToSellerDate"] = this.depositToPayToSellerDate ? this.depositToPayToSellerDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPropertyAcquisitionDto {
    id: number;
    ownersOnTitle: string | undefined;
    mortgageHolder: string | undefined;
    propertyResident: PropertyResident | undefined;
    houseOwningTime: number | undefined;
    annualHOACondoFees: number | undefined;
    depositPutAmount: number | undefined;
    isHomeListed: boolean | undefined;
    priceListed: number | undefined;
    listedDate: moment.Moment | undefined;
    listingExpires: moment.Moment | undefined;
    realtorName: string | undefined;
    realtorContactNumber: string | undefined;
    offersFromListing: boolean | undefined;
    offersFromListingAmount: number | undefined;
    anythingRecentlyUpgraded: string | undefined;
    needRepairs: string | undefined;
    structural: string | undefined;
    mechanical: string | undefined;
    waterIssues: string | undefined;
    roof: string | undefined;
    plumbing: string | undefined;
    electrical: string | undefined;
    hvac: string | undefined;
    repairsOrIssuesPool: string | undefined;
    landscaping: string | undefined;
    pests: PestsType | undefined;
    pestsResolved: boolean | undefined;
    repairsOrIssuesOther: string | undefined;
    whySell: string | undefined;
    howQuicklyWantToSell: SellPeriod | undefined;
    didntSellActions: string | undefined;
    tenantLeaseTerm: moment.Moment | undefined;
    tenantMonthlyRent: number | undefined;
    tenantDepositReceived: number | undefined;
    tenantPetAddendum: boolean | undefined;
    tenantPetFeeType: PetFeeType | undefined;
    tenantPetFee: number | undefined;
    currentOwningAmount: number | undefined;
    hasAdditionalMortgage: boolean | undefined;
    otherLienAmount: number | undefined;
    areMortgagePaymentsCurrent: boolean | undefined;
    monthsBehindOnMortgage: number | undefined;
    amountBehindOnMortgages: number | undefined;
    backTaxes: number | undefined;
    monthlyPrincipleMortgagePayment: number | undefined;
    monthlyInterestMortgagePayment: number | undefined;
    includeTaxesAndInsurance: boolean | undefined;
    annualPropertyTaxes: number | undefined;
    annualPropertyInsurance: number | undefined;
    interestRateMTG1: number | undefined;
    interestRateMTG1Type: InterestRate | undefined;
    interestRateMTG2: number | undefined;
    interestRateMTG2Type: InterestRate | undefined;
    prepaymentPenalty: number | undefined;
    mortgageLender1: string | undefined;
    mortgageLender2: string | undefined;
    mortgageTermRenewal1: moment.Moment | undefined;
    mortgageTermRenewal2: moment.Moment | undefined;
    sellerFinancing: string | undefined;
    lastSoldPrice: number | undefined;
    yearLastSold: string | undefined;
    cityAssessedValue: number | undefined;
    asIsValue: number | undefined;
    approxRepairCost: number | undefined;
    afterRepairValue: number | undefined;
    walkthroughDate: moment.Moment | undefined;
    exitStrategy: ExitStrategy | undefined;
    exitStrategyNotes: string | undefined;
    depositToPayToSeller: number | undefined;
    depositToPayToSellerDate: moment.Moment | undefined;
}

export class PropertyBaseDto implements IPropertyBaseDto {
    id!: number;
    name!: string;
    address!: CreateContactAddressInput | undefined;
    propertyType!: PropertyType | undefined;
    area!: number | undefined;
    lotSize!: number | undefined;
    yearBuilt!: number | undefined;
    floor!: number | undefined;
    numberOfLevels!: number | undefined;
    corner!: boolean | undefined;
    end!: boolean | undefined;
    bedCount!: number | undefined;
    bathCount!: number | undefined;
    den!: boolean | undefined;
    office!: boolean | undefined;
    appliances!: Appliances | undefined;
    otherAppliances!: string | undefined;
    laundryInSuite!: boolean | undefined;
    isCentralHeating!: boolean | undefined;
    heatingType!: HeatingCoolingType | undefined;
    ac!: boolean | undefined;
    monthlyHeatingCost!: number | undefined;
    isHeatIncludedInCondoFees!: boolean | undefined;
    utilityTypesIncluded!: UtilityType | undefined;
    floorVinyl!: boolean | undefined;
    floorHardwood!: boolean | undefined;
    floorTile!: boolean | undefined;
    floorCarpet!: boolean | undefined;
    floorLVP!: boolean | undefined;
    storageInSuite!: boolean | undefined;
    storageLocker!: number | undefined;
    storageLockerNumber!: number | undefined;
    storageLockerKey!: boolean | undefined;
    yard!: YardPatioEnum | undefined;
    patio!: YardPatioEnum | undefined;
    yardBalcony!: boolean | undefined;
    parking!: ParkingType | undefined;
    basement!: BasementStatus | undefined;
    dogs!: boolean | undefined;
    cats!: boolean | undefined;
    petsSizeLimit!: string | undefined;
    petsBreedRestriction!: string | undefined;
    turnoverCompanyName!: string | undefined;
    turnoverContactName!: string | undefined;
    turnoverEmail!: string | undefined;
    turnoverPhone!: string | undefined;
    condoDocuments!: boolean | undefined;
    moveInRequest!: string | undefined;
    petApplication!: boolean | undefined;
    intercomSetup!: string | undefined;
    additionalKeys!: boolean | undefined;
    numberOfSets!: number | undefined;
    frontDoorFob!: number | undefined;
    garageRemote!: boolean | undefined;
    garageRemoteNumberReceived!: number | undefined;
    garageKey!: boolean | undefined;
    garageKeyNumberReceived!: number | undefined;
    garageCode!: string | undefined;
    parkadeFob!: boolean | undefined;
    parkingStall!: number | undefined;
    visitorParkingPass!: number | undefined;
    mailbox!: number | undefined;
    mailboxKey!: boolean | undefined;
    mailboxNumberReceived!: number | undefined;
    garbageDay!: PlatformDayOfWeek | undefined;
    garbageCollection!: GarbageCollection | undefined;
    garbageKey!: boolean | undefined;
    garbageNumberReceived!: number | undefined;
    electricityProvider!: string | undefined;
    electricityAccountNo!: string | undefined;
    naturalGasProvider!: string | undefined;
    naturalGasAccountNo!: string | undefined;
    waterProvider!: string | undefined;
    waterAccountNo!: string | undefined;
    wasteProvider!: string | undefined;
    wasteAccountNo!: string | undefined;
    firepit!: boolean | undefined;
    secure!: boolean | undefined;
    onSiteManager!: boolean | undefined;
    wheelchairAccessible!: boolean | undefined;
    walkOut!: boolean | undefined;
    elevator!: boolean | undefined;
    ceilingFan!: boolean | undefined;
    fireplace!: FireplaceType | undefined;
    petPark!: boolean | undefined;
    communitySpace!: boolean | undefined;
    pool!: boolean | undefined;
    exerciseRoom!: boolean | undefined;
    partyRoom!: boolean | undefined;
    guestSuite!: boolean | undefined;
    other!: string | undefined;

    constructor(data?: IPropertyBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"] ? CreateContactAddressInput.fromJS(_data["address"]) : <any>undefined;
            this.propertyType = _data["propertyType"];
            this.area = _data["area"];
            this.lotSize = _data["lotSize"];
            this.yearBuilt = _data["yearBuilt"];
            this.floor = _data["floor"];
            this.numberOfLevels = _data["numberOfLevels"];
            this.corner = _data["corner"];
            this.end = _data["end"];
            this.bedCount = _data["bedCount"];
            this.bathCount = _data["bathCount"];
            this.den = _data["den"];
            this.office = _data["office"];
            this.appliances = _data["appliances"];
            this.otherAppliances = _data["otherAppliances"];
            this.laundryInSuite = _data["laundryInSuite"];
            this.isCentralHeating = _data["isCentralHeating"];
            this.heatingType = _data["heatingType"];
            this.ac = _data["ac"];
            this.monthlyHeatingCost = _data["monthlyHeatingCost"];
            this.isHeatIncludedInCondoFees = _data["isHeatIncludedInCondoFees"];
            this.utilityTypesIncluded = _data["utilityTypesIncluded"];
            this.floorVinyl = _data["floorVinyl"];
            this.floorHardwood = _data["floorHardwood"];
            this.floorTile = _data["floorTile"];
            this.floorCarpet = _data["floorCarpet"];
            this.floorLVP = _data["floorLVP"];
            this.storageInSuite = _data["storageInSuite"];
            this.storageLocker = _data["storageLocker"];
            this.storageLockerNumber = _data["storageLockerNumber"];
            this.storageLockerKey = _data["storageLockerKey"];
            this.yard = _data["yard"];
            this.patio = _data["patio"];
            this.yardBalcony = _data["yardBalcony"];
            this.parking = _data["parking"];
            this.basement = _data["basement"];
            this.dogs = _data["dogs"];
            this.cats = _data["cats"];
            this.petsSizeLimit = _data["petsSizeLimit"];
            this.petsBreedRestriction = _data["petsBreedRestriction"];
            this.turnoverCompanyName = _data["turnoverCompanyName"];
            this.turnoverContactName = _data["turnoverContactName"];
            this.turnoverEmail = _data["turnoverEmail"];
            this.turnoverPhone = _data["turnoverPhone"];
            this.condoDocuments = _data["condoDocuments"];
            this.moveInRequest = _data["moveInRequest"];
            this.petApplication = _data["petApplication"];
            this.intercomSetup = _data["intercomSetup"];
            this.additionalKeys = _data["additionalKeys"];
            this.numberOfSets = _data["numberOfSets"];
            this.frontDoorFob = _data["frontDoorFob"];
            this.garageRemote = _data["garageRemote"];
            this.garageRemoteNumberReceived = _data["garageRemoteNumberReceived"];
            this.garageKey = _data["garageKey"];
            this.garageKeyNumberReceived = _data["garageKeyNumberReceived"];
            this.garageCode = _data["garageCode"];
            this.parkadeFob = _data["parkadeFob"];
            this.parkingStall = _data["parkingStall"];
            this.visitorParkingPass = _data["visitorParkingPass"];
            this.mailbox = _data["mailbox"];
            this.mailboxKey = _data["mailboxKey"];
            this.mailboxNumberReceived = _data["mailboxNumberReceived"];
            this.garbageDay = _data["garbageDay"];
            this.garbageCollection = _data["garbageCollection"];
            this.garbageKey = _data["garbageKey"];
            this.garbageNumberReceived = _data["garbageNumberReceived"];
            this.electricityProvider = _data["electricityProvider"];
            this.electricityAccountNo = _data["electricityAccountNo"];
            this.naturalGasProvider = _data["naturalGasProvider"];
            this.naturalGasAccountNo = _data["naturalGasAccountNo"];
            this.waterProvider = _data["waterProvider"];
            this.waterAccountNo = _data["waterAccountNo"];
            this.wasteProvider = _data["wasteProvider"];
            this.wasteAccountNo = _data["wasteAccountNo"];
            this.firepit = _data["firepit"];
            this.secure = _data["secure"];
            this.onSiteManager = _data["onSiteManager"];
            this.wheelchairAccessible = _data["wheelchairAccessible"];
            this.walkOut = _data["walkOut"];
            this.elevator = _data["elevator"];
            this.ceilingFan = _data["ceilingFan"];
            this.fireplace = _data["fireplace"];
            this.petPark = _data["petPark"];
            this.communitySpace = _data["communitySpace"];
            this.pool = _data["pool"];
            this.exerciseRoom = _data["exerciseRoom"];
            this.partyRoom = _data["partyRoom"];
            this.guestSuite = _data["guestSuite"];
            this.other = _data["other"];
        }
    }

    static fromJS(data: any): PropertyBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["propertyType"] = this.propertyType;
        data["area"] = this.area;
        data["lotSize"] = this.lotSize;
        data["yearBuilt"] = this.yearBuilt;
        data["floor"] = this.floor;
        data["numberOfLevels"] = this.numberOfLevels;
        data["corner"] = this.corner;
        data["end"] = this.end;
        data["bedCount"] = this.bedCount;
        data["bathCount"] = this.bathCount;
        data["den"] = this.den;
        data["office"] = this.office;
        data["appliances"] = this.appliances;
        data["otherAppliances"] = this.otherAppliances;
        data["laundryInSuite"] = this.laundryInSuite;
        data["isCentralHeating"] = this.isCentralHeating;
        data["heatingType"] = this.heatingType;
        data["ac"] = this.ac;
        data["monthlyHeatingCost"] = this.monthlyHeatingCost;
        data["isHeatIncludedInCondoFees"] = this.isHeatIncludedInCondoFees;
        data["utilityTypesIncluded"] = this.utilityTypesIncluded;
        data["floorVinyl"] = this.floorVinyl;
        data["floorHardwood"] = this.floorHardwood;
        data["floorTile"] = this.floorTile;
        data["floorCarpet"] = this.floorCarpet;
        data["floorLVP"] = this.floorLVP;
        data["storageInSuite"] = this.storageInSuite;
        data["storageLocker"] = this.storageLocker;
        data["storageLockerNumber"] = this.storageLockerNumber;
        data["storageLockerKey"] = this.storageLockerKey;
        data["yard"] = this.yard;
        data["patio"] = this.patio;
        data["yardBalcony"] = this.yardBalcony;
        data["parking"] = this.parking;
        data["basement"] = this.basement;
        data["dogs"] = this.dogs;
        data["cats"] = this.cats;
        data["petsSizeLimit"] = this.petsSizeLimit;
        data["petsBreedRestriction"] = this.petsBreedRestriction;
        data["turnoverCompanyName"] = this.turnoverCompanyName;
        data["turnoverContactName"] = this.turnoverContactName;
        data["turnoverEmail"] = this.turnoverEmail;
        data["turnoverPhone"] = this.turnoverPhone;
        data["condoDocuments"] = this.condoDocuments;
        data["moveInRequest"] = this.moveInRequest;
        data["petApplication"] = this.petApplication;
        data["intercomSetup"] = this.intercomSetup;
        data["additionalKeys"] = this.additionalKeys;
        data["numberOfSets"] = this.numberOfSets;
        data["frontDoorFob"] = this.frontDoorFob;
        data["garageRemote"] = this.garageRemote;
        data["garageRemoteNumberReceived"] = this.garageRemoteNumberReceived;
        data["garageKey"] = this.garageKey;
        data["garageKeyNumberReceived"] = this.garageKeyNumberReceived;
        data["garageCode"] = this.garageCode;
        data["parkadeFob"] = this.parkadeFob;
        data["parkingStall"] = this.parkingStall;
        data["visitorParkingPass"] = this.visitorParkingPass;
        data["mailbox"] = this.mailbox;
        data["mailboxKey"] = this.mailboxKey;
        data["mailboxNumberReceived"] = this.mailboxNumberReceived;
        data["garbageDay"] = this.garbageDay;
        data["garbageCollection"] = this.garbageCollection;
        data["garbageKey"] = this.garbageKey;
        data["garbageNumberReceived"] = this.garbageNumberReceived;
        data["electricityProvider"] = this.electricityProvider;
        data["electricityAccountNo"] = this.electricityAccountNo;
        data["naturalGasProvider"] = this.naturalGasProvider;
        data["naturalGasAccountNo"] = this.naturalGasAccountNo;
        data["waterProvider"] = this.waterProvider;
        data["waterAccountNo"] = this.waterAccountNo;
        data["wasteProvider"] = this.wasteProvider;
        data["wasteAccountNo"] = this.wasteAccountNo;
        data["firepit"] = this.firepit;
        data["secure"] = this.secure;
        data["onSiteManager"] = this.onSiteManager;
        data["wheelchairAccessible"] = this.wheelchairAccessible;
        data["walkOut"] = this.walkOut;
        data["elevator"] = this.elevator;
        data["ceilingFan"] = this.ceilingFan;
        data["fireplace"] = this.fireplace;
        data["petPark"] = this.petPark;
        data["communitySpace"] = this.communitySpace;
        data["pool"] = this.pool;
        data["exerciseRoom"] = this.exerciseRoom;
        data["partyRoom"] = this.partyRoom;
        data["guestSuite"] = this.guestSuite;
        data["other"] = this.other;
        return data;
    }
}

export interface IPropertyBaseDto {
    id: number;
    name: string;
    address: CreateContactAddressInput | undefined;
    propertyType: PropertyType | undefined;
    area: number | undefined;
    lotSize: number | undefined;
    yearBuilt: number | undefined;
    floor: number | undefined;
    numberOfLevels: number | undefined;
    corner: boolean | undefined;
    end: boolean | undefined;
    bedCount: number | undefined;
    bathCount: number | undefined;
    den: boolean | undefined;
    office: boolean | undefined;
    appliances: Appliances | undefined;
    otherAppliances: string | undefined;
    laundryInSuite: boolean | undefined;
    isCentralHeating: boolean | undefined;
    heatingType: HeatingCoolingType | undefined;
    ac: boolean | undefined;
    monthlyHeatingCost: number | undefined;
    isHeatIncludedInCondoFees: boolean | undefined;
    utilityTypesIncluded: UtilityType | undefined;
    floorVinyl: boolean | undefined;
    floorHardwood: boolean | undefined;
    floorTile: boolean | undefined;
    floorCarpet: boolean | undefined;
    floorLVP: boolean | undefined;
    storageInSuite: boolean | undefined;
    storageLocker: number | undefined;
    storageLockerNumber: number | undefined;
    storageLockerKey: boolean | undefined;
    yard: YardPatioEnum | undefined;
    patio: YardPatioEnum | undefined;
    yardBalcony: boolean | undefined;
    parking: ParkingType | undefined;
    basement: BasementStatus | undefined;
    dogs: boolean | undefined;
    cats: boolean | undefined;
    petsSizeLimit: string | undefined;
    petsBreedRestriction: string | undefined;
    turnoverCompanyName: string | undefined;
    turnoverContactName: string | undefined;
    turnoverEmail: string | undefined;
    turnoverPhone: string | undefined;
    condoDocuments: boolean | undefined;
    moveInRequest: string | undefined;
    petApplication: boolean | undefined;
    intercomSetup: string | undefined;
    additionalKeys: boolean | undefined;
    numberOfSets: number | undefined;
    frontDoorFob: number | undefined;
    garageRemote: boolean | undefined;
    garageRemoteNumberReceived: number | undefined;
    garageKey: boolean | undefined;
    garageKeyNumberReceived: number | undefined;
    garageCode: string | undefined;
    parkadeFob: boolean | undefined;
    parkingStall: number | undefined;
    visitorParkingPass: number | undefined;
    mailbox: number | undefined;
    mailboxKey: boolean | undefined;
    mailboxNumberReceived: number | undefined;
    garbageDay: PlatformDayOfWeek | undefined;
    garbageCollection: GarbageCollection | undefined;
    garbageKey: boolean | undefined;
    garbageNumberReceived: number | undefined;
    electricityProvider: string | undefined;
    electricityAccountNo: string | undefined;
    naturalGasProvider: string | undefined;
    naturalGasAccountNo: string | undefined;
    waterProvider: string | undefined;
    waterAccountNo: string | undefined;
    wasteProvider: string | undefined;
    wasteAccountNo: string | undefined;
    firepit: boolean | undefined;
    secure: boolean | undefined;
    onSiteManager: boolean | undefined;
    wheelchairAccessible: boolean | undefined;
    walkOut: boolean | undefined;
    elevator: boolean | undefined;
    ceilingFan: boolean | undefined;
    fireplace: FireplaceType | undefined;
    petPark: boolean | undefined;
    communitySpace: boolean | undefined;
    pool: boolean | undefined;
    exerciseRoom: boolean | undefined;
    partyRoom: boolean | undefined;
    guestSuite: boolean | undefined;
    other: string | undefined;
}

export class PropertyDealInfo implements IPropertyDealInfo {
    leadId!: number;
    leadDate!: moment.Moment;
    leadTypeSysId!: string | undefined;
    leadTypeName!: string | undefined;
    leadStageName!: string | undefined;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;

    constructor(data?: IPropertyDealInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.leadDate = _data["leadDate"] ? moment(_data["leadDate"].toString()) : <any>undefined;
            this.leadTypeSysId = _data["leadTypeSysId"];
            this.leadTypeName = _data["leadTypeName"];
            this.leadStageName = _data["leadStageName"];
            this.dealAmount = _data["dealAmount"];
            this.installmentAmount = _data["installmentAmount"];
        }
    }

    static fromJS(data: any): PropertyDealInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDealInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["leadDate"] = this.leadDate ? this.leadDate.toISOString() : <any>undefined;
        data["leadTypeSysId"] = this.leadTypeSysId;
        data["leadTypeName"] = this.leadTypeName;
        data["leadStageName"] = this.leadStageName;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        return data;
    }
}

export interface IPropertyDealInfo {
    leadId: number;
    leadDate: moment.Moment;
    leadTypeSysId: string | undefined;
    leadTypeName: string | undefined;
    leadStageName: string | undefined;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
}

export class PropertyDto implements IPropertyDto {
    photo!: string | undefined;
    links!: PropertyLinkDto[] | undefined;
    id!: number;
    name!: string;
    address!: CreateContactAddressInput | undefined;
    propertyType!: PropertyType | undefined;
    area!: number | undefined;
    lotSize!: number | undefined;
    yearBuilt!: number | undefined;
    floor!: number | undefined;
    numberOfLevels!: number | undefined;
    corner!: boolean | undefined;
    end!: boolean | undefined;
    bedCount!: number | undefined;
    bathCount!: number | undefined;
    den!: boolean | undefined;
    office!: boolean | undefined;
    appliances!: Appliances | undefined;
    otherAppliances!: string | undefined;
    laundryInSuite!: boolean | undefined;
    isCentralHeating!: boolean | undefined;
    heatingType!: HeatingCoolingType | undefined;
    ac!: boolean | undefined;
    monthlyHeatingCost!: number | undefined;
    isHeatIncludedInCondoFees!: boolean | undefined;
    utilityTypesIncluded!: UtilityType | undefined;
    floorVinyl!: boolean | undefined;
    floorHardwood!: boolean | undefined;
    floorTile!: boolean | undefined;
    floorCarpet!: boolean | undefined;
    floorLVP!: boolean | undefined;
    storageInSuite!: boolean | undefined;
    storageLocker!: number | undefined;
    storageLockerNumber!: number | undefined;
    storageLockerKey!: boolean | undefined;
    yard!: YardPatioEnum | undefined;
    patio!: YardPatioEnum | undefined;
    yardBalcony!: boolean | undefined;
    parking!: ParkingType | undefined;
    basement!: BasementStatus | undefined;
    dogs!: boolean | undefined;
    cats!: boolean | undefined;
    petsSizeLimit!: string | undefined;
    petsBreedRestriction!: string | undefined;
    turnoverCompanyName!: string | undefined;
    turnoverContactName!: string | undefined;
    turnoverEmail!: string | undefined;
    turnoverPhone!: string | undefined;
    condoDocuments!: boolean | undefined;
    moveInRequest!: string | undefined;
    petApplication!: boolean | undefined;
    intercomSetup!: string | undefined;
    additionalKeys!: boolean | undefined;
    numberOfSets!: number | undefined;
    frontDoorFob!: number | undefined;
    garageRemote!: boolean | undefined;
    garageRemoteNumberReceived!: number | undefined;
    garageKey!: boolean | undefined;
    garageKeyNumberReceived!: number | undefined;
    garageCode!: string | undefined;
    parkadeFob!: boolean | undefined;
    parkingStall!: number | undefined;
    visitorParkingPass!: number | undefined;
    mailbox!: number | undefined;
    mailboxKey!: boolean | undefined;
    mailboxNumberReceived!: number | undefined;
    garbageDay!: PlatformDayOfWeek | undefined;
    garbageCollection!: GarbageCollection | undefined;
    garbageKey!: boolean | undefined;
    garbageNumberReceived!: number | undefined;
    electricityProvider!: string | undefined;
    electricityAccountNo!: string | undefined;
    naturalGasProvider!: string | undefined;
    naturalGasAccountNo!: string | undefined;
    waterProvider!: string | undefined;
    waterAccountNo!: string | undefined;
    wasteProvider!: string | undefined;
    wasteAccountNo!: string | undefined;
    firepit!: boolean | undefined;
    secure!: boolean | undefined;
    onSiteManager!: boolean | undefined;
    wheelchairAccessible!: boolean | undefined;
    walkOut!: boolean | undefined;
    elevator!: boolean | undefined;
    ceilingFan!: boolean | undefined;
    fireplace!: FireplaceType | undefined;
    petPark!: boolean | undefined;
    communitySpace!: boolean | undefined;
    pool!: boolean | undefined;
    exerciseRoom!: boolean | undefined;
    partyRoom!: boolean | undefined;
    guestSuite!: boolean | undefined;
    other!: string | undefined;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.photo = _data["photo"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(PropertyLinkDto.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"] ? CreateContactAddressInput.fromJS(_data["address"]) : <any>undefined;
            this.propertyType = _data["propertyType"];
            this.area = _data["area"];
            this.lotSize = _data["lotSize"];
            this.yearBuilt = _data["yearBuilt"];
            this.floor = _data["floor"];
            this.numberOfLevels = _data["numberOfLevels"];
            this.corner = _data["corner"];
            this.end = _data["end"];
            this.bedCount = _data["bedCount"];
            this.bathCount = _data["bathCount"];
            this.den = _data["den"];
            this.office = _data["office"];
            this.appliances = _data["appliances"];
            this.otherAppliances = _data["otherAppliances"];
            this.laundryInSuite = _data["laundryInSuite"];
            this.isCentralHeating = _data["isCentralHeating"];
            this.heatingType = _data["heatingType"];
            this.ac = _data["ac"];
            this.monthlyHeatingCost = _data["monthlyHeatingCost"];
            this.isHeatIncludedInCondoFees = _data["isHeatIncludedInCondoFees"];
            this.utilityTypesIncluded = _data["utilityTypesIncluded"];
            this.floorVinyl = _data["floorVinyl"];
            this.floorHardwood = _data["floorHardwood"];
            this.floorTile = _data["floorTile"];
            this.floorCarpet = _data["floorCarpet"];
            this.floorLVP = _data["floorLVP"];
            this.storageInSuite = _data["storageInSuite"];
            this.storageLocker = _data["storageLocker"];
            this.storageLockerNumber = _data["storageLockerNumber"];
            this.storageLockerKey = _data["storageLockerKey"];
            this.yard = _data["yard"];
            this.patio = _data["patio"];
            this.yardBalcony = _data["yardBalcony"];
            this.parking = _data["parking"];
            this.basement = _data["basement"];
            this.dogs = _data["dogs"];
            this.cats = _data["cats"];
            this.petsSizeLimit = _data["petsSizeLimit"];
            this.petsBreedRestriction = _data["petsBreedRestriction"];
            this.turnoverCompanyName = _data["turnoverCompanyName"];
            this.turnoverContactName = _data["turnoverContactName"];
            this.turnoverEmail = _data["turnoverEmail"];
            this.turnoverPhone = _data["turnoverPhone"];
            this.condoDocuments = _data["condoDocuments"];
            this.moveInRequest = _data["moveInRequest"];
            this.petApplication = _data["petApplication"];
            this.intercomSetup = _data["intercomSetup"];
            this.additionalKeys = _data["additionalKeys"];
            this.numberOfSets = _data["numberOfSets"];
            this.frontDoorFob = _data["frontDoorFob"];
            this.garageRemote = _data["garageRemote"];
            this.garageRemoteNumberReceived = _data["garageRemoteNumberReceived"];
            this.garageKey = _data["garageKey"];
            this.garageKeyNumberReceived = _data["garageKeyNumberReceived"];
            this.garageCode = _data["garageCode"];
            this.parkadeFob = _data["parkadeFob"];
            this.parkingStall = _data["parkingStall"];
            this.visitorParkingPass = _data["visitorParkingPass"];
            this.mailbox = _data["mailbox"];
            this.mailboxKey = _data["mailboxKey"];
            this.mailboxNumberReceived = _data["mailboxNumberReceived"];
            this.garbageDay = _data["garbageDay"];
            this.garbageCollection = _data["garbageCollection"];
            this.garbageKey = _data["garbageKey"];
            this.garbageNumberReceived = _data["garbageNumberReceived"];
            this.electricityProvider = _data["electricityProvider"];
            this.electricityAccountNo = _data["electricityAccountNo"];
            this.naturalGasProvider = _data["naturalGasProvider"];
            this.naturalGasAccountNo = _data["naturalGasAccountNo"];
            this.waterProvider = _data["waterProvider"];
            this.waterAccountNo = _data["waterAccountNo"];
            this.wasteProvider = _data["wasteProvider"];
            this.wasteAccountNo = _data["wasteAccountNo"];
            this.firepit = _data["firepit"];
            this.secure = _data["secure"];
            this.onSiteManager = _data["onSiteManager"];
            this.wheelchairAccessible = _data["wheelchairAccessible"];
            this.walkOut = _data["walkOut"];
            this.elevator = _data["elevator"];
            this.ceilingFan = _data["ceilingFan"];
            this.fireplace = _data["fireplace"];
            this.petPark = _data["petPark"];
            this.communitySpace = _data["communitySpace"];
            this.pool = _data["pool"];
            this.exerciseRoom = _data["exerciseRoom"];
            this.partyRoom = _data["partyRoom"];
            this.guestSuite = _data["guestSuite"];
            this.other = _data["other"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photo"] = this.photo;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["propertyType"] = this.propertyType;
        data["area"] = this.area;
        data["lotSize"] = this.lotSize;
        data["yearBuilt"] = this.yearBuilt;
        data["floor"] = this.floor;
        data["numberOfLevels"] = this.numberOfLevels;
        data["corner"] = this.corner;
        data["end"] = this.end;
        data["bedCount"] = this.bedCount;
        data["bathCount"] = this.bathCount;
        data["den"] = this.den;
        data["office"] = this.office;
        data["appliances"] = this.appliances;
        data["otherAppliances"] = this.otherAppliances;
        data["laundryInSuite"] = this.laundryInSuite;
        data["isCentralHeating"] = this.isCentralHeating;
        data["heatingType"] = this.heatingType;
        data["ac"] = this.ac;
        data["monthlyHeatingCost"] = this.monthlyHeatingCost;
        data["isHeatIncludedInCondoFees"] = this.isHeatIncludedInCondoFees;
        data["utilityTypesIncluded"] = this.utilityTypesIncluded;
        data["floorVinyl"] = this.floorVinyl;
        data["floorHardwood"] = this.floorHardwood;
        data["floorTile"] = this.floorTile;
        data["floorCarpet"] = this.floorCarpet;
        data["floorLVP"] = this.floorLVP;
        data["storageInSuite"] = this.storageInSuite;
        data["storageLocker"] = this.storageLocker;
        data["storageLockerNumber"] = this.storageLockerNumber;
        data["storageLockerKey"] = this.storageLockerKey;
        data["yard"] = this.yard;
        data["patio"] = this.patio;
        data["yardBalcony"] = this.yardBalcony;
        data["parking"] = this.parking;
        data["basement"] = this.basement;
        data["dogs"] = this.dogs;
        data["cats"] = this.cats;
        data["petsSizeLimit"] = this.petsSizeLimit;
        data["petsBreedRestriction"] = this.petsBreedRestriction;
        data["turnoverCompanyName"] = this.turnoverCompanyName;
        data["turnoverContactName"] = this.turnoverContactName;
        data["turnoverEmail"] = this.turnoverEmail;
        data["turnoverPhone"] = this.turnoverPhone;
        data["condoDocuments"] = this.condoDocuments;
        data["moveInRequest"] = this.moveInRequest;
        data["petApplication"] = this.petApplication;
        data["intercomSetup"] = this.intercomSetup;
        data["additionalKeys"] = this.additionalKeys;
        data["numberOfSets"] = this.numberOfSets;
        data["frontDoorFob"] = this.frontDoorFob;
        data["garageRemote"] = this.garageRemote;
        data["garageRemoteNumberReceived"] = this.garageRemoteNumberReceived;
        data["garageKey"] = this.garageKey;
        data["garageKeyNumberReceived"] = this.garageKeyNumberReceived;
        data["garageCode"] = this.garageCode;
        data["parkadeFob"] = this.parkadeFob;
        data["parkingStall"] = this.parkingStall;
        data["visitorParkingPass"] = this.visitorParkingPass;
        data["mailbox"] = this.mailbox;
        data["mailboxKey"] = this.mailboxKey;
        data["mailboxNumberReceived"] = this.mailboxNumberReceived;
        data["garbageDay"] = this.garbageDay;
        data["garbageCollection"] = this.garbageCollection;
        data["garbageKey"] = this.garbageKey;
        data["garbageNumberReceived"] = this.garbageNumberReceived;
        data["electricityProvider"] = this.electricityProvider;
        data["electricityAccountNo"] = this.electricityAccountNo;
        data["naturalGasProvider"] = this.naturalGasProvider;
        data["naturalGasAccountNo"] = this.naturalGasAccountNo;
        data["waterProvider"] = this.waterProvider;
        data["waterAccountNo"] = this.waterAccountNo;
        data["wasteProvider"] = this.wasteProvider;
        data["wasteAccountNo"] = this.wasteAccountNo;
        data["firepit"] = this.firepit;
        data["secure"] = this.secure;
        data["onSiteManager"] = this.onSiteManager;
        data["wheelchairAccessible"] = this.wheelchairAccessible;
        data["walkOut"] = this.walkOut;
        data["elevator"] = this.elevator;
        data["ceilingFan"] = this.ceilingFan;
        data["fireplace"] = this.fireplace;
        data["petPark"] = this.petPark;
        data["communitySpace"] = this.communitySpace;
        data["pool"] = this.pool;
        data["exerciseRoom"] = this.exerciseRoom;
        data["partyRoom"] = this.partyRoom;
        data["guestSuite"] = this.guestSuite;
        data["other"] = this.other;
        return data;
    }
}

export interface IPropertyDto {
    photo: string | undefined;
    links: PropertyLinkDto[] | undefined;
    id: number;
    name: string;
    address: CreateContactAddressInput | undefined;
    propertyType: PropertyType | undefined;
    area: number | undefined;
    lotSize: number | undefined;
    yearBuilt: number | undefined;
    floor: number | undefined;
    numberOfLevels: number | undefined;
    corner: boolean | undefined;
    end: boolean | undefined;
    bedCount: number | undefined;
    bathCount: number | undefined;
    den: boolean | undefined;
    office: boolean | undefined;
    appliances: Appliances | undefined;
    otherAppliances: string | undefined;
    laundryInSuite: boolean | undefined;
    isCentralHeating: boolean | undefined;
    heatingType: HeatingCoolingType | undefined;
    ac: boolean | undefined;
    monthlyHeatingCost: number | undefined;
    isHeatIncludedInCondoFees: boolean | undefined;
    utilityTypesIncluded: UtilityType | undefined;
    floorVinyl: boolean | undefined;
    floorHardwood: boolean | undefined;
    floorTile: boolean | undefined;
    floorCarpet: boolean | undefined;
    floorLVP: boolean | undefined;
    storageInSuite: boolean | undefined;
    storageLocker: number | undefined;
    storageLockerNumber: number | undefined;
    storageLockerKey: boolean | undefined;
    yard: YardPatioEnum | undefined;
    patio: YardPatioEnum | undefined;
    yardBalcony: boolean | undefined;
    parking: ParkingType | undefined;
    basement: BasementStatus | undefined;
    dogs: boolean | undefined;
    cats: boolean | undefined;
    petsSizeLimit: string | undefined;
    petsBreedRestriction: string | undefined;
    turnoverCompanyName: string | undefined;
    turnoverContactName: string | undefined;
    turnoverEmail: string | undefined;
    turnoverPhone: string | undefined;
    condoDocuments: boolean | undefined;
    moveInRequest: string | undefined;
    petApplication: boolean | undefined;
    intercomSetup: string | undefined;
    additionalKeys: boolean | undefined;
    numberOfSets: number | undefined;
    frontDoorFob: number | undefined;
    garageRemote: boolean | undefined;
    garageRemoteNumberReceived: number | undefined;
    garageKey: boolean | undefined;
    garageKeyNumberReceived: number | undefined;
    garageCode: string | undefined;
    parkadeFob: boolean | undefined;
    parkingStall: number | undefined;
    visitorParkingPass: number | undefined;
    mailbox: number | undefined;
    mailboxKey: boolean | undefined;
    mailboxNumberReceived: number | undefined;
    garbageDay: PlatformDayOfWeek | undefined;
    garbageCollection: GarbageCollection | undefined;
    garbageKey: boolean | undefined;
    garbageNumberReceived: number | undefined;
    electricityProvider: string | undefined;
    electricityAccountNo: string | undefined;
    naturalGasProvider: string | undefined;
    naturalGasAccountNo: string | undefined;
    waterProvider: string | undefined;
    waterAccountNo: string | undefined;
    wasteProvider: string | undefined;
    wasteAccountNo: string | undefined;
    firepit: boolean | undefined;
    secure: boolean | undefined;
    onSiteManager: boolean | undefined;
    wheelchairAccessible: boolean | undefined;
    walkOut: boolean | undefined;
    elevator: boolean | undefined;
    ceilingFan: boolean | undefined;
    fireplace: FireplaceType | undefined;
    petPark: boolean | undefined;
    communitySpace: boolean | undefined;
    pool: boolean | undefined;
    exerciseRoom: boolean | undefined;
    partyRoom: boolean | undefined;
    guestSuite: boolean | undefined;
    other: string | undefined;
}

export class PropertyInput implements IPropertyInput {
    propertyId!: number | undefined;
    name!: string | undefined;
    address!: CreateContactAddressInput | undefined;
    note!: string | undefined;

    constructor(data?: IPropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.name = _data["name"];
            this.address = _data["address"] ? CreateContactAddressInput.fromJS(_data["address"]) : <any>undefined;
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): PropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

export interface IPropertyInput {
    propertyId: number | undefined;
    name: string | undefined;
    address: CreateContactAddressInput | undefined;
    note: string | undefined;
}

export class PropertyInvestmentDto implements IPropertyInvestmentDto {
    id!: number;
    equityPaidToHomeowner!: number | undefined;
    referralFee!: number | undefined;
    renovations!: number | undefined;
    cleaning!: number | undefined;
    inspection!: number | undefined;
    legalFees!: number | undefined;
    otherPreparationFees!: number | undefined;
    purchaseTermFrom!: moment.Moment | undefined;
    purchaseTermTo!: moment.Moment | undefined;
    purchaseTermExtraYear!: boolean | undefined;
    monthlyMortgagePayments!: number | undefined;
    monthlyTaxes!: number | undefined;
    monthlyInsurance!: number | undefined;
    monthlyCondoFees!: number | undefined;
    otherMonthlyFees!: number | undefined;
    termUtilizedMonths!: number | undefined;
    rtoPurchasePrice!: number | undefined;
    rtoDeposit!: number | undefined;
    rtoMonthlyPayment!: number | undefined;
    rtoTermFrom!: moment.Moment | undefined;
    rtoTermTo!: moment.Moment | undefined;
    rtoMortgagePaydownRate!: number | undefined;

    constructor(data?: IPropertyInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.equityPaidToHomeowner = _data["equityPaidToHomeowner"];
            this.referralFee = _data["referralFee"];
            this.renovations = _data["renovations"];
            this.cleaning = _data["cleaning"];
            this.inspection = _data["inspection"];
            this.legalFees = _data["legalFees"];
            this.otherPreparationFees = _data["otherPreparationFees"];
            this.purchaseTermFrom = _data["purchaseTermFrom"] ? moment(_data["purchaseTermFrom"].toString()) : <any>undefined;
            this.purchaseTermTo = _data["purchaseTermTo"] ? moment(_data["purchaseTermTo"].toString()) : <any>undefined;
            this.purchaseTermExtraYear = _data["purchaseTermExtraYear"];
            this.monthlyMortgagePayments = _data["monthlyMortgagePayments"];
            this.monthlyTaxes = _data["monthlyTaxes"];
            this.monthlyInsurance = _data["monthlyInsurance"];
            this.monthlyCondoFees = _data["monthlyCondoFees"];
            this.otherMonthlyFees = _data["otherMonthlyFees"];
            this.termUtilizedMonths = _data["termUtilizedMonths"];
            this.rtoPurchasePrice = _data["rtoPurchasePrice"];
            this.rtoDeposit = _data["rtoDeposit"];
            this.rtoMonthlyPayment = _data["rtoMonthlyPayment"];
            this.rtoTermFrom = _data["rtoTermFrom"] ? moment(_data["rtoTermFrom"].toString()) : <any>undefined;
            this.rtoTermTo = _data["rtoTermTo"] ? moment(_data["rtoTermTo"].toString()) : <any>undefined;
            this.rtoMortgagePaydownRate = _data["rtoMortgagePaydownRate"];
        }
    }

    static fromJS(data: any): PropertyInvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["equityPaidToHomeowner"] = this.equityPaidToHomeowner;
        data["referralFee"] = this.referralFee;
        data["renovations"] = this.renovations;
        data["cleaning"] = this.cleaning;
        data["inspection"] = this.inspection;
        data["legalFees"] = this.legalFees;
        data["otherPreparationFees"] = this.otherPreparationFees;
        data["purchaseTermFrom"] = this.purchaseTermFrom ? this.purchaseTermFrom.toISOString() : <any>undefined;
        data["purchaseTermTo"] = this.purchaseTermTo ? this.purchaseTermTo.toISOString() : <any>undefined;
        data["purchaseTermExtraYear"] = this.purchaseTermExtraYear;
        data["monthlyMortgagePayments"] = this.monthlyMortgagePayments;
        data["monthlyTaxes"] = this.monthlyTaxes;
        data["monthlyInsurance"] = this.monthlyInsurance;
        data["monthlyCondoFees"] = this.monthlyCondoFees;
        data["otherMonthlyFees"] = this.otherMonthlyFees;
        data["termUtilizedMonths"] = this.termUtilizedMonths;
        data["rtoPurchasePrice"] = this.rtoPurchasePrice;
        data["rtoDeposit"] = this.rtoDeposit;
        data["rtoMonthlyPayment"] = this.rtoMonthlyPayment;
        data["rtoTermFrom"] = this.rtoTermFrom ? this.rtoTermFrom.toISOString() : <any>undefined;
        data["rtoTermTo"] = this.rtoTermTo ? this.rtoTermTo.toISOString() : <any>undefined;
        data["rtoMortgagePaydownRate"] = this.rtoMortgagePaydownRate;
        return data;
    }
}

export interface IPropertyInvestmentDto {
    id: number;
    equityPaidToHomeowner: number | undefined;
    referralFee: number | undefined;
    renovations: number | undefined;
    cleaning: number | undefined;
    inspection: number | undefined;
    legalFees: number | undefined;
    otherPreparationFees: number | undefined;
    purchaseTermFrom: moment.Moment | undefined;
    purchaseTermTo: moment.Moment | undefined;
    purchaseTermExtraYear: boolean | undefined;
    monthlyMortgagePayments: number | undefined;
    monthlyTaxes: number | undefined;
    monthlyInsurance: number | undefined;
    monthlyCondoFees: number | undefined;
    otherMonthlyFees: number | undefined;
    termUtilizedMonths: number | undefined;
    rtoPurchasePrice: number | undefined;
    rtoDeposit: number | undefined;
    rtoMonthlyPayment: number | undefined;
    rtoTermFrom: moment.Moment | undefined;
    rtoTermTo: moment.Moment | undefined;
    rtoMortgagePaydownRate: number | undefined;
}

export class PropertyLinkDto implements IPropertyLinkDto {
    id!: number;
    url!: string | undefined;

    constructor(data?: IPropertyLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): PropertyLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        return data;
    }
}

export interface IPropertyLinkDto {
    id: number;
    url: string | undefined;
}

export enum PropertyResident {
    Owner = "Owner",
    Tenant = "Tenant",
    Vacant = "Vacant",
}

export enum PropertyType {
    Condo = "Condo",
    Duplex = "Duplex",
    SFD = "SFD",
    Townhouse = "Townhouse",
}

export class PublicRecordBureauInfoDto implements IPublicRecordBureauInfoDto {
    bureau!: Bureau | undefined;
    title!: string | undefined;
    type!: string | undefined;
    status!: string | undefined;
    amount!: number | undefined;
    dateFiledOrReported!: moment.Moment | undefined;
    referenceNo!: string | undefined;
    court!: string | undefined;
    dateVerified!: moment.Moment | undefined;
    dateUpdated!: moment.Moment | undefined;
    dateReleased!: moment.Moment | undefined;
    remarks!: string | undefined;

    constructor(data?: IPublicRecordBureauInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bureau = _data["bureau"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.amount = _data["amount"];
            this.dateFiledOrReported = _data["dateFiledOrReported"] ? moment(_data["dateFiledOrReported"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.court = _data["court"];
            this.dateVerified = _data["dateVerified"] ? moment(_data["dateVerified"].toString()) : <any>undefined;
            this.dateUpdated = _data["dateUpdated"] ? moment(_data["dateUpdated"].toString()) : <any>undefined;
            this.dateReleased = _data["dateReleased"] ? moment(_data["dateReleased"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): PublicRecordBureauInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicRecordBureauInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["title"] = this.title;
        data["type"] = this.type;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateFiledOrReported"] = this.dateFiledOrReported ? this.dateFiledOrReported.toISOString() : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["court"] = this.court;
        data["dateVerified"] = this.dateVerified ? this.dateVerified.toISOString() : <any>undefined;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>undefined;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface IPublicRecordBureauInfoDto {
    bureau: Bureau | undefined;
    title: string | undefined;
    type: string | undefined;
    status: string | undefined;
    amount: number | undefined;
    dateFiledOrReported: moment.Moment | undefined;
    referenceNo: string | undefined;
    court: string | undefined;
    dateVerified: moment.Moment | undefined;
    dateUpdated: moment.Moment | undefined;
    dateReleased: moment.Moment | undefined;
    remarks: string | undefined;
}

export class PublicRecordDto implements IPublicRecordDto {
    title!: string | undefined;
    status!: string | undefined;
    amount!: number | undefined;
    dateReleased!: moment.Moment | undefined;
    publicRecordDetails!: PublicRecordBureauInfoDto[] | undefined;

    constructor(data?: IPublicRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.status = _data["status"];
            this.amount = _data["amount"];
            this.dateReleased = _data["dateReleased"] ? moment(_data["dateReleased"].toString()) : <any>undefined;
            if (Array.isArray(_data["publicRecordDetails"])) {
                this.publicRecordDetails = [] as any;
                for (let item of _data["publicRecordDetails"])
                    this.publicRecordDetails!.push(PublicRecordBureauInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublicRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        if (Array.isArray(this.publicRecordDetails)) {
            data["publicRecordDetails"] = [];
            for (let item of this.publicRecordDetails)
                data["publicRecordDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPublicRecordDto {
    title: string | undefined;
    status: string | undefined;
    amount: number | undefined;
    dateReleased: moment.Moment | undefined;
    publicRecordDetails: PublicRecordBureauInfoDto[] | undefined;
}

export class PublishedPersonProfileInfo implements IPublishedPersonProfileInfo {
    fullName!: string | undefined;
    email!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;
    profileSummary!: string | undefined;
    calendlyUrl!: string | undefined;
    emails!: ProfileEmail[] | undefined;
    addresses!: ProfileAddress[] | undefined;
    phones!: ProfilePhone[] | undefined;
    links!: ProfileLink[] | undefined;
    photos!: ProfilePhoto[] | undefined;

    constructor(data?: IPublishedPersonProfileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.companyName = _data["companyName"];
            this.jobTitle = _data["jobTitle"];
            this.profileSummary = _data["profileSummary"];
            this.calendlyUrl = _data["calendlyUrl"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(ProfileEmail.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(ProfileAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(ProfilePhone.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(ProfileLink.fromJS(item));
            }
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos!.push(ProfilePhoto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublishedPersonProfileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedPersonProfileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        data["profileSummary"] = this.profileSummary;
        data["calendlyUrl"] = this.calendlyUrl;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPublishedPersonProfileInfo {
    fullName: string | undefined;
    email: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
    profileSummary: string | undefined;
    calendlyUrl: string | undefined;
    emails: ProfileEmail[] | undefined;
    addresses: ProfileAddress[] | undefined;
    phones: ProfilePhone[] | undefined;
    links: ProfileLink[] | undefined;
    photos: ProfilePhoto[] | undefined;
}

export class PublishedProfileBaseDto implements IPublishedProfileBaseDto {
    name!: string | undefined;

    constructor(data?: IPublishedProfileBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PublishedProfileBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedProfileBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IPublishedProfileBaseDto {
    name: string | undefined;
}

export class PublishedProfileDto implements IPublishedProfileDto {
    data!: PublishedPersonProfileInfo | undefined;
    name!: string | undefined;

    constructor(data?: IPublishedProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? PublishedPersonProfileInfo.fromJS(_data["data"]) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PublishedProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["name"] = this.name;
        return data;
    }
}

export interface IPublishedProfileDto {
    data: PublishedPersonProfileInfo | undefined;
    name: string | undefined;
}

export class PublishProfileInput implements IPublishProfileInput {
    fullUrl!: string | undefined;
    photoIds!: number[] | undefined;
    name!: string;

    constructor(data?: IPublishProfileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullUrl = _data["fullUrl"];
            if (Array.isArray(_data["photoIds"])) {
                this.photoIds = [] as any;
                for (let item of _data["photoIds"])
                    this.photoIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PublishProfileInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishProfileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullUrl"] = this.fullUrl;
        if (Array.isArray(this.photoIds)) {
            data["photoIds"] = [];
            for (let item of this.photoIds)
                data["photoIds"].push(item);
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IPublishProfileInput {
    fullUrl: string | undefined;
    photoIds: number[] | undefined;
    name: string;
}

export class QuestionDto implements IQuestionDto {
    id!: number;
    questionnaireId!: number;
    type!: QuestionType;
    text!: string | undefined;
    sortOrder!: number;
    options!: OptionDto[] | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionnaireId = _data["questionnaireId"];
            this.type = _data["type"];
            this.text = _data["text"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionnaireId"] = this.questionnaireId;
        data["type"] = this.type;
        data["text"] = this.text;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionDto {
    id: number;
    questionnaireId: number;
    type: QuestionType;
    text: string | undefined;
    sortOrder: number;
    options: OptionDto[] | undefined;
}

export class QuestionnaireDto implements IQuestionnaireDto {
    id!: number;
    questions!: QuestionDto[] | undefined;

    constructor(data?: IQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionnaireDto {
    id: number;
    questions: QuestionDto[] | undefined;
}

export class QuestionnaireResponseDto implements IQuestionnaireResponseDto {
    questionnaireId!: number;
    answers!: AnswerDto[] | undefined;

    constructor(data?: IQuestionnaireResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionnaireId = _data["questionnaireId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaireId"] = this.questionnaireId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionnaireResponseDto {
    questionnaireId: number;
    answers: AnswerDto[] | undefined;
}

export enum QuestionType {
    QuestionWithOptions = "QuestionWithOptions",
}

export class RankRequest implements IRankRequest {
    ids!: number[];
    rank!: number;

    constructor(data?: IRankRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.rank = _data["rank"];
        }
    }

    static fromJS(data: any): RankRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RankRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["rank"] = this.rank;
        return data;
    }
}

export interface IRankRequest {
    ids: number[];
    rank: number;
}

export class RapidSettingsDto implements IRapidSettingsDto {
    username!: string | undefined;
    password!: string | undefined;

    constructor(data?: IRapidSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RapidSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RapidSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IRapidSettingsDto {
    username: string | undefined;
    password: string | undefined;
}

export class RateContactInput implements IRateContactInput {
    contactId!: number;
    ratingId!: number | undefined;

    constructor(data?: IRateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.ratingId = _data["ratingId"];
        }
    }

    static fromJS(data: any): RateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new RateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["ratingId"] = this.ratingId;
        return data;
    }
}

export interface IRateContactInput {
    contactId: number;
    ratingId: number | undefined;
}

export class RateContactsInput implements IRateContactsInput {
    contactIds!: number[] | undefined;
    ratingId!: number | undefined;

    constructor(data?: IRateContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            this.ratingId = _data["ratingId"];
        }
    }

    static fromJS(data: any): RateContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new RateContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["ratingId"] = this.ratingId;
        return data;
    }
}

export interface IRateContactsInput {
    contactIds: number[] | undefined;
    ratingId: number | undefined;
}

export class RecategorizeInput implements IRecategorizeInput {
    bankAccountIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    ruleId!: number | undefined;

    constructor(data?: IRecategorizeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bankAccountIds"])) {
                this.bankAccountIds = [] as any;
                for (let item of _data["bankAccountIds"])
                    this.bankAccountIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ruleId = _data["ruleId"];
        }
    }

    static fromJS(data: any): RecategorizeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecategorizeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bankAccountIds)) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ruleId"] = this.ruleId;
        return data;
    }
}

export interface IRecategorizeInput {
    bankAccountIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    ruleId: number | undefined;
}

export class RecentlyAddedContact implements IRecentlyAddedContact {
    sourceContactFullName!: string | undefined;
    bankCode!: string | undefined;
    bankCodeDate!: moment.Moment;
    countryId!: string | undefined;
    countryName!: string | undefined;

    constructor(data?: IRecentlyAddedContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceContactFullName = _data["sourceContactFullName"];
            this.bankCode = _data["bankCode"];
            this.bankCodeDate = _data["bankCodeDate"] ? moment(_data["bankCodeDate"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): RecentlyAddedContact {
        data = typeof data === 'object' ? data : {};
        let result = new RecentlyAddedContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceContactFullName"] = this.sourceContactFullName;
        data["bankCode"] = this.bankCode;
        data["bankCodeDate"] = this.bankCodeDate ? this.bankCodeDate.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IRecentlyAddedContact {
    sourceContactFullName: string | undefined;
    bankCode: string | undefined;
    bankCodeDate: moment.Moment;
    countryId: string | undefined;
    countryName: string | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: moment.Moment;
}

export class RecepientInfo implements IRecepientInfo {
    recipient!: string | undefined;
    deliveryStatus!: CommunicationMessageDeliveryStatus;
    deliveryDate!: moment.Moment | undefined;
    openDate!: moment.Moment | undefined;

    constructor(data?: IRecepientInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipient = _data["recipient"];
            this.deliveryStatus = _data["deliveryStatus"];
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecepientInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RecepientInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient;
        data["deliveryStatus"] = this.deliveryStatus;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecepientInfo {
    recipient: string | undefined;
    deliveryStatus: CommunicationMessageDeliveryStatus;
    deliveryDate: moment.Moment | undefined;
    openDate: moment.Moment | undefined;
}

export class RecommendationDto implements IRecommendationDto {
    header!: string | undefined;
    text!: string | undefined;
    isPositive!: boolean;

    constructor(data?: IRecommendationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"];
            this.text = _data["text"];
            this.isPositive = _data["isPositive"];
        }
    }

    static fromJS(data: any): RecommendationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["text"] = this.text;
        data["isPositive"] = this.isPositive;
        return data;
    }
}

export interface IRecommendationDto {
    header: string | undefined;
    text: string | undefined;
    isPositive: boolean;
}

export class RecordEarningsInput implements IRecordEarningsInput {
    contactIds!: number[] | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment;

    constructor(data?: IRecordEarningsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecordEarningsInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecordEarningsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecordEarningsInput {
    contactIds: number[] | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
}

export class RecurlyPaymentSettings implements IRecurlyPaymentSettings {
    apiKey!: string | undefined;
    subdomain!: string | undefined;
    privateKey!: string | undefined;
    pageSize!: number;

    constructor(data?: IRecurlyPaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.subdomain = _data["subdomain"];
            this.privateKey = _data["privateKey"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): RecurlyPaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RecurlyPaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["subdomain"] = this.subdomain;
        data["privateKey"] = this.privateKey;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IRecurlyPaymentSettings {
    apiKey: string | undefined;
    subdomain: string | undefined;
    privateKey: string | undefined;
    pageSize: number;
}

export enum RecurringPaymentFrequency {
    Monthly = "Monthly",
    Annual = "Annual",
    LifeTime = "LifeTime",
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class RefundInfo implements IRefundInfo {
    totalAmount!: number;
    count!: number;

    constructor(data?: IRefundInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalAmount = _data["totalAmount"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): RefundInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RefundInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAmount"] = this.totalAmount;
        data["count"] = this.count;
        return data;
    }
}

export interface IRefundInfo {
    totalAmount: number;
    count: number;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class RegisterApplicantRequest implements IRegisterApplicantRequest {
    testMode!: boolean;
    isAuthenticated!: boolean;
    newUserPassword!: string | undefined;
    finalizeLeadUrl!: string | undefined;
    sendWelcomeEmail!: boolean;
    returnNewUserInfo!: boolean;
    systemType!: OfferProviderType;
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformationExtended | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformationExtended | undefined;
    employmentInformation!: EmploymentInformationExtended | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IRegisterApplicantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testMode = _data["testMode"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.newUserPassword = _data["newUserPassword"];
            this.finalizeLeadUrl = _data["finalizeLeadUrl"];
            this.sendWelcomeEmail = _data["sendWelcomeEmail"];
            this.returnNewUserInfo = _data["returnNewUserInfo"];
            this.systemType = _data["systemType"];
            this.trackingInformation = _data["trackingInformation"] ? TrackingInformation.fromJS(_data["trackingInformation"]) : <any>undefined;
            this.personalInformation = _data["personalInformation"] ? PersonalInformationExtended.fromJS(_data["personalInformation"]) : <any>undefined;
            this.debtInformation = _data["debtInformation"] ? DebtInformation.fromJS(_data["debtInformation"]) : <any>undefined;
            this.loanInformation = _data["loanInformation"] ? LoanInformationExtended.fromJS(_data["loanInformation"]) : <any>undefined;
            this.employmentInformation = _data["employmentInformation"] ? EmploymentInformationExtended.fromJS(_data["employmentInformation"]) : <any>undefined;
            this.bankInformation = _data["bankInformation"] ? BankInformation.fromJS(_data["bankInformation"]) : <any>undefined;
            this.legalInformation = _data["legalInformation"] ? LegalInformation.fromJS(_data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterApplicantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterApplicantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testMode"] = this.testMode;
        data["isAuthenticated"] = this.isAuthenticated;
        data["newUserPassword"] = this.newUserPassword;
        data["finalizeLeadUrl"] = this.finalizeLeadUrl;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["returnNewUserInfo"] = this.returnNewUserInfo;
        data["systemType"] = this.systemType;
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterApplicantRequest {
    testMode: boolean;
    isAuthenticated: boolean;
    newUserPassword: string | undefined;
    finalizeLeadUrl: string | undefined;
    sendWelcomeEmail: boolean;
    returnNewUserInfo: boolean;
    systemType: OfferProviderType;
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformationExtended | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformationExtended | undefined;
    employmentInformation: EmploymentInformationExtended | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class RegisterApplicantResponse implements IRegisterApplicantResponse {
    applicantUserId!: number;
    newUserInfo!: UserInfo | undefined;

    constructor(data?: IRegisterApplicantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicantUserId = _data["applicantUserId"];
            this.newUserInfo = _data["newUserInfo"] ? UserInfo.fromJS(_data["newUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterApplicantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterApplicantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantUserId"] = this.applicantUserId;
        data["newUserInfo"] = this.newUserInfo ? this.newUserInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterApplicantResponse {
    applicantUserId: number;
    newUserInfo: UserInfo | undefined;
}

export class RegisterByApplicantRequest implements IRegisterByApplicantRequest {
    systemType!: OfferProviderType;
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformationExtended | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformationExtended | undefined;
    employmentInformation!: EmploymentInformationExtended | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IRegisterByApplicantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemType = _data["systemType"];
            this.trackingInformation = _data["trackingInformation"] ? TrackingInformation.fromJS(_data["trackingInformation"]) : <any>undefined;
            this.personalInformation = _data["personalInformation"] ? PersonalInformationExtended.fromJS(_data["personalInformation"]) : <any>undefined;
            this.debtInformation = _data["debtInformation"] ? DebtInformation.fromJS(_data["debtInformation"]) : <any>undefined;
            this.loanInformation = _data["loanInformation"] ? LoanInformationExtended.fromJS(_data["loanInformation"]) : <any>undefined;
            this.employmentInformation = _data["employmentInformation"] ? EmploymentInformationExtended.fromJS(_data["employmentInformation"]) : <any>undefined;
            this.bankInformation = _data["bankInformation"] ? BankInformation.fromJS(_data["bankInformation"]) : <any>undefined;
            this.legalInformation = _data["legalInformation"] ? LegalInformation.fromJS(_data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterByApplicantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterByApplicantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterByApplicantRequest {
    systemType: OfferProviderType;
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformationExtended | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformationExtended | undefined;
    employmentInformation: EmploymentInformationExtended | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class RegisterByApplicantResponse implements IRegisterByApplicantResponse {
    authToken!: string | undefined;
    secureId!: string | undefined;

    constructor(data?: IRegisterByApplicantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authToken = _data["authToken"];
            this.secureId = _data["secureId"];
        }
    }

    static fromJS(data: any): RegisterByApplicantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterByApplicantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authToken"] = this.authToken;
        data["secureId"] = this.secureId;
        return data;
    }
}

export interface IRegisterByApplicantResponse {
    authToken: string | undefined;
    secureId: string | undefined;
}

export class RegisterMemberInput implements IRegisterMemberInput {
    contactId!: number;
    channelCode!: string;
    accountingTreeType!: AccountingTreeType | undefined;

    constructor(data?: IRegisterMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.channelCode = _data["channelCode"];
            this.accountingTreeType = _data["accountingTreeType"];
        }
    }

    static fromJS(data: any): RegisterMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["channelCode"] = this.channelCode;
        data["accountingTreeType"] = this.accountingTreeType;
        return data;
    }
}

export interface IRegisterMemberInput {
    contactId: number;
    channelCode: string;
    accountingTreeType: AccountingTreeType | undefined;
}

export class RegisterMemberOutput implements IRegisterMemberOutput {
    userId!: number;
    alreadyInitialized!: boolean;

    constructor(data?: IRegisterMemberOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.alreadyInitialized = _data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): RegisterMemberOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data;
    }
}

export interface IRegisterMemberOutput {
    userId: number;
    alreadyInitialized: boolean;
}

export class RegisterMemberRequest implements IRegisterMemberRequest {
    password!: string;
    registrationId!: string;
    name!: string;
    surname!: string;
    email!: string;
    phone!: string | undefined;
    address!: MemberAddressDto | undefined;
    doB!: moment.Moment;
    ssn!: string;
    gender!: Gender;
    isUSCitizen!: boolean;
    packageId!: number;
    utmParameter!: UTMParameterInfo | undefined;
    trackingInfo!: TrackingInfo | undefined;

    constructor(data?: IRegisterMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.registrationId = _data["registrationId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"] ? MemberAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.gender = _data["gender"];
            this.isUSCitizen = _data["isUSCitizen"];
            this.packageId = _data["packageId"];
            this.utmParameter = _data["utmParameter"] ? UTMParameterInfo.fromJS(_data["utmParameter"]) : <any>undefined;
            this.trackingInfo = _data["trackingInfo"] ? TrackingInfo.fromJS(_data["trackingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterMemberRequest {
    password: string;
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string | undefined;
    address: MemberAddressDto | undefined;
    doB: moment.Moment;
    ssn: string;
    gender: Gender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo | undefined;
    trackingInfo: TrackingInfo | undefined;
}

export class RenameForecastModelInput implements IRenameForecastModelInput {
    id!: number;
    newName!: string;

    constructor(data?: IRenameForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newName = _data["newName"];
        }
    }

    static fromJS(data: any): RenameForecastModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data;
    }
}

export interface IRenameForecastModelInput {
    id: number;
    newName: string;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class RenamePartnerTypeInput implements IRenamePartnerTypeInput {
    id!: number;
    name!: string;

    constructor(data?: IRenamePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RenamePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRenamePartnerTypeInput {
    id: number;
    name: string;
}

export class RenameStageChecklistPointInput implements IRenameStageChecklistPointInput {
    id!: number;
    name!: string;

    constructor(data?: IRenameStageChecklistPointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RenameStageChecklistPointInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameStageChecklistPointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRenameStageChecklistPointInput {
    id: number;
    name: string;
}

export class RenameStageInput implements IRenameStageInput {
    id!: number;
    name!: string;

    constructor(data?: IRenameStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RenameStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRenameStageInput {
    id: number;
    name: string;
}

export class RenameSyncAccountInput implements IRenameSyncAccountInput {
    id!: number;
    newName!: string;

    constructor(data?: IRenameSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newName = _data["newName"];
        }
    }

    static fromJS(data: any): RenameSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data;
    }
}

export interface IRenameSyncAccountInput {
    id: number;
    newName: string;
}

export class ReportSectionDto implements IReportSectionDto {
    group!: SectionGroup;
    name!: string | undefined;

    constructor(data?: IReportSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReportSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["name"] = this.name;
        return data;
    }
}

export interface IReportSectionDto {
    group: SectionGroup;
    name: string | undefined;
}

export enum ReportTemplate {
    Personal = "Personal",
    Suspense = "Suspense",
    Business = "Business",
    Yacht = "Yacht",
    JH1 = "JH1",
}

export class RequestConnectionInput implements IRequestConnectionInput {
    syncTypeId!: string;
    mode!: ConnectionMode;
    syncAccountId!: number | undefined;

    constructor(data?: IRequestConnectionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.syncTypeId = _data["syncTypeId"];
            this.mode = _data["mode"];
            this.syncAccountId = _data["syncAccountId"];
        }
    }

    static fromJS(data: any): RequestConnectionInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestConnectionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncTypeId"] = this.syncTypeId;
        data["mode"] = this.mode;
        data["syncAccountId"] = this.syncAccountId;
        return data;
    }
}

export interface IRequestConnectionInput {
    syncTypeId: string;
    mode: ConnectionMode;
    syncAccountId: number | undefined;
}

export class RequestConnectionOutput implements IRequestConnectionOutput {
    connectUrl!: string | undefined;
    scope!: string[] | undefined;
    clientName!: string | undefined;
    environment!: string | undefined;
    publicKey!: string | undefined;
    webhookUrl!: string | undefined;

    constructor(data?: IRequestConnectionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectUrl = _data["connectUrl"];
            if (Array.isArray(_data["scope"])) {
                this.scope = [] as any;
                for (let item of _data["scope"])
                    this.scope!.push(item);
            }
            this.clientName = _data["clientName"];
            this.environment = _data["environment"];
            this.publicKey = _data["publicKey"];
            this.webhookUrl = _data["webhookUrl"];
        }
    }

    static fromJS(data: any): RequestConnectionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestConnectionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectUrl"] = this.connectUrl;
        if (Array.isArray(this.scope)) {
            data["scope"] = [];
            for (let item of this.scope)
                data["scope"].push(item);
        }
        data["clientName"] = this.clientName;
        data["environment"] = this.environment;
        data["publicKey"] = this.publicKey;
        data["webhookUrl"] = this.webhookUrl;
        return data;
    }
}

export interface IRequestConnectionOutput {
    connectUrl: string | undefined;
    scope: string[] | undefined;
    clientName: string | undefined;
    environment: string | undefined;
    publicKey: string | undefined;
    webhookUrl: string | undefined;
}

export class RequestKBAInput implements IRequestKBAInput {
    redirectUrl!: string;
    cssUrl!: string | undefined;

    constructor(data?: IRequestKBAInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redirectUrl = _data["redirectUrl"];
            this.cssUrl = _data["cssUrl"];
        }
    }

    static fromJS(data: any): RequestKBAInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKBAInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirectUrl"] = this.redirectUrl;
        data["cssUrl"] = this.cssUrl;
        return data;
    }
}

export interface IRequestKBAInput {
    redirectUrl: string;
    cssUrl: string | undefined;
}

export class RequestKBAOutput implements IRequestKBAOutput {
    kbaAlreadyPassed!: boolean;
    kbaUrl!: string | undefined;

    constructor(data?: IRequestKBAOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kbaAlreadyPassed = _data["kbaAlreadyPassed"];
            this.kbaUrl = _data["kbaUrl"];
        }
    }

    static fromJS(data: any): RequestKBAOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKBAOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kbaAlreadyPassed"] = this.kbaAlreadyPassed;
        data["kbaUrl"] = this.kbaUrl;
        return data;
    }
}

export interface IRequestKBAOutput {
    kbaAlreadyPassed: boolean;
    kbaUrl: string | undefined;
}

export class RequestPaymentDto implements IRequestPaymentDto {
    subscriptionInfo!: ModuleSubscriptionInfo | undefined;
    requestType!: RequestPaymentType;

    constructor(data?: IRequestPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionInfo = _data["subscriptionInfo"] ? ModuleSubscriptionInfo.fromJS(_data["subscriptionInfo"]) : <any>undefined;
            this.requestType = _data["requestType"];
        }
    }

    static fromJS(data: any): RequestPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionInfo"] = this.subscriptionInfo ? this.subscriptionInfo.toJSON() : <any>undefined;
        data["requestType"] = this.requestType;
        return data;
    }
}

export interface IRequestPaymentDto {
    subscriptionInfo: ModuleSubscriptionInfo | undefined;
    requestType: RequestPaymentType;
}

export class RequestPaymentResult implements IRequestPaymentResult {
    transactionId!: string | undefined;
    code!: string | undefined;

    constructor(data?: IRequestPaymentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): RequestPaymentResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPaymentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["code"] = this.code;
        return data;
    }
}

export interface IRequestPaymentResult {
    transactionId: string | undefined;
    code: string | undefined;
}

export enum RequestPaymentType {
    PayPal = "PayPal",
    ManualBankTransfer = "ManualBankTransfer",
}

export class RequestStripePaymentInput implements IRequestStripePaymentInput {
    productId!: number;
    paymentPeriodType!: PaymentPeriodType;
    quantity!: number;

    constructor(data?: IRequestStripePaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): RequestStripePaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStripePaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IRequestStripePaymentInput {
    productId: number;
    paymentPeriodType: PaymentPeriodType;
    quantity: number;
}

export class RequestStripePaymentOutput implements IRequestStripePaymentOutput {
    paymentLink!: string | undefined;

    constructor(data?: IRequestStripePaymentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentLink = _data["paymentLink"];
        }
    }

    static fromJS(data: any): RequestStripePaymentOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStripePaymentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentLink"] = this.paymentLink;
        return data;
    }
}

export interface IRequestStripePaymentOutput {
    paymentLink: string | undefined;
}

export class RequestWithdrawalInput implements IRequestWithdrawalInput {
    contactId!: number;
    amount!: number;
    date!: moment.Moment | undefined;

    constructor(data?: IRequestWithdrawalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.amount = _data["amount"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestWithdrawalInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestWithdrawalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRequestWithdrawalInput {
    contactId: number;
    amount: number;
    date: moment.Moment | undefined;
}

export class ResetClassificationDto implements IResetClassificationDto {
    unclassify!: boolean;
    removeRules!: boolean;
    removeCategoryTree!: boolean;
    removeForecasts!: boolean;

    constructor(data?: IResetClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unclassify = false;
            this.removeRules = false;
            this.removeCategoryTree = false;
            this.removeForecasts = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unclassify = _data["unclassify"] !== undefined ? _data["unclassify"] : false;
            this.removeRules = _data["removeRules"] !== undefined ? _data["removeRules"] : false;
            this.removeCategoryTree = _data["removeCategoryTree"] !== undefined ? _data["removeCategoryTree"] : false;
            this.removeForecasts = _data["removeForecasts"] !== undefined ? _data["removeForecasts"] : false;
        }
    }

    static fromJS(data: any): ResetClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unclassify"] = this.unclassify;
        data["removeRules"] = this.removeRules;
        data["removeCategoryTree"] = this.removeCategoryTree;
        data["removeForecasts"] = this.removeForecasts;
        return data;
    }
}

export interface IResetClassificationDto {
    unclassify: boolean;
    removeRules: boolean;
    removeCategoryTree: boolean;
    removeForecasts: boolean;
}

export class ResetPasswordInput implements IResetPasswordInput {
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    userId!: number | undefined;
    resetCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IResetPasswordInput {
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    userId: number | undefined;
    resetCode: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class ResetUserPasswordDto implements IResetUserPasswordDto {
    id!: number;
    password!: string | undefined;
    setRandomPassword!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;

    constructor(data?: IResetUserPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.password = _data["password"];
            this.setRandomPassword = _data["setRandomPassword"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
        }
    }

    static fromJS(data: any): ResetUserPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetUserPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        data["setRandomPassword"] = this.setRandomPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        return data;
    }
}

export interface IResetUserPasswordDto {
    id: number;
    password: string | undefined;
    setRandomPassword: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    moduleId!: ModuleType | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: moment.Moment;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.moduleId = _data["moduleId"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["moduleId"] = this.moduleId;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    moduleId: ModuleType | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class RuleDto implements IRuleDto {
    parentId!: number | undefined;
    name!: string | undefined;
    categoryId!: number;
    creationTime!: moment.Moment;
    sortOrder!: number;
    isActive!: boolean;
    transactionCount!: number;
    id!: number;

    constructor(data?: IRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.categoryId = _data["categoryId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.sortOrder = _data["sortOrder"];
            this.isActive = _data["isActive"];
            this.transactionCount = _data["transactionCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sortOrder"] = this.sortOrder;
        data["isActive"] = this.isActive;
        data["transactionCount"] = this.transactionCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IRuleDto {
    parentId: number | undefined;
    name: string | undefined;
    categoryId: number;
    creationTime: moment.Moment;
    sortOrder: number;
    isActive: boolean;
    transactionCount: number;
    id: number;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SalesTalkLeadInfo implements ISalesTalkLeadInfo {
    companyId!: number | undefined;
    leadId!: number;
    salutation!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    mobilePhone!: string | undefined;
    homePhone!: string | undefined;
    workPhone!: string | undefined;
    tollPhone!: string | undefined;
    faxPhone!: string | undefined;
    homeAddress1!: string | undefined;
    homeCity!: string | undefined;
    homeState!: string | undefined;
    homeCountry!: string | undefined;
    homeZip!: string | undefined;
    officeAddress1!: string | undefined;
    officeCity!: string | undefined;
    officeState!: string | undefined;
    officeCountry!: string | undefined;
    officeZip!: string | undefined;
    companyName!: string | undefined;
    companyDescription!: string | undefined;
    companyAnnualRevenue!: number | undefined;
    companyEmployeeCount!: number | undefined;
    companyIndustry!: string | undefined;
    companyTickerSymbol!: string | undefined;
    companyWebSite!: string | undefined;
    title!: string | undefined;
    leadStage!: string | undefined;
    source!: string | undefined;
    timezone!: string | undefined;

    constructor(data?: ISalesTalkLeadInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.leadId = _data["leadId"];
            this.salutation = _data["salutation"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.mobilePhone = _data["mobilePhone"];
            this.homePhone = _data["homePhone"];
            this.workPhone = _data["workPhone"];
            this.tollPhone = _data["tollPhone"];
            this.faxPhone = _data["faxPhone"];
            this.homeAddress1 = _data["homeAddress1"];
            this.homeCity = _data["homeCity"];
            this.homeState = _data["homeState"];
            this.homeCountry = _data["homeCountry"];
            this.homeZip = _data["homeZip"];
            this.officeAddress1 = _data["officeAddress1"];
            this.officeCity = _data["officeCity"];
            this.officeState = _data["officeState"];
            this.officeCountry = _data["officeCountry"];
            this.officeZip = _data["officeZip"];
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyAnnualRevenue = _data["companyAnnualRevenue"];
            this.companyEmployeeCount = _data["companyEmployeeCount"];
            this.companyIndustry = _data["companyIndustry"];
            this.companyTickerSymbol = _data["companyTickerSymbol"];
            this.companyWebSite = _data["companyWebSite"];
            this.title = _data["title"];
            this.leadStage = _data["leadStage"];
            this.source = _data["source"];
            this.timezone = _data["timezone"];
        }
    }

    static fromJS(data: any): SalesTalkLeadInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SalesTalkLeadInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["leadId"] = this.leadId;
        data["salutation"] = this.salutation;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["mobilePhone"] = this.mobilePhone;
        data["homePhone"] = this.homePhone;
        data["workPhone"] = this.workPhone;
        data["tollPhone"] = this.tollPhone;
        data["faxPhone"] = this.faxPhone;
        data["homeAddress1"] = this.homeAddress1;
        data["homeCity"] = this.homeCity;
        data["homeState"] = this.homeState;
        data["homeCountry"] = this.homeCountry;
        data["homeZip"] = this.homeZip;
        data["officeAddress1"] = this.officeAddress1;
        data["officeCity"] = this.officeCity;
        data["officeState"] = this.officeState;
        data["officeCountry"] = this.officeCountry;
        data["officeZip"] = this.officeZip;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyAnnualRevenue"] = this.companyAnnualRevenue;
        data["companyEmployeeCount"] = this.companyEmployeeCount;
        data["companyIndustry"] = this.companyIndustry;
        data["companyTickerSymbol"] = this.companyTickerSymbol;
        data["companyWebSite"] = this.companyWebSite;
        data["title"] = this.title;
        data["leadStage"] = this.leadStage;
        data["source"] = this.source;
        data["timezone"] = this.timezone;
        return data;
    }
}

export interface ISalesTalkLeadInfo {
    companyId: number | undefined;
    leadId: number;
    salutation: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    mobilePhone: string | undefined;
    homePhone: string | undefined;
    workPhone: string | undefined;
    tollPhone: string | undefined;
    faxPhone: string | undefined;
    homeAddress1: string | undefined;
    homeCity: string | undefined;
    homeState: string | undefined;
    homeCountry: string | undefined;
    homeZip: string | undefined;
    officeAddress1: string | undefined;
    officeCity: string | undefined;
    officeState: string | undefined;
    officeCountry: string | undefined;
    officeZip: string | undefined;
    companyName: string | undefined;
    companyDescription: string | undefined;
    companyAnnualRevenue: number | undefined;
    companyEmployeeCount: number | undefined;
    companyIndustry: string | undefined;
    companyTickerSymbol: string | undefined;
    companyWebSite: string | undefined;
    title: string | undefined;
    leadStage: string | undefined;
    source: string | undefined;
    timezone: string | undefined;
}

export class SalesTalkSettings implements ISalesTalkSettings {
    isEnabled!: boolean;
    url!: string | undefined;
    apiKey!: string | undefined;

    constructor(data?: ISalesTalkSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.url = _data["url"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): SalesTalkSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SalesTalkSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["url"] = this.url;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface ISalesTalkSettings {
    isEnabled: boolean;
    url: string | undefined;
    apiKey: string | undefined;
}

export class SalesTalkSettingsInput implements ISalesTalkSettingsInput {
    isEnabled!: boolean;
    url!: string | undefined;
    apiKey!: string | undefined;

    constructor(data?: ISalesTalkSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.url = _data["url"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): SalesTalkSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new SalesTalkSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["url"] = this.url;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface ISalesTalkSettingsInput {
    isEnabled: boolean;
    url: string | undefined;
    apiKey: string | undefined;
}

export class SalesTalkUpdateLeadInfo implements ISalesTalkUpdateLeadInfo {
    userEmail!: string | undefined;
    leadId!: number;
    salutation!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    mobilePhone!: string | undefined;
    homePhone!: string | undefined;
    workPhone!: string | undefined;
    tollPhone!: string | undefined;
    faxPhone!: string | undefined;
    homeAddress1!: string | undefined;
    homeCity!: string | undefined;
    homeState!: string | undefined;
    homeCountry!: string | undefined;
    homeZip!: string | undefined;
    officeAddress1!: string | undefined;
    officeCity!: string | undefined;
    officeState!: string | undefined;
    officeCountry!: string | undefined;
    officeZip!: string | undefined;
    companyName!: string | undefined;
    companyDescription!: string | undefined;
    companyAnnualRevenue!: number | undefined;
    companyEmployeeCount!: number | undefined;
    companyIndustry!: string | undefined;
    companyTickerSymbol!: string | undefined;
    companyWebSite!: string | undefined;
    title!: string | undefined;
    leadStage!: string | undefined;
    source!: string | undefined;
    timezone!: string | undefined;

    constructor(data?: ISalesTalkUpdateLeadInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEmail = _data["userEmail"];
            this.leadId = _data["leadId"];
            this.salutation = _data["salutation"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.mobilePhone = _data["mobilePhone"];
            this.homePhone = _data["homePhone"];
            this.workPhone = _data["workPhone"];
            this.tollPhone = _data["tollPhone"];
            this.faxPhone = _data["faxPhone"];
            this.homeAddress1 = _data["homeAddress1"];
            this.homeCity = _data["homeCity"];
            this.homeState = _data["homeState"];
            this.homeCountry = _data["homeCountry"];
            this.homeZip = _data["homeZip"];
            this.officeAddress1 = _data["officeAddress1"];
            this.officeCity = _data["officeCity"];
            this.officeState = _data["officeState"];
            this.officeCountry = _data["officeCountry"];
            this.officeZip = _data["officeZip"];
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyAnnualRevenue = _data["companyAnnualRevenue"];
            this.companyEmployeeCount = _data["companyEmployeeCount"];
            this.companyIndustry = _data["companyIndustry"];
            this.companyTickerSymbol = _data["companyTickerSymbol"];
            this.companyWebSite = _data["companyWebSite"];
            this.title = _data["title"];
            this.leadStage = _data["leadStage"];
            this.source = _data["source"];
            this.timezone = _data["timezone"];
        }
    }

    static fromJS(data: any): SalesTalkUpdateLeadInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SalesTalkUpdateLeadInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail;
        data["leadId"] = this.leadId;
        data["salutation"] = this.salutation;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["mobilePhone"] = this.mobilePhone;
        data["homePhone"] = this.homePhone;
        data["workPhone"] = this.workPhone;
        data["tollPhone"] = this.tollPhone;
        data["faxPhone"] = this.faxPhone;
        data["homeAddress1"] = this.homeAddress1;
        data["homeCity"] = this.homeCity;
        data["homeState"] = this.homeState;
        data["homeCountry"] = this.homeCountry;
        data["homeZip"] = this.homeZip;
        data["officeAddress1"] = this.officeAddress1;
        data["officeCity"] = this.officeCity;
        data["officeState"] = this.officeState;
        data["officeCountry"] = this.officeCountry;
        data["officeZip"] = this.officeZip;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyAnnualRevenue"] = this.companyAnnualRevenue;
        data["companyEmployeeCount"] = this.companyEmployeeCount;
        data["companyIndustry"] = this.companyIndustry;
        data["companyTickerSymbol"] = this.companyTickerSymbol;
        data["companyWebSite"] = this.companyWebSite;
        data["title"] = this.title;
        data["leadStage"] = this.leadStage;
        data["source"] = this.source;
        data["timezone"] = this.timezone;
        return data;
    }
}

export interface ISalesTalkUpdateLeadInfo {
    userEmail: string | undefined;
    leadId: number;
    salutation: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    mobilePhone: string | undefined;
    homePhone: string | undefined;
    workPhone: string | undefined;
    tollPhone: string | undefined;
    faxPhone: string | undefined;
    homeAddress1: string | undefined;
    homeCity: string | undefined;
    homeState: string | undefined;
    homeCountry: string | undefined;
    homeZip: string | undefined;
    officeAddress1: string | undefined;
    officeCity: string | undefined;
    officeState: string | undefined;
    officeCountry: string | undefined;
    officeZip: string | undefined;
    companyName: string | undefined;
    companyDescription: string | undefined;
    companyAnnualRevenue: number | undefined;
    companyEmployeeCount: number | undefined;
    companyIndustry: string | undefined;
    companyTickerSymbol: string | undefined;
    companyWebSite: string | undefined;
    title: string | undefined;
    leadStage: string | undefined;
    source: string | undefined;
    timezone: string | undefined;
}

export class SalesTalkUpdateLeadOutput implements ISalesTalkUpdateLeadOutput {
    validationErrors!: string[] | undefined;

    constructor(data?: ISalesTalkUpdateLeadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): SalesTalkUpdateLeadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SalesTalkUpdateLeadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface ISalesTalkUpdateLeadOutput {
    validationErrors: string[] | undefined;
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class ScoreFactorDto implements IScoreFactorDto {
    isPositive!: boolean;
    text!: string | undefined;

    constructor(data?: IScoreFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isPositive = _data["isPositive"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): ScoreFactorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isPositive"] = this.isPositive;
        data["text"] = this.text;
        return data;
    }
}

export interface IScoreFactorDto {
    isPositive: boolean;
    text: string | undefined;
}

export class ScoreHistoryDto implements IScoreHistoryDto {
    scoreDate!: moment.Moment;
    score!: number;

    constructor(data?: IScoreHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scoreDate = _data["scoreDate"] ? moment(_data["scoreDate"].toString()) : <any>undefined;
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): ScoreHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["score"] = this.score;
        return data;
    }
}

export interface IScoreHistoryDto {
    scoreDate: moment.Moment;
    score: number;
}

export class ScoreSimulatorDto implements IScoreSimulatorDto {
    onTimePayment!: number | undefined;
    closeOldestCreditCard!: boolean | undefined;
    oneAccountPastDue!: number | undefined;
    allAccountsPastDue!: number | undefined;
    increaseCreditBalance!: number | undefined;
    decreaseCreditBalance!: number | undefined;
    increaseCreditCardLimit!: number | undefined;
    moveOneAccountToCollection!: boolean | undefined;
    addTaxLienPublicRecord!: boolean | undefined;
    addForeClosurePublicRecord!: boolean | undefined;
    addChildSupportPublicRecord!: boolean | undefined;
    addWageGarnishmentPublicRecord!: boolean | undefined;
    declareBankruptcy!: boolean | undefined;
    payOffAllCreditCards!: boolean | undefined;
    applyForCreditCard!: number | undefined;
    obtainCreditCard!: number | undefined;
    obtainMortgage!: number | undefined;
    obtainAutoLoan!: number | undefined;
    obtainPersonalLoan!: number | undefined;
    transferCreditBalances!: number | undefined;

    constructor(data?: IScoreSimulatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTimePayment = _data["onTimePayment"];
            this.closeOldestCreditCard = _data["closeOldestCreditCard"];
            this.oneAccountPastDue = _data["oneAccountPastDue"];
            this.allAccountsPastDue = _data["allAccountsPastDue"];
            this.increaseCreditBalance = _data["increaseCreditBalance"];
            this.decreaseCreditBalance = _data["decreaseCreditBalance"];
            this.increaseCreditCardLimit = _data["increaseCreditCardLimit"];
            this.moveOneAccountToCollection = _data["moveOneAccountToCollection"];
            this.addTaxLienPublicRecord = _data["addTaxLienPublicRecord"];
            this.addForeClosurePublicRecord = _data["addForeClosurePublicRecord"];
            this.addChildSupportPublicRecord = _data["addChildSupportPublicRecord"];
            this.addWageGarnishmentPublicRecord = _data["addWageGarnishmentPublicRecord"];
            this.declareBankruptcy = _data["declareBankruptcy"];
            this.payOffAllCreditCards = _data["payOffAllCreditCards"];
            this.applyForCreditCard = _data["applyForCreditCard"];
            this.obtainCreditCard = _data["obtainCreditCard"];
            this.obtainMortgage = _data["obtainMortgage"];
            this.obtainAutoLoan = _data["obtainAutoLoan"];
            this.obtainPersonalLoan = _data["obtainPersonalLoan"];
            this.transferCreditBalances = _data["transferCreditBalances"];
        }
    }

    static fromJS(data: any): ScoreSimulatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreSimulatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTimePayment"] = this.onTimePayment;
        data["closeOldestCreditCard"] = this.closeOldestCreditCard;
        data["oneAccountPastDue"] = this.oneAccountPastDue;
        data["allAccountsPastDue"] = this.allAccountsPastDue;
        data["increaseCreditBalance"] = this.increaseCreditBalance;
        data["decreaseCreditBalance"] = this.decreaseCreditBalance;
        data["increaseCreditCardLimit"] = this.increaseCreditCardLimit;
        data["moveOneAccountToCollection"] = this.moveOneAccountToCollection;
        data["addTaxLienPublicRecord"] = this.addTaxLienPublicRecord;
        data["addForeClosurePublicRecord"] = this.addForeClosurePublicRecord;
        data["addChildSupportPublicRecord"] = this.addChildSupportPublicRecord;
        data["addWageGarnishmentPublicRecord"] = this.addWageGarnishmentPublicRecord;
        data["declareBankruptcy"] = this.declareBankruptcy;
        data["payOffAllCreditCards"] = this.payOffAllCreditCards;
        data["applyForCreditCard"] = this.applyForCreditCard;
        data["obtainCreditCard"] = this.obtainCreditCard;
        data["obtainMortgage"] = this.obtainMortgage;
        data["obtainAutoLoan"] = this.obtainAutoLoan;
        data["obtainPersonalLoan"] = this.obtainPersonalLoan;
        data["transferCreditBalances"] = this.transferCreditBalances;
        return data;
    }
}

export interface IScoreSimulatorDto {
    onTimePayment: number | undefined;
    closeOldestCreditCard: boolean | undefined;
    oneAccountPastDue: number | undefined;
    allAccountsPastDue: number | undefined;
    increaseCreditBalance: number | undefined;
    decreaseCreditBalance: number | undefined;
    increaseCreditCardLimit: number | undefined;
    moveOneAccountToCollection: boolean | undefined;
    addTaxLienPublicRecord: boolean | undefined;
    addForeClosurePublicRecord: boolean | undefined;
    addChildSupportPublicRecord: boolean | undefined;
    addWageGarnishmentPublicRecord: boolean | undefined;
    declareBankruptcy: boolean | undefined;
    payOffAllCreditCards: boolean | undefined;
    applyForCreditCard: number | undefined;
    obtainCreditCard: number | undefined;
    obtainMortgage: number | undefined;
    obtainAutoLoan: number | undefined;
    obtainPersonalLoan: number | undefined;
    transferCreditBalances: number | undefined;
}

export class ScoreSimulatorInfoDto implements IScoreSimulatorInfoDto {
    initialScore!: number;
    totalCreditLimit!: number;
    outstandingBalance!: number;
    isDemoPackage!: boolean;
    accessStatus!: MemberSimulatorAccessStatus;

    constructor(data?: IScoreSimulatorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.initialScore = _data["initialScore"];
            this.totalCreditLimit = _data["totalCreditLimit"];
            this.outstandingBalance = _data["outstandingBalance"];
            this.isDemoPackage = _data["isDemoPackage"];
            this.accessStatus = _data["accessStatus"];
        }
    }

    static fromJS(data: any): ScoreSimulatorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreSimulatorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initialScore"] = this.initialScore;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["isDemoPackage"] = this.isDemoPackage;
        data["accessStatus"] = this.accessStatus;
        return data;
    }
}

export interface IScoreSimulatorInfoDto {
    initialScore: number;
    totalCreditLimit: number;
    outstandingBalance: number;
    isDemoPackage: boolean;
    accessStatus: MemberSimulatorAccessStatus;
}

export enum SectionGroup {
    Income = "Income",
    CostOfSales = "CostOfSales",
    Expense = "Expense",
    OtherIncomeExpense = "OtherIncomeExpense",
}

export enum SecuringType {
    Unsecured = "Unsecured",
    Secured = "Secured",
    Prepaid = "Prepaid",
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class SelectPackageResponseDto implements ISelectPackageResponseDto {
    registrationId!: string | undefined;
    memberInfo!: MemberInfoDto | undefined;
    paymentAuthorizationRequired!: boolean;

    constructor(data?: ISelectPackageResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationId = _data["registrationId"];
            this.memberInfo = _data["memberInfo"] ? MemberInfoDto.fromJS(_data["memberInfo"]) : <any>undefined;
            this.paymentAuthorizationRequired = _data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SelectPackageResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectPackageResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data;
    }
}

export interface ISelectPackageResponseDto {
    registrationId: string | undefined;
    memberInfo: MemberInfoDto | undefined;
    paymentAuthorizationRequired: boolean;
}

export enum SellPeriod {
    Immediately = "Immediately",
    OneToThreeMonths = "OneToThreeMonths",
    ThreeToSixMonths = "ThreeToSixMonths",
    SixPlusMonths = "SixPlusMonths",
}

export class SendAnnouncementRequest implements ISendAnnouncementRequest {
    campaignId!: number;
    offerDetailsLink!: string;
    serviceName!: MailSenderType;
    contactListName!: string | undefined;
    emailAddresses!: string[] | undefined;

    constructor(data?: ISendAnnouncementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.campaignId = _data["campaignId"];
            this.offerDetailsLink = _data["offerDetailsLink"];
            this.serviceName = _data["serviceName"];
            this.contactListName = _data["contactListName"];
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(item);
            }
        }
    }

    static fromJS(data: any): SendAnnouncementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendAnnouncementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["offerDetailsLink"] = this.offerDetailsLink;
        data["serviceName"] = this.serviceName;
        data["contactListName"] = this.contactListName;
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        return data;
    }
}

export interface ISendAnnouncementRequest {
    campaignId: number;
    offerDetailsLink: string;
    serviceName: MailSenderType;
    contactListName: string | undefined;
    emailAddresses: string[] | undefined;
}

export class SendAutoLoginLinkInput implements ISendAutoLoginLinkInput {
    emailAddress!: string;
    autoDetectTenancy!: boolean;
    features!: string[] | undefined;
    appRoute!: string | undefined;

    constructor(data?: ISendAutoLoginLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.autoDetectTenancy = _data["autoDetectTenancy"] !== undefined ? _data["autoDetectTenancy"] : false;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(item);
            }
            this.appRoute = _data["appRoute"];
        }
    }

    static fromJS(data: any): SendAutoLoginLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendAutoLoginLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        data["appRoute"] = this.appRoute;
        return data;
    }
}

export interface ISendAutoLoginLinkInput {
    emailAddress: string;
    autoDetectTenancy: boolean;
    features: string[] | undefined;
    appRoute: string | undefined;
}

export class SendAutoLoginLinkOutput implements ISendAutoLoginLinkOutput {
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: ISendAutoLoginLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["detectedTenancies"])) {
                this.detectedTenancies = [] as any;
                for (let item of _data["detectedTenancies"])
                    this.detectedTenancies!.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendAutoLoginLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SendAutoLoginLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.detectedTenancies)) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendAutoLoginLinkOutput {
    detectedTenancies: TenantModel[] | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class SendEmailInput implements ISendEmailInput {
    contactId!: number;
    to!: string[];
    replyToId!: number | undefined;
    emailSettingsSource!: EmailSettingsSource;
    subject!: string;
    previewText!: string | undefined;
    saveAttachmentsToDocuments!: boolean;
    attachments!: FileInfo[] | undefined;
    replyTo!: string[] | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string;

    constructor(data?: ISendEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.to = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            if (Array.isArray(_data["to"])) {
                this.to = [] as any;
                for (let item of _data["to"])
                    this.to!.push(item);
            }
            this.replyToId = _data["replyToId"];
            this.emailSettingsSource = _data["emailSettingsSource"];
            this.subject = _data["subject"];
            this.previewText = _data["previewText"];
            this.saveAttachmentsToDocuments = _data["saveAttachmentsToDocuments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(FileInfo.fromJS(item));
            }
            if (Array.isArray(_data["replyTo"])) {
                this.replyTo = [] as any;
                for (let item of _data["replyTo"])
                    this.replyTo!.push(item);
            }
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): SendEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (Array.isArray(this.to)) {
            data["to"] = [];
            for (let item of this.to)
                data["to"].push(item);
        }
        data["replyToId"] = this.replyToId;
        data["emailSettingsSource"] = this.emailSettingsSource;
        data["subject"] = this.subject;
        data["previewText"] = this.previewText;
        data["saveAttachmentsToDocuments"] = this.saveAttachmentsToDocuments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.replyTo)) {
            data["replyTo"] = [];
            for (let item of this.replyTo)
                data["replyTo"].push(item);
        }
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        return data;
    }
}

export interface ISendEmailInput {
    contactId: number;
    to: string[];
    replyToId: number | undefined;
    emailSettingsSource: EmailSettingsSource;
    subject: string;
    previewText: string | undefined;
    saveAttachmentsToDocuments: boolean;
    attachments: FileInfo[] | undefined;
    replyTo: string[] | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string;
}

export class SendEmailToContactConfiguration implements ISendEmailToContactConfiguration {
    emailTemplateId!: number;
    contactGroupIds!: string[] | undefined;

    constructor(data?: ISendEmailToContactConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplateId = _data["emailTemplateId"];
            if (Array.isArray(_data["contactGroupIds"])) {
                this.contactGroupIds = [] as any;
                for (let item of _data["contactGroupIds"])
                    this.contactGroupIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmailToContactConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailToContactConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplateId"] = this.emailTemplateId;
        if (Array.isArray(this.contactGroupIds)) {
            data["contactGroupIds"] = [];
            for (let item of this.contactGroupIds)
                data["contactGroupIds"].push(item);
        }
        return data;
    }
}

export interface ISendEmailToContactConfiguration {
    emailTemplateId: number;
    contactGroupIds: string[] | undefined;
}

export class SendEmailToOrgUnitConfiguration implements ISendEmailToOrgUnitConfiguration {
    emailTemplateId!: number;
    contactGroupIds!: string[] | undefined;
    usersFilterTagId!: number | undefined;

    constructor(data?: ISendEmailToOrgUnitConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplateId = _data["emailTemplateId"];
            if (Array.isArray(_data["contactGroupIds"])) {
                this.contactGroupIds = [] as any;
                for (let item of _data["contactGroupIds"])
                    this.contactGroupIds!.push(item);
            }
            this.usersFilterTagId = _data["usersFilterTagId"];
        }
    }

    static fromJS(data: any): SendEmailToOrgUnitConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailToOrgUnitConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplateId"] = this.emailTemplateId;
        if (Array.isArray(this.contactGroupIds)) {
            data["contactGroupIds"] = [];
            for (let item of this.contactGroupIds)
                data["contactGroupIds"].push(item);
        }
        data["usersFilterTagId"] = this.usersFilterTagId;
        return data;
    }
}

export interface ISendEmailToOrgUnitConfiguration {
    emailTemplateId: number;
    contactGroupIds: string[] | undefined;
    usersFilterTagId: number | undefined;
}

export class SendGridSettingsDto implements ISendGridSettingsDto {
    apiKey!: string | undefined;
    rpTemplateId!: string | undefined;
    rpFromEmail!: string | undefined;
    webhookKey!: string | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;

    constructor(data?: ISendGridSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.rpTemplateId = _data["rpTemplateId"];
            this.rpFromEmail = _data["rpFromEmail"];
            this.webhookKey = _data["webhookKey"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): SendGridSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendGridSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["rpTemplateId"] = this.rpTemplateId;
        data["rpFromEmail"] = this.rpFromEmail;
        data["webhookKey"] = this.webhookKey;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface ISendGridSettingsDto {
    apiKey: string | undefined;
    rpTemplateId: string | undefined;
    rpFromEmail: string | undefined;
    webhookKey: string | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;
    autoDetectTenancy!: boolean;
    features!: string[] | undefined;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.autoDetectTenancy = _data["autoDetectTenancy"] !== undefined ? _data["autoDetectTenancy"] : false;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(item);
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
    autoDetectTenancy: boolean;
    features: string[] | undefined;
}

export class SendPasswordResetCodeOutput implements ISendPasswordResetCodeOutput {
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: ISendPasswordResetCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["detectedTenancies"])) {
                this.detectedTenancies = [] as any;
                for (let item of _data["detectedTenancies"])
                    this.detectedTenancies!.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.detectedTenancies)) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendPasswordResetCodeOutput {
    detectedTenancies: TenantModel[] | undefined;
}

export class SendReportNotificationInfo implements ISendReportNotificationInfo {
    recipientUserEmailAddress!: string;
    sendReportInAttachments!: boolean;

    constructor(data?: ISendReportNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipientUserEmailAddress = _data["recipientUserEmailAddress"];
            this.sendReportInAttachments = _data["sendReportInAttachments"];
        }
    }

    static fromJS(data: any): SendReportNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SendReportNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipientUserEmailAddress"] = this.recipientUserEmailAddress;
        data["sendReportInAttachments"] = this.sendReportInAttachments;
        return data;
    }
}

export interface ISendReportNotificationInfo {
    recipientUserEmailAddress: string;
    sendReportInAttachments: boolean;
}

export class SendReportNotificationInput implements ISendReportNotificationInput {
    reportId!: string;
    recipientUserEmailAddress!: string;
    sendReportInAttachments!: boolean;

    constructor(data?: ISendReportNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"];
            this.recipientUserEmailAddress = _data["recipientUserEmailAddress"];
            this.sendReportInAttachments = _data["sendReportInAttachments"];
        }
    }

    static fromJS(data: any): SendReportNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendReportNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["recipientUserEmailAddress"] = this.recipientUserEmailAddress;
        data["sendReportInAttachments"] = this.sendReportInAttachments;
        return data;
    }
}

export interface ISendReportNotificationInput {
    reportId: string;
    recipientUserEmailAddress: string;
    sendReportInAttachments: boolean;
}

export class SendSMSInput implements ISendSMSInput {
    contactId!: number;
    parentId!: number | undefined;
    phoneNumber!: string;
    message!: string | undefined;

    constructor(data?: ISendSMSInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.parentId = _data["parentId"];
            this.phoneNumber = _data["phoneNumber"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendSMSInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendSMSInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["parentId"] = this.parentId;
        data["phoneNumber"] = this.phoneNumber;
        data["message"] = this.message;
        return data;
    }
}

export interface ISendSMSInput {
    contactId: number;
    parentId: number | undefined;
    phoneNumber: string;
    message: string | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;
    from!: EmailFromSettings | undefined;
    smtp!: EmailSmtpSettings | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.from = _data["from"] ? EmailFromSettings.fromJS(_data["from"]) : <any>undefined;
            this.smtp = _data["smtp"] ? EmailSmtpSettings.fromJS(_data["smtp"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["smtp"] = this.smtp ? this.smtp.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
    from: EmailFromSettings | undefined;
    smtp: EmailSmtpSettings | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data;
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;
}

export class SetAffiliateLinkImageInput implements ISetAffiliateLinkImageInput {
    affiliateLinkId!: number;
    image!: string | undefined;

    constructor(data?: ISetAffiliateLinkImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affiliateLinkId = _data["affiliateLinkId"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): SetAffiliateLinkImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetAffiliateLinkImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affiliateLinkId"] = this.affiliateLinkId;
        data["image"] = this.image;
        return data;
    }
}

export interface ISetAffiliateLinkImageInput {
    affiliateLinkId: number;
    image: string | undefined;
}

export class SetAmountInfo implements ISetAmountInfo {
    orderId!: number;
    amount!: number;

    constructor(data?: ISetAmountInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): SetAmountInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SetAmountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["amount"] = this.amount;
        return data;
    }
}

export interface ISetAmountInfo {
    orderId: number;
    amount: number;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class SetLearningResourceGroupImageInput implements ISetLearningResourceGroupImageInput {
    id!: number;
    image!: string | undefined;

    constructor(data?: ISetLearningResourceGroupImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): SetLearningResourceGroupImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetLearningResourceGroupImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        return data;
    }
}

export interface ISetLearningResourceGroupImageInput {
    id: number;
    image: string | undefined;
}

export class SetLearningResourceImageInput implements ISetLearningResourceImageInput {
    id!: number;
    image!: string | undefined;

    constructor(data?: ISetLearningResourceImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): SetLearningResourceImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetLearningResourceImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        return data;
    }
}

export interface ISetLearningResourceImageInput {
    id: number;
    image: string | undefined;
}

export class SetProductImageInput implements ISetProductImageInput {
    productId!: number;
    image!: string | undefined;

    constructor(data?: ISetProductImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): SetProductImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetProductImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["image"] = this.image;
        return data;
    }
}

export interface ISetProductImageInput {
    productId: number;
    image: string | undefined;
}

export class SetResolvedInput implements ISetResolvedInput {
    threadId!: number;
    isResolved!: boolean;

    constructor(data?: ISetResolvedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.threadId = _data["threadId"];
            this.isResolved = _data["isResolved"];
        }
    }

    static fromJS(data: any): SetResolvedInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetResolvedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["isResolved"] = this.isResolved;
        return data;
    }
}

export interface ISetResolvedInput {
    threadId: number;
    isResolved: boolean;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class SetupOutput implements ISetupOutput {
    userId!: number | undefined;
    alreadyInitialized!: boolean;

    constructor(data?: ISetupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.alreadyInitialized = _data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): SetupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SetupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data;
    }
}

export interface ISetupOutput {
    userId: number | undefined;
    alreadyInitialized: boolean;
}

export class SetupSubscriptionInfoDto implements ISetupSubscriptionInfoDto {
    subscriptionInfo!: ModuleSubscriptionInfo | undefined;
    billingInfo!: PaymentRequestInfoDto | undefined;

    constructor(data?: ISetupSubscriptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionInfo = _data["subscriptionInfo"] ? ModuleSubscriptionInfo.fromJS(_data["subscriptionInfo"]) : <any>undefined;
            this.billingInfo = _data["billingInfo"] ? PaymentRequestInfoDto.fromJS(_data["billingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetupSubscriptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetupSubscriptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionInfo"] = this.subscriptionInfo ? this.subscriptionInfo.toJSON() : <any>undefined;
        data["billingInfo"] = this.billingInfo ? this.billingInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISetupSubscriptionInfoDto {
    subscriptionInfo: ModuleSubscriptionInfo | undefined;
    billingInfo: PaymentRequestInfoDto | undefined;
}

export class SetupSyncUserApplicationInput implements ISetupSyncUserApplicationInput {
    syncTypeId!: string;
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: ISetupSyncUserApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.syncTypeId = _data["syncTypeId"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): SetupSyncUserApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetupSyncUserApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncTypeId"] = this.syncTypeId;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface ISetupSyncUserApplicationInput {
    syncTypeId: string;
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class ShortPaymentInfo implements IShortPaymentInfo {
    date!: moment.Moment;
    amount!: number;

    constructor(data?: IShortPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): ShortPaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ShortPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IShortPaymentInfo {
    date: moment.Moment;
    amount: number;
}

export class SignUpMemberRequest implements ISignUpMemberRequest {
    firstName!: string;
    lastName!: string;
    email!: string;
    phoneNumber!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isUSCitizen!: boolean;
    pendingPasswordReset!: boolean;

    constructor(data?: ISignUpMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.postalCode = _data["postalCode"];
            this.countryCode = _data["countryCode"];
            this.isUSCitizen = _data["isUSCitizen"];
            this.pendingPasswordReset = _data["pendingPasswordReset"];
        }
    }

    static fromJS(data: any): SignUpMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isUSCitizen"] = this.isUSCitizen;
        data["pendingPasswordReset"] = this.pendingPasswordReset;
        return data;
    }
}

export interface ISignUpMemberRequest {
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isUSCitizen: boolean;
    pendingPasswordReset: boolean;
}

export class SignUpMemberResponse implements ISignUpMemberResponse {
    authenticateResult!: AuthenticateResultModel | undefined;

    constructor(data?: ISignUpMemberResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticateResult = _data["authenticateResult"] ? AuthenticateResultModel.fromJS(_data["authenticateResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SignUpMemberResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpMemberResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticateResult"] = this.authenticateResult ? this.authenticateResult.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISignUpMemberResponse {
    authenticateResult: AuthenticateResultModel | undefined;
}

export class SignUpRequest implements ISignUpRequest {
    fullName!: string;
    email!: string;
    password!: string;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignUpRequest {
    fullName: string;
    email: string;
    password: string;
}

export class SimilarContactOutput implements ISimilarContactOutput {
    id!: number;
    parentId!: number | undefined;
    name!: string | undefined;
    photo!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;
    ratingId!: number | undefined;
    score!: number;

    constructor(data?: ISimilarContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.photo = _data["photo"];
            this.companyName = _data["companyName"];
            this.jobTitle = _data["jobTitle"];
            this.ratingId = _data["ratingId"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): SimilarContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SimilarContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["photo"] = this.photo;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        data["ratingId"] = this.ratingId;
        data["score"] = this.score;
        return data;
    }
}

export interface ISimilarContactOutput {
    id: number;
    parentId: number | undefined;
    name: string | undefined;
    photo: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
    ratingId: number | undefined;
    score: number;
}

export enum SortOrderType {
    Best = "Best",
    Newest = "Newest",
}

export class SourceContactInfo implements ISourceContactInfo {
    id!: number;
    typeId!: string | undefined;
    affiliateCode!: string | undefined;
    companyName!: string | undefined;
    personName!: string | undefined;
    jobTitle!: string | undefined;

    constructor(data?: ISourceContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.affiliateCode = _data["affiliateCode"];
            this.companyName = _data["companyName"];
            this.personName = _data["personName"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): SourceContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SourceContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["affiliateCode"] = this.affiliateCode;
        data["companyName"] = this.companyName;
        data["personName"] = this.personName;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface ISourceContactInfo {
    id: number;
    typeId: string | undefined;
    affiliateCode: string | undefined;
    companyName: string | undefined;
    personName: string | undefined;
    jobTitle: string | undefined;
}

export class SourceContactLevelInfo implements ISourceContactLevelInfo {
    id!: number;
    name!: string | undefined;
    affiliateCode!: string | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: ISourceContactLevelInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.affiliateCode = _data["affiliateCode"];
            this.photoPublicId = _data["photoPublicId"];
        }
    }

    static fromJS(data: any): SourceContactLevelInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SourceContactLevelInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["affiliateCode"] = this.affiliateCode;
        data["photoPublicId"] = this.photoPublicId;
        return data;
    }
}

export interface ISourceContactLevelInfo {
    id: number;
    name: string | undefined;
    affiliateCode: string | undefined;
    photoPublicId: string | undefined;
}

export class StageChecklistPointDto implements IStageChecklistPointDto {
    id!: number;
    name!: string | undefined;
    sortOrder!: number;

    constructor(data?: IStageChecklistPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): StageChecklistPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageChecklistPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IStageChecklistPointDto {
    id: number;
    name: string | undefined;
    sortOrder: number;
}

export class StageChecklistPointInfoOutput implements IStageChecklistPointInfoOutput {
    stageId!: number;
    id!: number;
    name!: string | undefined;
    sortOrder!: number;
    isDone!: boolean;
    completionTime!: moment.Moment | undefined;
    completedByUserId!: number | undefined;

    constructor(data?: IStageChecklistPointInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stageId = _data["stageId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
            this.isDone = _data["isDone"];
            this.completionTime = _data["completionTime"] ? moment(_data["completionTime"].toString()) : <any>undefined;
            this.completedByUserId = _data["completedByUserId"];
        }
    }

    static fromJS(data: any): StageChecklistPointInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StageChecklistPointInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stageId"] = this.stageId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        data["isDone"] = this.isDone;
        data["completionTime"] = this.completionTime ? this.completionTime.toISOString() : <any>undefined;
        data["completedByUserId"] = this.completedByUserId;
        return data;
    }
}

export interface IStageChecklistPointInfoOutput {
    stageId: number;
    id: number;
    name: string | undefined;
    sortOrder: number;
    isDone: boolean;
    completionTime: moment.Moment | undefined;
    completedByUserId: number | undefined;
}

export class StageDto implements IStageDto {
    id!: number;
    name!: string | undefined;
    sortOrder!: number;
    color!: string | undefined;
    isFinal!: boolean;
    accessibleActions!: ActionDto[] | undefined;
    checklistPoints!: StageChecklistPointDto[] | undefined;

    constructor(data?: IStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
            this.color = _data["color"];
            this.isFinal = _data["isFinal"];
            if (Array.isArray(_data["accessibleActions"])) {
                this.accessibleActions = [] as any;
                for (let item of _data["accessibleActions"])
                    this.accessibleActions!.push(ActionDto.fromJS(item));
            }
            if (Array.isArray(_data["checklistPoints"])) {
                this.checklistPoints = [] as any;
                for (let item of _data["checklistPoints"])
                    this.checklistPoints!.push(StageChecklistPointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        data["color"] = this.color;
        data["isFinal"] = this.isFinal;
        if (Array.isArray(this.accessibleActions)) {
            data["accessibleActions"] = [];
            for (let item of this.accessibleActions)
                data["accessibleActions"].push(item.toJSON());
        }
        if (Array.isArray(this.checklistPoints)) {
            data["checklistPoints"] = [];
            for (let item of this.checklistPoints)
                data["checklistPoints"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStageDto {
    id: number;
    name: string | undefined;
    sortOrder: number;
    color: string | undefined;
    isFinal: boolean;
    accessibleActions: ActionDto[] | undefined;
    checklistPoints: StageChecklistPointDto[] | undefined;
}

export class StatsDetailFilter implements IStatsDetailFilter {
    searchTerm!: string | undefined;
    forecastModelId!: number | undefined;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsDetailFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchTerm = _data["searchTerm"];
            this.forecastModelId = _data["forecastModelId"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.accountingTypeId = _data["accountingTypeId"];
            this.categoryId = _data["categoryId"];
            this.reportSectionGroup = _data["reportSectionGroup"];
            this.reportSectionId = _data["reportSectionId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilter {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDetailFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        data["forecastModelId"] = this.forecastModelId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data;
    }
}

export interface IStatsDetailFilter {
    searchTerm: string | undefined;
    forecastModelId: number | undefined;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class StatsDetailFilterBase implements IStatsDetailFilterBase {
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsDetailFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.accountingTypeId = _data["accountingTypeId"];
            this.categoryId = _data["categoryId"];
            this.reportSectionGroup = _data["reportSectionGroup"];
            this.reportSectionId = _data["reportSectionId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilterBase {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDetailFilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data;
    }
}

export interface IStatsDetailFilterBase {
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class StatsFilter implements IStatsFilter {
    forecastModelId!: number | undefined;
    showResolvedComments!: boolean;
    groupByPeriod!: GroupByPeriod;
    dailyPeriods!: Period[] | undefined;
    calculateStartingBalance!: boolean;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.showResolvedComments = false;
            this.groupByPeriod = GroupByPeriod.Daily;
            this.calculateStartingBalance = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.forecastModelId = _data["forecastModelId"];
            this.showResolvedComments = _data["showResolvedComments"] !== undefined ? _data["showResolvedComments"] : false;
            this.groupByPeriod = _data["groupByPeriod"] !== undefined ? _data["groupByPeriod"] : GroupByPeriod.Daily;
            if (Array.isArray(_data["dailyPeriods"])) {
                this.dailyPeriods = [] as any;
                for (let item of _data["dailyPeriods"])
                    this.dailyPeriods!.push(Period.fromJS(item));
            }
            this.calculateStartingBalance = _data["calculateStartingBalance"] !== undefined ? _data["calculateStartingBalance"] : true;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            if (Array.isArray(_data["businessEntityIds"])) {
                this.businessEntityIds = [] as any;
                for (let item of _data["businessEntityIds"])
                    this.businessEntityIds!.push(item);
            }
        }
    }

    static fromJS(data: any): StatsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new StatsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["showResolvedComments"] = this.showResolvedComments;
        data["groupByPeriod"] = this.groupByPeriod;
        if (Array.isArray(this.dailyPeriods)) {
            data["dailyPeriods"] = [];
            for (let item of this.dailyPeriods)
                data["dailyPeriods"].push(item.toJSON());
        }
        data["calculateStartingBalance"] = this.calculateStartingBalance;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (Array.isArray(this.businessEntityIds)) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data;
    }
}

export interface IStatsFilter {
    forecastModelId: number | undefined;
    showResolvedComments: boolean;
    groupByPeriod: GroupByPeriod;
    dailyPeriods: Period[] | undefined;
    calculateStartingBalance: boolean;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export enum StatsType {
    Transaction = "Transaction",
    Adjustment = "Adjustment",
    Forecast = "Forecast",
}

export enum Status {
    Historical = "Historical",
    Partial = "Partial",
    Projected = "Projected",
    Completed = "Completed",
}

export class StoreEmailAttachment implements IStoreEmailAttachment {
    name!: string;
    file!: string | undefined;
    fileUrl!: string | undefined;

    constructor(data?: IStoreEmailAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.file = _data["file"];
            this.fileUrl = _data["fileUrl"];
        }
    }

    static fromJS(data: any): StoreEmailAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new StoreEmailAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["file"] = this.file;
        data["fileUrl"] = this.fileUrl;
        return data;
    }
}

export interface IStoreEmailAttachment {
    name: string;
    file: string | undefined;
    fileUrl: string | undefined;
}

export class StoreEmailInput implements IStoreEmailInput {
    to!: string[];
    contactId!: number | undefined;
    contactXref!: string | undefined;
    xref!: string | undefined;
    parentEmailXref!: string | undefined;
    fromEmailAddress!: string | undefined;
    fromDisplayName!: string | undefined;
    subject!: string | undefined;
    isInbound!: boolean;
    messageDate!: moment.Moment | undefined;
    saveAttachmentsToDocuments!: boolean;
    attachments!: StoreEmailAttachment[] | undefined;
    replyTo!: string[] | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string;

    constructor(data?: IStoreEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.to = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["to"])) {
                this.to = [] as any;
                for (let item of _data["to"])
                    this.to!.push(item);
            }
            this.contactId = _data["contactId"];
            this.contactXref = _data["contactXref"];
            this.xref = _data["xref"];
            this.parentEmailXref = _data["parentEmailXref"];
            this.fromEmailAddress = _data["fromEmailAddress"];
            this.fromDisplayName = _data["fromDisplayName"];
            this.subject = _data["subject"];
            this.isInbound = _data["isInbound"];
            this.messageDate = _data["messageDate"] ? moment(_data["messageDate"].toString()) : <any>undefined;
            this.saveAttachmentsToDocuments = _data["saveAttachmentsToDocuments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(StoreEmailAttachment.fromJS(item));
            }
            if (Array.isArray(_data["replyTo"])) {
                this.replyTo = [] as any;
                for (let item of _data["replyTo"])
                    this.replyTo!.push(item);
            }
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): StoreEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new StoreEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.to)) {
            data["to"] = [];
            for (let item of this.to)
                data["to"].push(item);
        }
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["xref"] = this.xref;
        data["parentEmailXref"] = this.parentEmailXref;
        data["fromEmailAddress"] = this.fromEmailAddress;
        data["fromDisplayName"] = this.fromDisplayName;
        data["subject"] = this.subject;
        data["isInbound"] = this.isInbound;
        data["messageDate"] = this.messageDate ? this.messageDate.toISOString() : <any>undefined;
        data["saveAttachmentsToDocuments"] = this.saveAttachmentsToDocuments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.replyTo)) {
            data["replyTo"] = [];
            for (let item of this.replyTo)
                data["replyTo"].push(item);
        }
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        return data;
    }
}

export interface IStoreEmailInput {
    to: string[];
    contactId: number | undefined;
    contactXref: string | undefined;
    xref: string | undefined;
    parentEmailXref: string | undefined;
    fromEmailAddress: string | undefined;
    fromDisplayName: string | undefined;
    subject: string | undefined;
    isInbound: boolean;
    messageDate: moment.Moment | undefined;
    saveAttachmentsToDocuments: boolean;
    attachments: StoreEmailAttachment[] | undefined;
    replyTo: string[] | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string;
}

export class StripeSettings implements IStripeSettings {
    apiKey!: string | undefined;
    webhookSingingSecret!: string | undefined;

    constructor(data?: IStripeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.webhookSingingSecret = _data["webhookSingingSecret"];
        }
    }

    static fromJS(data: any): StripeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new StripeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["webhookSingingSecret"] = this.webhookSingingSecret;
        return data;
    }
}

export interface IStripeSettings {
    apiKey: string | undefined;
    webhookSingingSecret: string | undefined;
}

export class SubmitAnswerDto implements ISubmitAnswerDto {
    xref!: string | undefined;
    sortOrder!: number | undefined;
    text!: string | undefined;

    constructor(data?: ISubmitAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.xref = _data["xref"];
            this.sortOrder = _data["sortOrder"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): SubmitAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xref"] = this.xref;
        data["sortOrder"] = this.sortOrder;
        data["text"] = this.text;
        return data;
    }
}

export interface ISubmitAnswerDto {
    xref: string | undefined;
    sortOrder: number | undefined;
    text: string | undefined;
}

export class SubmitApplicationInput implements ISubmitApplicationInput {
    campaignId!: number | undefined;
    systemType!: OfferProviderType;
    personalInformation!: PersonalInformation;
    debtInformation!: DebtInformation;
    loanInformation!: LoanInformation;
    employmentInformation!: EmploymentInformation;
    bankInformation!: BankInformation;
    legalInformation!: LegalInformation;

    constructor(data?: ISubmitApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personalInformation = new PersonalInformation();
            this.debtInformation = new DebtInformation();
            this.loanInformation = new LoanInformation();
            this.employmentInformation = new EmploymentInformation();
            this.bankInformation = new BankInformation();
            this.legalInformation = new LegalInformation();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.campaignId = _data["campaignId"];
            this.systemType = _data["systemType"];
            this.personalInformation = _data["personalInformation"] ? PersonalInformation.fromJS(_data["personalInformation"]) : new PersonalInformation();
            this.debtInformation = _data["debtInformation"] ? DebtInformation.fromJS(_data["debtInformation"]) : new DebtInformation();
            this.loanInformation = _data["loanInformation"] ? LoanInformation.fromJS(_data["loanInformation"]) : new LoanInformation();
            this.employmentInformation = _data["employmentInformation"] ? EmploymentInformation.fromJS(_data["employmentInformation"]) : new EmploymentInformation();
            this.bankInformation = _data["bankInformation"] ? BankInformation.fromJS(_data["bankInformation"]) : new BankInformation();
            this.legalInformation = _data["legalInformation"] ? LegalInformation.fromJS(_data["legalInformation"]) : new LegalInformation();
        }
    }

    static fromJS(data: any): SubmitApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["systemType"] = this.systemType;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISubmitApplicationInput {
    campaignId: number | undefined;
    systemType: OfferProviderType;
    personalInformation: PersonalInformation;
    debtInformation: DebtInformation;
    loanInformation: LoanInformation;
    employmentInformation: EmploymentInformation;
    bankInformation: BankInformation;
    legalInformation: LegalInformation;
}

export class SubmitApplicationOutput implements ISubmitApplicationOutput {
    status!: string | undefined;
    redirectUrl!: string | undefined;
    applicationId!: string | undefined;

    constructor(data?: ISubmitApplicationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.redirectUrl = _data["redirectUrl"];
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): SubmitApplicationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitApplicationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        data["applicationId"] = this.applicationId;
        return data;
    }
}

export interface ISubmitApplicationOutput {
    status: string | undefined;
    redirectUrl: string | undefined;
    applicationId: string | undefined;
}

export class SubmitClientRequestInput implements ISubmitClientRequestInput {
    tenancyName!: string;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    zip!: string | undefined;
    customContactInfo!: CustomFieldsInput | undefined;
    customRequestInfo!: CustomFieldsInput | undefined;
    leadRequestXref!: string | undefined;
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    phoneExt!: string | undefined;
    comments!: string | undefined;
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    isHelpNeeded!: boolean;

    constructor(data?: ISubmitClientRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.zip = _data["zip"];
            this.customContactInfo = _data["customContactInfo"] ? CustomFieldsInput.fromJS(_data["customContactInfo"]) : <any>undefined;
            this.customRequestInfo = _data["customRequestInfo"] ? CustomFieldsInput.fromJS(_data["customRequestInfo"]) : <any>undefined;
            this.leadRequestXref = _data["leadRequestXref"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.phoneExt = _data["phoneExt"];
            this.comments = _data["comments"];
            this.sourceCode = _data["sourceCode"];
            this.channelCode = _data["channelCode"];
            this.affiliateCode = _data["affiliateCode"];
            this.isHelpNeeded = _data["isHelpNeeded"];
        }
    }

    static fromJS(data: any): SubmitClientRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitClientRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["zip"] = this.zip;
        data["customContactInfo"] = this.customContactInfo ? this.customContactInfo.toJSON() : <any>undefined;
        data["customRequestInfo"] = this.customRequestInfo ? this.customRequestInfo.toJSON() : <any>undefined;
        data["leadRequestXref"] = this.leadRequestXref;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["isHelpNeeded"] = this.isHelpNeeded;
        return data;
    }
}

export interface ISubmitClientRequestInput {
    tenancyName: string;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    zip: string | undefined;
    customContactInfo: CustomFieldsInput | undefined;
    customRequestInfo: CustomFieldsInput | undefined;
    leadRequestXref: string | undefined;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    phoneExt: string | undefined;
    comments: string | undefined;
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    isHelpNeeded: boolean;
}

export class SubmitFreeTrialRequestInput implements ISubmitFreeTrialRequestInput {
    contactGroupId!: string | undefined;
    email!: string;
    tag!: string | undefined;

    constructor(data?: ISubmitFreeTrialRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactGroupId = _data["contactGroupId"];
            this.email = _data["email"];
            this.tag = _data["tag"];
        }
    }

    static fromJS(data: any): SubmitFreeTrialRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitFreeTrialRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactGroupId"] = this.contactGroupId;
        data["email"] = this.email;
        data["tag"] = this.tag;
        return data;
    }
}

export interface ISubmitFreeTrialRequestInput {
    contactGroupId: string | undefined;
    email: string;
    tag: string | undefined;
}

export class SubmitMemberInfoResultDto implements ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired!: boolean;

    constructor(data?: ISubmitMemberInfoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentAuthorizationRequired = _data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SubmitMemberInfoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitMemberInfoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data;
    }
}

export interface ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired: boolean;
}

export class SubmitQuestionAndAnswersDto implements ISubmitQuestionAndAnswersDto {
    question!: SubmitQuestionDto | undefined;
    answers!: SubmitAnswerDto[] | undefined;

    constructor(data?: ISubmitQuestionAndAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.question = _data["question"] ? SubmitQuestionDto.fromJS(_data["question"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(SubmitAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuestionAndAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionAndAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitQuestionAndAnswersDto {
    question: SubmitQuestionDto | undefined;
    answers: SubmitAnswerDto[] | undefined;
}

export class SubmitQuestionDto implements ISubmitQuestionDto {
    xref!: string | undefined;
    type!: QuestionType;
    text!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ISubmitQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.xref = _data["xref"];
            this.type = _data["type"];
            this.text = _data["text"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): SubmitQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xref"] = this.xref;
        data["type"] = this.type;
        data["text"] = this.text;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ISubmitQuestionDto {
    xref: string | undefined;
    type: QuestionType;
    text: string | undefined;
    sortOrder: number | undefined;
}

export class SubmitQuestionnaireDto implements ISubmitQuestionnaireDto {
    xref!: string | undefined;
    name!: string | undefined;

    constructor(data?: ISubmitQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.xref = _data["xref"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SubmitQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xref"] = this.xref;
        data["name"] = this.name;
        return data;
    }
}

export interface ISubmitQuestionnaireDto {
    xref: string | undefined;
    name: string | undefined;
}

export class SubmitQuestionsAndAnswersDto implements ISubmitQuestionsAndAnswersDto {
    questionnaire!: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers!: SubmitQuestionAndAnswersDto[] | undefined;

    constructor(data?: ISubmitQuestionsAndAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionnaire = _data["questionnaire"] ? SubmitQuestionnaireDto.fromJS(_data["questionnaire"]) : <any>undefined;
            if (Array.isArray(_data["questionsAndAnswers"])) {
                this.questionsAndAnswers = [] as any;
                for (let item of _data["questionsAndAnswers"])
                    this.questionsAndAnswers!.push(SubmitQuestionAndAnswersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuestionsAndAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionsAndAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        if (Array.isArray(this.questionsAndAnswers)) {
            data["questionsAndAnswers"] = [];
            for (let item of this.questionsAndAnswers)
                data["questionsAndAnswers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitQuestionsAndAnswersDto {
    questionnaire: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers: SubmitQuestionAndAnswersDto[] | undefined;
}

export class SubmitQuestionsAndAnswersDtoWithoutCheck implements ISubmitQuestionsAndAnswersDtoWithoutCheck {
    questionnaire!: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers!: SubmitQuestionAndAnswersDto[] | undefined;

    constructor(data?: ISubmitQuestionsAndAnswersDtoWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionnaire = _data["questionnaire"] ? SubmitQuestionnaireDto.fromJS(_data["questionnaire"]) : <any>undefined;
            if (Array.isArray(_data["questionsAndAnswers"])) {
                this.questionsAndAnswers = [] as any;
                for (let item of _data["questionsAndAnswers"])
                    this.questionsAndAnswers!.push(SubmitQuestionAndAnswersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuestionsAndAnswersDtoWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionsAndAnswersDtoWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        if (Array.isArray(this.questionsAndAnswers)) {
            data["questionsAndAnswers"] = [];
            for (let item of this.questionsAndAnswers)
                data["questionsAndAnswers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitQuestionsAndAnswersDtoWithoutCheck {
    questionnaire: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers: SubmitQuestionAndAnswersDto[] | undefined;
}

export class SubmitRequestInput implements ISubmitRequestInput {
    systemType!: OfferProviderType;
    campaignId!: number;
    xref!: string;
    redirectUrl!: string | undefined;
    clickId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    countryCode!: string | undefined;
    zipCode!: string | undefined;
    monthsAtAddress!: number | undefined;
    doB!: moment.Moment | undefined;
    creditScore!: CreditScoreRating | undefined;

    constructor(data?: ISubmitRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemType = _data["systemType"];
            this.campaignId = _data["campaignId"];
            this.xref = _data["xref"];
            this.redirectUrl = _data["redirectUrl"];
            this.clickId = _data["clickId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.stateCode = _data["stateCode"];
            this.countryCode = _data["countryCode"];
            this.zipCode = _data["zipCode"];
            this.monthsAtAddress = _data["monthsAtAddress"];
            this.doB = _data["doB"] ? moment(_data["doB"].toString()) : <any>undefined;
            this.creditScore = _data["creditScore"];
        }
    }

    static fromJS(data: any): SubmitRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["campaignId"] = this.campaignId;
        data["xref"] = this.xref;
        data["redirectUrl"] = this.redirectUrl;
        data["clickId"] = this.clickId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        data["zipCode"] = this.zipCode;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["creditScore"] = this.creditScore;
        return data;
    }
}

export interface ISubmitRequestInput {
    systemType: OfferProviderType;
    campaignId: number;
    xref: string;
    redirectUrl: string | undefined;
    clickId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    countryCode: string | undefined;
    zipCode: string | undefined;
    monthsAtAddress: number | undefined;
    doB: moment.Moment | undefined;
    creditScore: CreditScoreRating | undefined;
}

export class SubmitRequestOutput implements ISubmitRequestOutput {
    status!: string | undefined;
    redirectUrl!: string | undefined;
    applicationId!: string | undefined;

    constructor(data?: ISubmitRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.redirectUrl = _data["redirectUrl"];
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): SubmitRequestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        data["applicationId"] = this.applicationId;
        return data;
    }
}

export interface ISubmitRequestOutput {
    status: string | undefined;
    redirectUrl: string | undefined;
    applicationId: string | undefined;
}

export class SubmitTenancyRequestInput implements ISubmitTenancyRequestInput {
    companyName!: string | undefined;
    products!: TenantProductInfo[] | undefined;
    website!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    stage!: string | undefined;
    tag!: string | undefined;
    leadRequestXref!: string | undefined;
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    phoneExt!: string | undefined;
    comments!: string | undefined;
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    isHelpNeeded!: boolean;

    constructor(data?: ISubmitTenancyRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(TenantProductInfo.fromJS(item));
            }
            this.website = _data["website"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.stage = _data["stage"];
            this.tag = _data["tag"];
            this.leadRequestXref = _data["leadRequestXref"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.phoneExt = _data["phoneExt"];
            this.comments = _data["comments"];
            this.sourceCode = _data["sourceCode"];
            this.channelCode = _data["channelCode"];
            this.affiliateCode = _data["affiliateCode"];
            this.isHelpNeeded = _data["isHelpNeeded"];
        }
    }

    static fromJS(data: any): SubmitTenancyRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTenancyRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["website"] = this.website;
        data["city"] = this.city;
        data["state"] = this.state;
        data["stage"] = this.stage;
        data["tag"] = this.tag;
        data["leadRequestXref"] = this.leadRequestXref;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["isHelpNeeded"] = this.isHelpNeeded;
        return data;
    }
}

export interface ISubmitTenancyRequestInput {
    companyName: string | undefined;
    products: TenantProductInfo[] | undefined;
    website: string | undefined;
    city: string | undefined;
    state: string | undefined;
    stage: string | undefined;
    tag: string | undefined;
    leadRequestXref: string | undefined;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    phoneExt: string | undefined;
    comments: string | undefined;
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    isHelpNeeded: boolean;
}

export class SubmitTenancyRequestOutput implements ISubmitTenancyRequestOutput {
    leadRequestXref!: string | undefined;
    contactId!: number | undefined;

    constructor(data?: ISubmitTenancyRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadRequestXref = _data["leadRequestXref"];
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): SubmitTenancyRequestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTenancyRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface ISubmitTenancyRequestOutput {
    leadRequestXref: string | undefined;
    contactId: number | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    packageName!: string | undefined;
    moduleId!: string | undefined;
    moduleName!: string | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFree = _data["isFree"];
            this.packageName = _data["packageName"];
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["packageName"] = this.packageName;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    packageName: string | undefined;
    moduleId: string | undefined;
    moduleName: string | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class SubscribeForEventInput implements ISubscribeForEventInput {
    eventName!: string;
    targetUrl!: string;

    constructor(data?: ISubscribeForEventInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventName = _data["eventName"];
            this.targetUrl = _data["targetUrl"];
        }
    }

    static fromJS(data: any): SubscribeForEventInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribeForEventInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventName"] = this.eventName;
        data["targetUrl"] = this.targetUrl;
        return data;
    }
}

export interface ISubscribeForEventInput {
    eventName: string;
    targetUrl: string;
}

export class SubscribeForEventOutput implements ISubscribeForEventOutput {
    id!: number;

    constructor(data?: ISubscribeForEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscribeForEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribeForEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscribeForEventOutput {
    id: number;
}

export class SubscriberDailyStatsReportInfo implements ISubscriberDailyStatsReportInfo {
    date!: moment.Moment;
    leadCount!: number | undefined;
    clientCount!: number | undefined;
    bankConnectCount!: number | undefined;
    bankConnectAmount!: number | undefined;
    bankBeyondCount!: number | undefined;
    bankBeyondAmount!: number | undefined;
    starterKitCount!: number | undefined;
    starterKitAmount!: number | undefined;
    totalCount!: number | undefined;
    readonly totalAmount!: number | undefined;

    constructor(data?: ISubscriberDailyStatsReportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.leadCount = _data["leadCount"];
            this.clientCount = _data["clientCount"];
            this.bankConnectCount = _data["bankConnectCount"];
            this.bankConnectAmount = _data["bankConnectAmount"];
            this.bankBeyondCount = _data["bankBeyondCount"];
            this.bankBeyondAmount = _data["bankBeyondAmount"];
            this.starterKitCount = _data["starterKitCount"];
            this.starterKitAmount = _data["starterKitAmount"];
            this.totalCount = _data["totalCount"];
            (<any>this).totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): SubscriberDailyStatsReportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriberDailyStatsReportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["leadCount"] = this.leadCount;
        data["clientCount"] = this.clientCount;
        data["bankConnectCount"] = this.bankConnectCount;
        data["bankConnectAmount"] = this.bankConnectAmount;
        data["bankBeyondCount"] = this.bankBeyondCount;
        data["bankBeyondAmount"] = this.bankBeyondAmount;
        data["starterKitCount"] = this.starterKitCount;
        data["starterKitAmount"] = this.starterKitAmount;
        data["totalCount"] = this.totalCount;
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

export interface ISubscriberDailyStatsReportInfo {
    date: moment.Moment;
    leadCount: number | undefined;
    clientCount: number | undefined;
    bankConnectCount: number | undefined;
    bankConnectAmount: number | undefined;
    bankBeyondCount: number | undefined;
    bankBeyondAmount: number | undefined;
    starterKitCount: number | undefined;
    starterKitAmount: number | undefined;
    totalCount: number | undefined;
    totalAmount: number | undefined;
}

export class SubscriptionInput implements ISubscriptionInput {
    code!: string;
    name!: string;
    level!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: ISubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): SubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface ISubscriptionInput {
    code: string;
    name: string;
    level: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    amount: number | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    id!: number;
    invoiceId!: number | undefined;
    invoiceDate!: moment.Moment | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;
    type!: SubscriptionPaymentType;
    seqNo!: number;
    status!: SubscriptionPaymentStatus;
    fee!: number;
    paymentProvider!: string | undefined;
    paymentId!: string | undefined;
    paymentDate!: moment.Moment;
    authorizationCode!: string | undefined;
    uniqueId!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.seqNo = _data["seqNo"];
            this.status = _data["status"];
            this.fee = _data["fee"];
            this.paymentProvider = _data["paymentProvider"];
            this.paymentId = _data["paymentId"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.authorizationCode = _data["authorizationCode"];
            this.uniqueId = _data["uniqueId"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["seqNo"] = this.seqNo;
        data["status"] = this.status;
        data["fee"] = this.fee;
        data["paymentProvider"] = this.paymentProvider;
        data["paymentId"] = this.paymentId;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["authorizationCode"] = this.authorizationCode;
        data["uniqueId"] = this.uniqueId;
        return data;
    }
}

export interface ISubscriptionPaymentDto {
    id: number;
    invoiceId: number | undefined;
    invoiceDate: moment.Moment | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    type: SubscriptionPaymentType;
    seqNo: number;
    status: SubscriptionPaymentStatus;
    fee: number;
    paymentProvider: string | undefined;
    paymentId: string | undefined;
    paymentDate: moment.Moment;
    authorizationCode: string | undefined;
    uniqueId: number;
}

export enum SubscriptionPaymentStatus {
    Pending = "Pending",
    Approved = "Approved",
    Declined = "Declined",
    Active = "Active",
}

export enum SubscriptionPaymentType {
    OriginalPayment = "OriginalPayment",
    Installment = "Installment",
    Refund = "Refund",
    Chargeback = "Chargeback",
    RecurringBilling = "RecurringBilling",
}

export class SubscriptionServiceDto implements ISubscriptionServiceDto {
    id!: number;
    systemType!: string | undefined;
    serviceCode!: string | undefined;
    serviceName!: string | undefined;
    levelCode!: string | undefined;
    levelName!: string | undefined;

    constructor(data?: ISubscriptionServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.systemType = _data["systemType"];
            this.serviceCode = _data["serviceCode"];
            this.serviceName = _data["serviceName"];
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
        }
    }

    static fromJS(data: any): SubscriptionServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemType"] = this.systemType;
        data["serviceCode"] = this.serviceCode;
        data["serviceName"] = this.serviceName;
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        return data;
    }
}

export interface ISubscriptionServiceDto {
    id: number;
    systemType: string | undefined;
    serviceCode: string | undefined;
    serviceName: string | undefined;
    levelCode: string | undefined;
    levelName: string | undefined;
}

export class SubscriptionShortInfoOutput implements ISubscriptionShortInfoOutput {
    serviceType!: string | undefined;
    serviceTypeId!: string | undefined;
    serviceName!: string | undefined;
    serviceId!: string | undefined;
    endDate!: moment.Moment | undefined;
    gracePeriodDayCount!: number;
    hasRecurringBilling!: boolean;
    finalEndDate!: moment.Moment | undefined;

    constructor(data?: ISubscriptionShortInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceType = _data["serviceType"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.serviceName = _data["serviceName"];
            this.serviceId = _data["serviceId"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.gracePeriodDayCount = _data["gracePeriodDayCount"];
            this.hasRecurringBilling = _data["hasRecurringBilling"];
            this.finalEndDate = _data["finalEndDate"] ? moment(_data["finalEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionShortInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionShortInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceType"] = this.serviceType;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceName"] = this.serviceName;
        data["serviceId"] = this.serviceId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["gracePeriodDayCount"] = this.gracePeriodDayCount;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["finalEndDate"] = this.finalEndDate ? this.finalEndDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISubscriptionShortInfoOutput {
    serviceType: string | undefined;
    serviceTypeId: string | undefined;
    serviceName: string | undefined;
    serviceId: string | undefined;
    endDate: moment.Moment | undefined;
    gracePeriodDayCount: number;
    hasRecurringBilling: boolean;
    finalEndDate: moment.Moment | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class SyncAccountBankDto implements ISyncAccountBankDto {
    syncAccountId!: number | undefined;
    bankId!: number;
    name!: string | undefined;
    readonly balance!: number | undefined;
    lastSyncDate!: moment.Moment | undefined;
    lastGoodSyncDate!: moment.Moment | undefined;
    refreshAllowedSinceDate!: moment.Moment | undefined;
    bankAccounts!: BankAccountDto[] | undefined;
    syncAccountStatus!: SyncProgressStatus;
    syncRef!: string | undefined;
    syncTypeId!: string | undefined;
    autoSyncTime!: string | undefined;

    constructor(data?: ISyncAccountBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.syncAccountId = _data["syncAccountId"];
            this.bankId = _data["bankId"];
            this.name = _data["name"];
            (<any>this).balance = _data["balance"];
            this.lastSyncDate = _data["lastSyncDate"] ? moment(_data["lastSyncDate"].toString()) : <any>undefined;
            this.lastGoodSyncDate = _data["lastGoodSyncDate"] ? moment(_data["lastGoodSyncDate"].toString()) : <any>undefined;
            this.refreshAllowedSinceDate = _data["refreshAllowedSinceDate"] ? moment(_data["refreshAllowedSinceDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["bankAccounts"])) {
                this.bankAccounts = [] as any;
                for (let item of _data["bankAccounts"])
                    this.bankAccounts!.push(BankAccountDto.fromJS(item));
            }
            this.syncAccountStatus = _data["syncAccountStatus"];
            this.syncRef = _data["syncRef"];
            this.syncTypeId = _data["syncTypeId"];
            this.autoSyncTime = _data["autoSyncTime"];
        }
    }

    static fromJS(data: any): SyncAccountBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAccountBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountId"] = this.syncAccountId;
        data["bankId"] = this.bankId;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["lastGoodSyncDate"] = this.lastGoodSyncDate ? this.lastGoodSyncDate.toISOString() : <any>undefined;
        data["refreshAllowedSinceDate"] = this.refreshAllowedSinceDate ? this.refreshAllowedSinceDate.toISOString() : <any>undefined;
        if (Array.isArray(this.bankAccounts)) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        data["syncAccountStatus"] = this.syncAccountStatus;
        data["syncRef"] = this.syncRef;
        data["syncTypeId"] = this.syncTypeId;
        data["autoSyncTime"] = this.autoSyncTime;
        return data;
    }
}

export interface ISyncAccountBankDto {
    syncAccountId: number | undefined;
    bankId: number;
    name: string | undefined;
    balance: number | undefined;
    lastSyncDate: moment.Moment | undefined;
    lastGoodSyncDate: moment.Moment | undefined;
    refreshAllowedSinceDate: moment.Moment | undefined;
    bankAccounts: BankAccountDto[] | undefined;
    syncAccountStatus: SyncProgressStatus;
    syncRef: string | undefined;
    syncTypeId: string | undefined;
    autoSyncTime: string | undefined;
}

export class SyncAccountDto implements ISyncAccountDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: ISyncAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SyncAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISyncAccountDto {
    id: number;
    name: string | undefined;
}

export class SyncAllAccountsOutput implements ISyncAllAccountsOutput {
    syncInProgressAccountsCount!: number;
    failedSyncAccountsCount!: number;

    constructor(data?: ISyncAllAccountsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.syncInProgressAccountsCount = _data["syncInProgressAccountsCount"];
            this.failedSyncAccountsCount = _data["failedSyncAccountsCount"];
        }
    }

    static fromJS(data: any): SyncAllAccountsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAllAccountsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncInProgressAccountsCount"] = this.syncInProgressAccountsCount;
        data["failedSyncAccountsCount"] = this.failedSyncAccountsCount;
        return data;
    }
}

export interface ISyncAllAccountsOutput {
    syncInProgressAccountsCount: number;
    failedSyncAccountsCount: number;
}

export class SyncDto implements ISyncDto {
    syncAccountId!: number;

    constructor(data?: ISyncDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.syncAccountId = _data["syncAccountId"];
        }
    }

    static fromJS(data: any): SyncDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountId"] = this.syncAccountId;
        return data;
    }
}

export interface ISyncDto {
    syncAccountId: number;
}

export class SyncProgressDto implements ISyncProgressDto {
    accountId!: number;
    accountName!: string | undefined;
    syncStatusMessage!: string | undefined;
    progressPercent!: number;
    syncStatus!: SyncProgressStatus;
    lastSyncDate!: moment.Moment | undefined;
    bankAccounts!: BankAccountProgress[] | undefined;

    constructor(data?: ISyncProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.syncStatusMessage = _data["syncStatusMessage"];
            this.progressPercent = _data["progressPercent"];
            this.syncStatus = _data["syncStatus"];
            this.lastSyncDate = _data["lastSyncDate"] ? moment(_data["lastSyncDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["bankAccounts"])) {
                this.bankAccounts = [] as any;
                for (let item of _data["bankAccounts"])
                    this.bankAccounts!.push(BankAccountProgress.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["syncStatusMessage"] = this.syncStatusMessage;
        data["progressPercent"] = this.progressPercent;
        data["syncStatus"] = this.syncStatus;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        if (Array.isArray(this.bankAccounts)) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISyncProgressDto {
    accountId: number;
    accountName: string | undefined;
    syncStatusMessage: string | undefined;
    progressPercent: number;
    syncStatus: SyncProgressStatus;
    lastSyncDate: moment.Moment | undefined;
    bankAccounts: BankAccountProgress[] | undefined;
}

export class SyncProgressOutput implements ISyncProgressOutput {
    lastSyncDate!: moment.Moment | undefined;
    totalProgress!: SyncProgressDto | undefined;
    accountProgresses!: SyncProgressDto[] | undefined;

    constructor(data?: ISyncProgressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastSyncDate = _data["lastSyncDate"] ? moment(_data["lastSyncDate"].toString()) : <any>undefined;
            this.totalProgress = _data["totalProgress"] ? SyncProgressDto.fromJS(_data["totalProgress"]) : <any>undefined;
            if (Array.isArray(_data["accountProgresses"])) {
                this.accountProgresses = [] as any;
                for (let item of _data["accountProgresses"])
                    this.accountProgresses!.push(SyncProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncProgressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SyncProgressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["totalProgress"] = this.totalProgress ? this.totalProgress.toJSON() : <any>undefined;
        if (Array.isArray(this.accountProgresses)) {
            data["accountProgresses"] = [];
            for (let item of this.accountProgresses)
                data["accountProgresses"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISyncProgressOutput {
    lastSyncDate: moment.Moment | undefined;
    totalProgress: SyncProgressDto | undefined;
    accountProgresses: SyncProgressDto[] | undefined;
}

export enum SyncProgressStatus {
    InProgress = "InProgress",
    ActionRequired = "ActionRequired",
    SyncPending = "SyncPending",
    Unavailable = "Unavailable",
    Completed = "Completed",
    Failed = "Failed",
}

export class SystemTypeDto implements ISystemTypeDto {
    code!: string | undefined;

    constructor(data?: ISystemTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): SystemTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface ISystemTypeDto {
    code: string | undefined;
}

export class TagContactsInput implements ITagContactsInput {
    contactIds!: number[] | undefined;
    tags!: ContactTagInput[] | undefined;

    constructor(data?: ITagContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ContactTagInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new TagContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITagContactsInput {
    contactIds: number[] | undefined;
    tags: ContactTagInput[] | undefined;
}

export enum TargetAudience {
    Consumer = "Consumer",
    Business = "Business",
    Students = "Students",
}

export class TargetContactMergeOptions implements ITargetContactMergeOptions {
    emailIdsToRemove!: number[] | undefined;
    phoneIdsToRemove!: number[] | undefined;
    addressIdsToRemove!: number[] | undefined;

    constructor(data?: ITargetContactMergeOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["emailIdsToRemove"])) {
                this.emailIdsToRemove = [] as any;
                for (let item of _data["emailIdsToRemove"])
                    this.emailIdsToRemove!.push(item);
            }
            if (Array.isArray(_data["phoneIdsToRemove"])) {
                this.phoneIdsToRemove = [] as any;
                for (let item of _data["phoneIdsToRemove"])
                    this.phoneIdsToRemove!.push(item);
            }
            if (Array.isArray(_data["addressIdsToRemove"])) {
                this.addressIdsToRemove = [] as any;
                for (let item of _data["addressIdsToRemove"])
                    this.addressIdsToRemove!.push(item);
            }
        }
    }

    static fromJS(data: any): TargetContactMergeOptions {
        data = typeof data === 'object' ? data : {};
        let result = new TargetContactMergeOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.emailIdsToRemove)) {
            data["emailIdsToRemove"] = [];
            for (let item of this.emailIdsToRemove)
                data["emailIdsToRemove"].push(item);
        }
        if (Array.isArray(this.phoneIdsToRemove)) {
            data["phoneIdsToRemove"] = [];
            for (let item of this.phoneIdsToRemove)
                data["phoneIdsToRemove"].push(item);
        }
        if (Array.isArray(this.addressIdsToRemove)) {
            data["addressIdsToRemove"] = [];
            for (let item of this.addressIdsToRemove)
                data["addressIdsToRemove"].push(item);
        }
        return data;
    }
}

export interface ITargetContactMergeOptions {
    emailIdsToRemove: number[] | undefined;
    phoneIdsToRemove: number[] | undefined;
    addressIdsToRemove: number[] | undefined;
}

export class TenantAppHostOutput implements ITenantAppHostOutput {
    appHostName!: string | undefined;

    constructor(data?: ITenantAppHostOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appHostName = _data["appHostName"];
        }
    }

    static fromJS(data: any): TenantAppHostOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppHostOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appHostName"] = this.appHostName;
        return data;
    }
}

export interface ITenantAppHostOutput {
    appHostName: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class TenantCustomizationInfoDto implements ITenantCustomizationInfoDto {
    siteTitle!: string | undefined;
    faviconBaseUrl!: string | undefined;
    favicons!: FaviconDto[] | undefined;

    constructor(data?: ITenantCustomizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteTitle = _data["siteTitle"];
            this.faviconBaseUrl = _data["faviconBaseUrl"];
            if (Array.isArray(_data["favicons"])) {
                this.favicons = [] as any;
                for (let item of _data["favicons"])
                    this.favicons!.push(FaviconDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantCustomizationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCustomizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteTitle"] = this.siteTitle;
        data["faviconBaseUrl"] = this.faviconBaseUrl;
        if (Array.isArray(this.favicons)) {
            data["favicons"] = [];
            for (let item of this.favicons)
                data["favicons"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITenantCustomizationInfoDto {
    siteTitle: string | undefined;
    faviconBaseUrl: string | undefined;
    favicons: FaviconDto[] | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    id!: number;
    copyFiles!: boolean;
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    crmConnectionString!: string | undefined;
    memberDbConnectionString!: string | undefined;
    cfoConnectionString!: string | undefined;
    azureConnectionString!: string | undefined;
    editions!: TenantEditEditionDto[] | undefined;
    isActive!: boolean;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.copyFiles = _data["copyFiles"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.crmConnectionString = _data["crmConnectionString"];
            this.memberDbConnectionString = _data["memberDbConnectionString"];
            this.cfoConnectionString = _data["cfoConnectionString"];
            this.azureConnectionString = _data["azureConnectionString"];
            if (Array.isArray(_data["editions"])) {
                this.editions = [] as any;
                for (let item of _data["editions"])
                    this.editions!.push(TenantEditEditionDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["copyFiles"] = this.copyFiles;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["azureConnectionString"] = this.azureConnectionString;
        if (Array.isArray(this.editions)) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITenantEditDto {
    id: number;
    copyFiles: boolean;
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    crmConnectionString: string | undefined;
    memberDbConnectionString: string | undefined;
    cfoConnectionString: string | undefined;
    azureConnectionString: string | undefined;
    editions: TenantEditEditionDto[] | undefined;
    isActive: boolean;
}

export class TenantEditEditionDto implements ITenantEditEditionDto {
    editionId!: number;
    maxUserCount!: number | undefined;
    trialDayCount!: number | undefined;

    constructor(data?: ITenantEditEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.maxUserCount = _data["maxUserCount"];
            this.trialDayCount = _data["trialDayCount"];
        }
    }

    static fromJS(data: any): TenantEditEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["trialDayCount"] = this.trialDayCount;
        return data;
    }
}

export interface ITenantEditEditionDto {
    editionId: number;
    maxUserCount: number | undefined;
    trialDayCount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export enum TenantHostType {
    PlatformApp = "PlatformApp",
    MemberPortal = "MemberPortal",
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    hasOwnDatabase!: boolean;
    isActive!: boolean;
    creationTime!: moment.Moment;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.hasOwnDatabase = _data["hasOwnDatabase"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["hasOwnDatabase"] = this.hasOwnDatabase;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    hasOwnDatabase: boolean;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    isWhiteLabel!: boolean;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    loginCustomCssId!: string | undefined;
    portalCustomCssId!: string | undefined;
    customToSDocumentId!: string | undefined;
    customPrivacyPolicyDocumentId!: string | undefined;
    customLayoutType!: LayoutType | undefined;
    creationTime!: moment.Moment;
    paymentPeriodType!: PaymentPeriodType;
    creationTimeString!: string | undefined;
    tenantCustomizations!: TenantCustomizationInfoDto | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isWhiteLabel = _data["isWhiteLabel"];
            this.logoId = _data["logoId"];
            this.logoFileType = _data["logoFileType"];
            this.customCssId = _data["customCssId"];
            this.loginCustomCssId = _data["loginCustomCssId"];
            this.portalCustomCssId = _data["portalCustomCssId"];
            this.customToSDocumentId = _data["customToSDocumentId"];
            this.customPrivacyPolicyDocumentId = _data["customPrivacyPolicyDocumentId"];
            this.customLayoutType = _data["customLayoutType"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.creationTimeString = _data["creationTimeString"];
            this.tenantCustomizations = _data["tenantCustomizations"] ? TenantCustomizationInfoDto.fromJS(_data["tenantCustomizations"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isWhiteLabel"] = this.isWhiteLabel;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["loginCustomCssId"] = this.loginCustomCssId;
        data["portalCustomCssId"] = this.portalCustomCssId;
        data["customToSDocumentId"] = this.customToSDocumentId;
        data["customPrivacyPolicyDocumentId"] = this.customPrivacyPolicyDocumentId;
        data["customLayoutType"] = this.customLayoutType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["creationTimeString"] = this.creationTimeString;
        data["tenantCustomizations"] = this.tenantCustomizations ? this.tenantCustomizations.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    isWhiteLabel: boolean;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    loginCustomCssId: string | undefined;
    portalCustomCssId: string | undefined;
    customToSDocumentId: string | undefined;
    customPrivacyPolicyDocumentId: string | undefined;
    customLayoutType: LayoutType | undefined;
    creationTime: moment.Moment;
    paymentPeriodType: PaymentPeriodType;
    creationTimeString: string | undefined;
    tenantCustomizations: TenantCustomizationInfoDto | undefined;
    id: number;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class TenantModel implements ITenantModel {
    id!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ITenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantModel {
        data = typeof data === 'object' ? data : {};
        let result = new TenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }
}

export interface ITenantModel {
    id: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TenantNotificationDto implements ITenantNotificationDto {
    id!: string;
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityTypeName!: string | undefined;
    entityId!: string | undefined;
    severity!: NotificationSeverity;
    creationTime!: moment.Moment;

    constructor(data?: ITenantNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITenantNotificationDto {
    id: string;
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityTypeName: string | undefined;
    entityId: string | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantProductInfo implements ITenantProductInfo {
    productId!: number;
    paymentPeriodType!: PaymentPeriodType;
    quantity!: number;

    constructor(data?: ITenantProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): TenantProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ITenantProductInfo {
    productId: number;
    paymentPeriodType: PaymentPeriodType;
    quantity: number;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto | undefined;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto | undefined;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto | undefined;
}

export class TenantSslBindingInfo implements ITenantSslBindingInfo {
    id!: number;
    hostName!: string | undefined;
    hostType!: TenantHostType;
    isActive!: boolean;
    sslCertificateId!: number | undefined;
    sslCertificateExpiration!: moment.Moment | undefined;
    sslCertificateThumbprint!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: ITenantSslBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hostName = _data["hostName"];
            this.hostType = _data["hostType"];
            this.isActive = _data["isActive"];
            this.sslCertificateId = _data["sslCertificateId"];
            this.sslCertificateExpiration = _data["sslCertificateExpiration"] ? moment(_data["sslCertificateExpiration"].toString()) : <any>undefined;
            this.sslCertificateThumbprint = _data["sslCertificateThumbprint"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): TenantSslBindingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSslBindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostName"] = this.hostName;
        data["hostType"] = this.hostType;
        data["isActive"] = this.isActive;
        data["sslCertificateId"] = this.sslCertificateId;
        data["sslCertificateExpiration"] = this.sslCertificateExpiration ? this.sslCertificateExpiration.toISOString() : <any>undefined;
        data["sslCertificateThumbprint"] = this.sslCertificateThumbprint;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface ITenantSslBindingInfo {
    id: number;
    hostName: string | undefined;
    hostType: TenantHostType;
    isActive: boolean;
    sslCertificateId: number | undefined;
    sslCertificateExpiration: moment.Moment | undefined;
    sslCertificateThumbprint: string | undefined;
    organizationUnitId: number | undefined;
}

export class TenantSslCertificateInfo implements ITenantSslCertificateInfo {
    id!: number;
    hostNames!: string | undefined;
    expiration!: moment.Moment | undefined;
    thumbprint!: string | undefined;

    constructor(data?: ITenantSslCertificateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hostNames = _data["hostNames"];
            this.expiration = _data["expiration"] ? moment(_data["expiration"].toString()) : <any>undefined;
            this.thumbprint = _data["thumbprint"];
        }
    }

    static fromJS(data: any): TenantSslCertificateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSslCertificateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostNames"] = this.hostNames;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["thumbprint"] = this.thumbprint;
        return data;
    }
}

export interface ITenantSslCertificateInfo {
    id: number;
    hostNames: string | undefined;
    expiration: moment.Moment | undefined;
    thumbprint: string | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto | undefined;
    customWelcomeEmailTemplates!: CustomWelcomeTemplate[] | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
            if (Array.isArray(_data["customWelcomeEmailTemplates"])) {
                this.customWelcomeEmailTemplates = [] as any;
                for (let item of _data["customWelcomeEmailTemplates"])
                    this.customWelcomeEmailTemplates!.push(CustomWelcomeTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        if (Array.isArray(this.customWelcomeEmailTemplates)) {
            data["customWelcomeEmailTemplates"] = [];
            for (let item of this.customWelcomeEmailTemplates)
                data["customWelcomeEmailTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto | undefined;
    customWelcomeEmailTemplates: CustomWelcomeTemplate[] | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    readonly desktopFixedHeader!: boolean;
    readonly mobileFixedHeader!: boolean;
    minimizeDesktopHeaderType!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).desktopFixedHeader = _data["desktopFixedHeader"];
            (<any>this).mobileFixedHeader = _data["mobileFixedHeader"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        return data;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    minimizeDesktopHeaderType: string | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;
    darkMode!: boolean;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layoutType = _data["layoutType"];
            this.darkMode = _data["darkMode"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["darkMode"] = this.darkMode;
        return data;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
    darkMode: boolean;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;
    enableSecondary!: boolean;
    hoverableAside!: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
            this.enableSecondary = _data["enableSecondary"];
            this.hoverableAside = _data["hoverableAside"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        data["enableSecondary"] = this.enableSecondary;
        data["hoverableAside"] = this.hoverableAside;
        return data;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
    enableSecondary: boolean;
    hoverableAside: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto | undefined;
    header!: ThemeHeaderSettingsDto | undefined;
    subHeader!: ThemeSubHeaderSettingsDto | undefined;
    menu!: ThemeMenuSettingsDto | undefined;
    footer!: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    subHeader: ThemeSubHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;
    subheaderSize!: number;
    titleStyle!: string | undefined;
    containerStyle!: string | undefined;
    subContainerStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
            this.subheaderSize = _data["subheaderSize"];
            this.titleStyle = _data["titleStyle"];
            this.containerStyle = _data["containerStyle"];
            this.subContainerStyle = _data["subContainerStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        data["subheaderSize"] = this.subheaderSize;
        data["titleStyle"] = this.titleStyle;
        data["containerStyle"] = this.containerStyle;
        data["subContainerStyle"] = this.subContainerStyle;
        return data;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
    subheaderSize: number;
    titleStyle: string | undefined;
    containerStyle: string | undefined;
    subContainerStyle: string | undefined;
}

export enum Tier2CommissionSource {
    CommissionAmount = "CommissionAmount",
    CommissionableValue = "CommissionableValue",
}

export enum TimeOfDay {
    Morning = "Morning",
    Afternoon = "Afternoon",
    Evening = "Evening",
    Anytime = "Anytime",
    Night = "Night",
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data;
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class TrackingInfo implements ITrackingInfo {
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    userAgent!: string | undefined;
    clientIp!: string | undefined;

    constructor(data?: ITrackingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceCode = _data["sourceCode"];
            this.channelCode = _data["channelCode"];
            this.affiliateCode = _data["affiliateCode"];
            this.refererUrl = _data["refererUrl"];
            this.entryUrl = _data["entryUrl"];
            this.userAgent = _data["userAgent"];
            this.clientIp = _data["clientIp"];
        }
    }

    static fromJS(data: any): TrackingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["userAgent"] = this.userAgent;
        data["clientIp"] = this.clientIp;
        return data;
    }
}

export interface ITrackingInfo {
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    userAgent: string | undefined;
    clientIp: string | undefined;
}

export class TrackingInformation implements ITrackingInformation {
    campaignId!: number | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    applicationDate!: moment.Moment | undefined;
    subId!: string | undefined;
    affiliateId!: number | undefined;
    vertical!: DIOSVertical | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    clickId!: string | undefined;

    constructor(data?: ITrackingInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.campaignId = _data["campaignId"];
            this.applicantId = _data["applicantId"];
            this.applicationId = _data["applicationId"];
            this.applicationDate = _data["applicationDate"] ? moment(_data["applicationDate"].toString()) : <any>undefined;
            this.subId = _data["subId"];
            this.affiliateId = _data["affiliateId"];
            this.vertical = _data["vertical"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
            this.siteId = _data["siteId"];
            this.siteUrl = _data["siteUrl"];
            this.clickId = _data["clickId"];
        }
    }

    static fromJS(data: any): TrackingInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["applicationDate"] = this.applicationDate ? this.applicationDate.toISOString() : <any>undefined;
        data["subId"] = this.subId;
        data["affiliateId"] = this.affiliateId;
        data["vertical"] = this.vertical;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["clickId"] = this.clickId;
        return data;
    }
}

export interface ITrackingInformation {
    campaignId: number | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    applicationDate: moment.Moment | undefined;
    subId: string | undefined;
    affiliateId: number | undefined;
    vertical: DIOSVertical | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    clickId: string | undefined;
}

export class TransactionAttributeDto implements ITransactionAttributeDto {
    readonly typeId!: string | undefined;
    readonly value!: string | undefined;

    constructor(data?: ITransactionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeId = _data["typeId"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): TransactionAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data;
    }
}

export interface ITransactionAttributeDto {
    typeId: string | undefined;
    value: string | undefined;
}

export class TransactionAttributeTypeDto implements ITransactionAttributeTypeDto {
    name!: string | undefined;

    constructor(data?: ITransactionAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TransactionAttributeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ITransactionAttributeTypeDto {
    name: string | undefined;
}

export class TransactionCommentDto implements ITransactionCommentDto {
    commentId!: number;
    text!: string | undefined;

    constructor(data?: ITransactionCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): TransactionCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["text"] = this.text;
        return data;
    }
}

export interface ITransactionCommentDto {
    commentId: number;
    text: string | undefined;
}

export class TransactionCommonDetailsDto implements ITransactionCommonDetailsDto {
    readonly amountFormat!: AmountFormat | undefined;
    readonly bankId!: number | undefined;
    readonly bankAccountId!: number | undefined;
    readonly standardDescriptor!: string | undefined;
    transactionCategoryId!: string | undefined;
    transactionTypeId!: string | undefined;
    readonly descriptionPhrases!: string[] | undefined;
    readonly attributes!: TransactionAttributeDto[] | undefined;
    readonly sourceTransactionsAreMatchingExistingRules!: boolean;

    constructor(data?: ITransactionCommonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).amountFormat = _data["amountFormat"];
            (<any>this).bankId = _data["bankId"];
            (<any>this).bankAccountId = _data["bankAccountId"];
            (<any>this).standardDescriptor = _data["standardDescriptor"];
            this.transactionCategoryId = _data["transactionCategoryId"];
            this.transactionTypeId = _data["transactionTypeId"];
            if (Array.isArray(_data["descriptionPhrases"])) {
                (<any>this).descriptionPhrases = [] as any;
                for (let item of _data["descriptionPhrases"])
                    (<any>this).descriptionPhrases!.push(item);
            }
            if (Array.isArray(_data["attributes"])) {
                (<any>this).attributes = [] as any;
                for (let item of _data["attributes"])
                    (<any>this).attributes!.push(TransactionAttributeDto.fromJS(item));
            }
            (<any>this).sourceTransactionsAreMatchingExistingRules = _data["sourceTransactionsAreMatchingExistingRules"];
        }
    }

    static fromJS(data: any): TransactionCommonDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCommonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountFormat"] = this.amountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["transactionTypeId"] = this.transactionTypeId;
        if (Array.isArray(this.descriptionPhrases)) {
            data["descriptionPhrases"] = [];
            for (let item of this.descriptionPhrases)
                data["descriptionPhrases"].push(item);
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["sourceTransactionsAreMatchingExistingRules"] = this.sourceTransactionsAreMatchingExistingRules;
        return data;
    }
}

export interface ITransactionCommonDetailsDto {
    amountFormat: AmountFormat | undefined;
    bankId: number | undefined;
    bankAccountId: number | undefined;
    standardDescriptor: string | undefined;
    transactionCategoryId: string | undefined;
    transactionTypeId: string | undefined;
    descriptionPhrases: string[] | undefined;
    attributes: TransactionAttributeDto[] | undefined;
    sourceTransactionsAreMatchingExistingRules: boolean;
}

export class TransactionDetailsDto implements ITransactionDetailsDto {
    id!: number;
    bankAccountBankName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankAccountName!: string | undefined;
    date!: moment.Moment;
    currency!: string | undefined;
    amount!: number;
    description!: string | undefined;
    cashFlowTypeId!: string | undefined;
    transactionStatus!: TransactionStatus;
    cashflowCategoryId!: number | undefined;
    cashflowCategory!: string | undefined;
    cashflowSubCategoryId!: number | undefined;
    cashflowSubCategory!: string | undefined;
    accountingTypeId!: number | undefined;
    accountingType!: string | undefined;
    transactionDescriptor!: string | undefined;
    isDescriptorCalculated!: boolean;
    counterpartyName!: string | undefined;
    comments!: TransactionCommentDto[] | undefined;
    attributes!: TransactionAttributeDto[] | undefined;

    constructor(data?: ITransactionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankAccountBankName = _data["bankAccountBankName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankAccountName = _data["bankAccountName"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.cashFlowTypeId = _data["cashFlowTypeId"];
            this.transactionStatus = _data["transactionStatus"];
            this.cashflowCategoryId = _data["cashflowCategoryId"];
            this.cashflowCategory = _data["cashflowCategory"];
            this.cashflowSubCategoryId = _data["cashflowSubCategoryId"];
            this.cashflowSubCategory = _data["cashflowSubCategory"];
            this.accountingTypeId = _data["accountingTypeId"];
            this.accountingType = _data["accountingType"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.isDescriptorCalculated = _data["isDescriptorCalculated"];
            this.counterpartyName = _data["counterpartyName"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(TransactionCommentDto.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(TransactionAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountBankName"] = this.bankAccountBankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankAccountName"] = this.bankAccountName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["transactionStatus"] = this.transactionStatus;
        data["cashflowCategoryId"] = this.cashflowCategoryId;
        data["cashflowCategory"] = this.cashflowCategory;
        data["cashflowSubCategoryId"] = this.cashflowSubCategoryId;
        data["cashflowSubCategory"] = this.cashflowSubCategory;
        data["accountingTypeId"] = this.accountingTypeId;
        data["accountingType"] = this.accountingType;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["isDescriptorCalculated"] = this.isDescriptorCalculated;
        data["counterpartyName"] = this.counterpartyName;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransactionDetailsDto {
    id: number;
    bankAccountBankName: string | undefined;
    bankAccountNumber: string | undefined;
    bankAccountName: string | undefined;
    date: moment.Moment;
    currency: string | undefined;
    amount: number;
    description: string | undefined;
    cashFlowTypeId: string | undefined;
    transactionStatus: TransactionStatus;
    cashflowCategoryId: number | undefined;
    cashflowCategory: string | undefined;
    cashflowSubCategoryId: number | undefined;
    cashflowSubCategory: string | undefined;
    accountingTypeId: number | undefined;
    accountingType: string | undefined;
    transactionDescriptor: string | undefined;
    isDescriptorCalculated: boolean;
    counterpartyName: string | undefined;
    comments: TransactionCommentDto[] | undefined;
    attributes: TransactionAttributeDto[] | undefined;
}

export class TransactionStatsDto implements ITransactionStatsDto {
    adjustmentType!: AdjustmentType | undefined;
    cashflowTypeId!: string | undefined;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    accountId!: number;
    currencyId!: string | undefined;
    date!: moment.Moment;
    amount!: number;
    count!: number;
    comment!: string | undefined;
    forecastId!: number | undefined;

    constructor(data?: ITransactionStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adjustmentType = _data["adjustmentType"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            this.accountId = _data["accountId"];
            this.currencyId = _data["currencyId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.count = _data["count"];
            this.comment = _data["comment"];
            this.forecastId = _data["forecastId"];
        }
    }

    static fromJS(data: any): TransactionStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjustmentType"] = this.adjustmentType;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        data["currencyId"] = this.currencyId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["count"] = this.count;
        data["comment"] = this.comment;
        data["forecastId"] = this.forecastId;
        return data;
    }
}

export interface ITransactionStatsDto {
    adjustmentType: AdjustmentType | undefined;
    cashflowTypeId: string | undefined;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    accountId: number;
    currencyId: string | undefined;
    date: moment.Moment;
    amount: number;
    count: number;
    comment: string | undefined;
    forecastId: number | undefined;
}

export enum TransactionStatus {
    Pending = "Pending",
    Settled = "Settled",
}

export class TransactionTypeDto implements ITransactionTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    categories!: string[] | undefined;

    constructor(data?: ITransactionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
        }
    }

    static fromJS(data: any): TransactionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data;
    }
}

export interface ITransactionTypeDto {
    id: string | undefined;
    name: string | undefined;
    categories: string[] | undefined;
}

export class TransactionTypesAndCategoriesDto implements ITransactionTypesAndCategoriesDto {
    types!: TransactionTypeDto[] | undefined;
    categories!: FilterElementDtoOfString[] | undefined;

    constructor(data?: ITransactionTypesAndCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(TransactionTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(FilterElementDtoOfString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionTypesAndCategoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypesAndCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransactionTypesAndCategoriesDto {
    types: TransactionTypeDto[] | undefined;
    categories: FilterElementDtoOfString[] | undefined;
}

export class TransitionActivityDto implements ITransitionActivityDto {
    id!: number;
    stageId!: number;
    sortOrder!: number | undefined;

    constructor(data?: ITransitionActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stageId = _data["stageId"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): TransitionActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ITransitionActivityDto {
    id: number;
    stageId: number;
    sortOrder: number | undefined;
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: ITwitterExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerKey = _data["consumerKey"];
            this.consumerSecret = _data["consumerSecret"];
        }
    }

    static fromJS(data: any): TwitterExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data;
    }
}

export interface ITwitterExternalLoginProviderSettings {
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class TwitterGetAccessTokenResponse implements ITwitterGetAccessTokenResponse {
    accessToken!: string | undefined;
    accessTokenSecret!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ITwitterGetAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenSecret = _data["accessTokenSecret"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): TwitterGetAccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetAccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenSecret"] = this.accessTokenSecret;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ITwitterGetAccessTokenResponse {
    accessToken: string | undefined;
    accessTokenSecret: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
}

export class TwitterGetRequestTokenResponse implements ITwitterGetRequestTokenResponse {
    token!: string | undefined;
    secret!: string | undefined;
    confirmed!: boolean;
    redirectUrl!: string | undefined;

    constructor(data?: ITwitterGetRequestTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.secret = _data["secret"];
            this.confirmed = _data["confirmed"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): TwitterGetRequestTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetRequestTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["secret"] = this.secret;
        data["confirmed"] = this.confirmed;
        data["redirectUrl"] = this.redirectUrl;
        return data;
    }
}

export interface ITwitterGetRequestTokenResponse {
    token: string | undefined;
    secret: string | undefined;
    confirmed: boolean;
    redirectUrl: string | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class TypeDto implements ITypeDto {
    name!: string | undefined;

    constructor(data?: ITypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ITypeDto {
    name: string | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto | undefined;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UnpinNoteInput implements IUnpinNoteInput {
    contactId!: number;
    noteId!: number;

    constructor(data?: IUnpinNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.noteId = _data["noteId"];
        }
    }

    static fromJS(data: any): UnpinNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnpinNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["noteId"] = this.noteId;
        return data;
    }
}

export interface IUnpinNoteInput {
    contactId: number;
    noteId: number;
}

export class UntagContactsInput implements IUntagContactsInput {
    contactIds!: number[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUntagContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UntagContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UntagContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data;
    }
}

export interface IUntagContactsInput {
    contactIds: number[] | undefined;
    tagIds: number[] | undefined;
}

export class UpdateAccountingTypeInput implements IUpdateAccountingTypeInput {
    id!: number;
    name!: string;
    cashflowTypeId!: string | undefined;

    constructor(data?: IUpdateAccountingTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cashflowTypeId = _data["cashflowTypeId"];
        }
    }

    static fromJS(data: any): UpdateAccountingTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountingTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cashflowTypeId"] = this.cashflowTypeId;
        return data;
    }
}

export interface IUpdateAccountingTypeInput {
    id: number;
    name: string;
    cashflowTypeId: string | undefined;
}

export class UpdateActivityDto implements IUpdateActivityDto {
    id!: number;
    type!: ActivityType;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IUpdateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["assignedUserIds"])) {
                this.assignedUserIds = [] as any;
                for (let item of _data["assignedUserIds"])
                    this.assignedUserIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.allDay = _data["allDay"];
            this.stageId = _data["stageId"];
            this.leadId = _data["leadId"];
            this.contactId = _data["contactId"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.assignedUserIds)) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateActivityDto {
    id: number;
    type: ActivityType;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class UpdateAffiliateContactInput implements IUpdateAffiliateContactInput {
    contactId!: number;
    affiliateContactId!: number | undefined;
    updatePendingCommissions!: boolean;

    constructor(data?: IUpdateAffiliateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.affiliateContactId = _data["affiliateContactId"];
            this.updatePendingCommissions = _data["updatePendingCommissions"];
        }
    }

    static fromJS(data: any): UpdateAffiliateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAffiliateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["affiliateContactId"] = this.affiliateContactId;
        data["updatePendingCommissions"] = this.updatePendingCommissions;
        return data;
    }
}

export interface IUpdateAffiliateContactInput {
    contactId: number;
    affiliateContactId: number | undefined;
    updatePendingCommissions: boolean;
}

export class UpdateAffiliateIsAdvisorInput implements IUpdateAffiliateIsAdvisorInput {
    contactId!: number;
    isAdvisor!: boolean;

    constructor(data?: IUpdateAffiliateIsAdvisorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.isAdvisor = _data["isAdvisor"];
        }
    }

    static fromJS(data: any): UpdateAffiliateIsAdvisorInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAffiliateIsAdvisorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["isAdvisor"] = this.isAdvisor;
        return data;
    }
}

export interface IUpdateAffiliateIsAdvisorInput {
    contactId: number;
    isAdvisor: boolean;
}

export class UpdateAffiliateLinkInput implements IUpdateAffiliateLinkInput {
    id!: number;
    category!: string | undefined;
    companyName!: string | undefined;
    phoneNumber!: string | undefined;
    url!: string;
    suggestedCopy!: string | undefined;

    constructor(data?: IUpdateAffiliateLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"];
            this.companyName = _data["companyName"];
            this.phoneNumber = _data["phoneNumber"];
            this.url = _data["url"];
            this.suggestedCopy = _data["suggestedCopy"];
        }
    }

    static fromJS(data: any): UpdateAffiliateLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAffiliateLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category;
        data["companyName"] = this.companyName;
        data["phoneNumber"] = this.phoneNumber;
        data["url"] = this.url;
        data["suggestedCopy"] = this.suggestedCopy;
        return data;
    }
}

export interface IUpdateAffiliateLinkInput {
    id: number;
    category: string | undefined;
    companyName: string | undefined;
    phoneNumber: string | undefined;
    url: string;
    suggestedCopy: string | undefined;
}

export class UpdateApiKeyInput implements IUpdateApiKeyInput {
    id!: number;
    name!: string;
    expirationDate!: moment.Moment | undefined;
    userId!: number | undefined;
    paths!: string | undefined;

    constructor(data?: IUpdateApiKeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.paths = _data["paths"];
        }
    }

    static fromJS(data: any): UpdateApiKeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApiKeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["paths"] = this.paths;
        return data;
    }
}

export interface IUpdateApiKeyInput {
    id: number;
    name: string;
    expirationDate: moment.Moment | undefined;
    userId: number | undefined;
    paths: string | undefined;
}

export class UpdateBankAccountDto implements IUpdateBankAccountDto {
    id!: number;
    name!: string | undefined;
    typeId!: string | undefined;
    isActive!: boolean;
    businessEntityId!: number | undefined;

    constructor(data?: IUpdateBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.isActive = _data["isActive"];
            this.businessEntityId = _data["businessEntityId"];
        }
    }

    static fromJS(data: any): UpdateBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["isActive"] = this.isActive;
        data["businessEntityId"] = this.businessEntityId;
        return data;
    }
}

export interface IUpdateBankAccountDto {
    id: number;
    name: string | undefined;
    typeId: string | undefined;
    isActive: boolean;
    businessEntityId: number | undefined;
}

export class UpdateBankCodeUserSettingsInput implements IUpdateBankCodeUserSettingsInput {
    isSetupWizardEnabled!: boolean;
    isWelcomeVideoWatched!: boolean;

    constructor(data?: IUpdateBankCodeUserSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSetupWizardEnabled = _data["isSetupWizardEnabled"];
            this.isWelcomeVideoWatched = _data["isWelcomeVideoWatched"];
        }
    }

    static fromJS(data: any): UpdateBankCodeUserSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankCodeUserSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSetupWizardEnabled"] = this.isSetupWizardEnabled;
        data["isWelcomeVideoWatched"] = this.isWelcomeVideoWatched;
        return data;
    }
}

export interface IUpdateBankCodeUserSettingsInput {
    isSetupWizardEnabled: boolean;
    isWelcomeVideoWatched: boolean;
}

export class UpdateBusinessEntityDto implements IUpdateBusinessEntityDto {
    id!: number;
    status!: BusinessEntityStatus | undefined;
    name!: string;
    parentId!: number | undefined;
    industry!: string | undefined;
    type!: BusinessEntityType | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    neighborhood!: string | undefined;
    streetAddress!: string | undefined;
    isDefault!: boolean;

    constructor(data?: IUpdateBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.industry = _data["industry"];
            this.type = _data["type"];
            this.taxNumber = _data["taxNumber"];
            this.dateOpened = _data["dateOpened"] ? moment(_data["dateOpened"].toString()) : <any>undefined;
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.alternativeEmail = _data["alternativeEmail"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.neighborhood = _data["neighborhood"];
            this.streetAddress = _data["streetAddress"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateBusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["neighborhood"] = this.neighborhood;
        data["streetAddress"] = this.streetAddress;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IUpdateBusinessEntityDto {
    id: number;
    status: BusinessEntityStatus | undefined;
    name: string;
    parentId: number | undefined;
    industry: string | undefined;
    type: BusinessEntityType | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    neighborhood: string | undefined;
    streetAddress: string | undefined;
    isDefault: boolean;
}

export class UpdateCategoryInput implements IUpdateCategoryInput {
    id!: number;
    coAID!: string | undefined;
    name!: string;
    accountingTypeId!: number;
    parentId!: number | undefined;

    constructor(data?: IUpdateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coAID = _data["coAID"];
            this.name = _data["name"];
            this.accountingTypeId = _data["accountingTypeId"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IUpdateCategoryInput {
    id: number;
    coAID: string | undefined;
    name: string;
    accountingTypeId: number;
    parentId: number | undefined;
}

export class UpdateCategoryStatusInput implements IUpdateCategoryStatusInput {
    id!: number;
    isActive!: boolean;

    constructor(data?: IUpdateCategoryStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCategoryStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateCategoryStatusInput {
    id: number;
    isActive: boolean;
}

export class UpdateCommentInput implements IUpdateCommentInput {
    comment!: string;
    id!: number;

    constructor(data?: IUpdateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateCommentInput {
    comment: string;
    id: number;
}

export class UpdateCommissionableAmountInput implements IUpdateCommissionableAmountInput {
    commissionIds!: number[] | undefined;
    commissionableAmount!: number;

    constructor(data?: IUpdateCommissionableAmountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["commissionIds"])) {
                this.commissionIds = [] as any;
                for (let item of _data["commissionIds"])
                    this.commissionIds!.push(item);
            }
            this.commissionableAmount = _data["commissionableAmount"];
        }
    }

    static fromJS(data: any): UpdateCommissionableAmountInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommissionableAmountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.commissionIds)) {
            data["commissionIds"] = [];
            for (let item of this.commissionIds)
                data["commissionIds"].push(item);
        }
        data["commissionableAmount"] = this.commissionableAmount;
        return data;
    }
}

export interface IUpdateCommissionableAmountInput {
    commissionIds: number[] | undefined;
    commissionableAmount: number;
}

export class UpdateCommissionAffiliateInput implements IUpdateCommissionAffiliateInput {
    commissionIds!: number[] | undefined;
    affiliateContactId!: number;
    assignToBuyerContact!: boolean;
    reassignTier2Commissions!: boolean;

    constructor(data?: IUpdateCommissionAffiliateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["commissionIds"])) {
                this.commissionIds = [] as any;
                for (let item of _data["commissionIds"])
                    this.commissionIds!.push(item);
            }
            this.affiliateContactId = _data["affiliateContactId"];
            this.assignToBuyerContact = _data["assignToBuyerContact"];
            this.reassignTier2Commissions = _data["reassignTier2Commissions"];
        }
    }

    static fromJS(data: any): UpdateCommissionAffiliateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommissionAffiliateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.commissionIds)) {
            data["commissionIds"] = [];
            for (let item of this.commissionIds)
                data["commissionIds"].push(item);
        }
        data["affiliateContactId"] = this.affiliateContactId;
        data["assignToBuyerContact"] = this.assignToBuyerContact;
        data["reassignTier2Commissions"] = this.reassignTier2Commissions;
        return data;
    }
}

export interface IUpdateCommissionAffiliateInput {
    commissionIds: number[] | undefined;
    affiliateContactId: number;
    assignToBuyerContact: boolean;
    reassignTier2Commissions: boolean;
}

export class UpdateCommissionRateInput implements IUpdateCommissionRateInput {
    commissionIds!: number[] | undefined;
    commissionRate!: number;

    constructor(data?: IUpdateCommissionRateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["commissionIds"])) {
                this.commissionIds = [] as any;
                for (let item of _data["commissionIds"])
                    this.commissionIds!.push(item);
            }
            this.commissionRate = _data["commissionRate"];
        }
    }

    static fromJS(data: any): UpdateCommissionRateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommissionRateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.commissionIds)) {
            data["commissionIds"] = [];
            for (let item of this.commissionIds)
                data["commissionIds"].push(item);
        }
        data["commissionRate"] = this.commissionRate;
        return data;
    }
}

export interface IUpdateCommissionRateInput {
    commissionIds: number[] | undefined;
    commissionRate: number;
}

export class UpdateContactAddressInput implements IUpdateContactAddressInput {
    id!: number;
    contactId!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IUpdateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.usageTypeId = _data["usageTypeId"];
            this.ownershipTypeId = _data["ownershipTypeId"];
            this.streetAddress = _data["streetAddress"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.zip = _data["zip"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): UpdateContactAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IUpdateContactAddressInput {
    id: number;
    contactId: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    comment: string | undefined;
}

export class UpdateContactAffiliateCodeInput implements IUpdateContactAffiliateCodeInput {
    contactId!: number;
    affiliateCode!: string | undefined;

    constructor(data?: IUpdateContactAffiliateCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.affiliateCode = _data["affiliateCode"];
        }
    }

    static fromJS(data: any): UpdateContactAffiliateCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAffiliateCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["affiliateCode"] = this.affiliateCode;
        return data;
    }
}

export interface IUpdateContactAffiliateCodeInput {
    contactId: number;
    affiliateCode: string | undefined;
}

export class UpdateContactAffiliateRateInput implements IUpdateContactAffiliateRateInput {
    contactId!: number;
    affiliateRate!: number | undefined;
    updatePendingCommissions!: boolean;
    commissionTier!: CommissionTier;

    constructor(data?: IUpdateContactAffiliateRateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.affiliateRate = _data["affiliateRate"];
            this.updatePendingCommissions = _data["updatePendingCommissions"];
            this.commissionTier = _data["commissionTier"];
        }
    }

    static fromJS(data: any): UpdateContactAffiliateRateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAffiliateRateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["affiliateRate"] = this.affiliateRate;
        data["updatePendingCommissions"] = this.updatePendingCommissions;
        data["commissionTier"] = this.commissionTier;
        return data;
    }
}

export interface IUpdateContactAffiliateRateInput {
    contactId: number;
    affiliateRate: number | undefined;
    updatePendingCommissions: boolean;
    commissionTier: CommissionTier;
}

export class UpdateContactCustomFieldsInput implements IUpdateContactCustomFieldsInput {
    contactId!: number;
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;

    constructor(data?: IUpdateContactCustomFieldsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.customField1 = _data["customField1"];
            this.customField2 = _data["customField2"];
            this.customField3 = _data["customField3"];
            this.customField4 = _data["customField4"];
            this.customField5 = _data["customField5"];
        }
    }

    static fromJS(data: any): UpdateContactCustomFieldsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactCustomFieldsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        return data;
    }
}

export interface IUpdateContactCustomFieldsInput {
    contactId: number;
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
}

export class UpdateContactEmailInput implements IUpdateContactEmailInput {
    id!: number;
    contactId!: number;
    emailAddress!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IUpdateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface IUpdateContactEmailInput {
    id: number;
    contactId: number;
    emailAddress: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class UpdateContactLinkInput implements IUpdateContactLinkInput {
    id!: number;
    contactId!: number;
    isConfirmed!: boolean;
    isCompany!: boolean;
    url!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: IUpdateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.isConfirmed = _data["isConfirmed"];
            this.isCompany = _data["isCompany"];
            this.url = _data["url"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.comment = _data["comment"];
            this.linkTypeId = _data["linkTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["isConfirmed"] = this.isConfirmed;
        data["isCompany"] = this.isCompany;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data;
    }
}

export interface IUpdateContactLinkInput {
    id: number;
    contactId: number;
    isConfirmed: boolean;
    isCompany: boolean;
    url: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class UpdateContactListInput implements IUpdateContactListInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateContactListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateContactListInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateContactListInput {
    id: number;
    name: string;
}

export class UpdateContactListsInput implements IUpdateContactListsInput {
    contactId!: number;
    lists!: ContactListInput[] | undefined;

    constructor(data?: IUpdateContactListsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ContactListInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactListsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactListsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateContactListsInput {
    contactId: number;
    lists: ContactListInput[] | undefined;
}

export class UpdateContactPhoneInput implements IUpdateContactPhoneInput {
    id!: number;
    contactId!: number;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IUpdateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExtension = _data["phoneExtension"];
            this.isActive = _data["isActive"];
            this.isConfirmed = _data["isConfirmed"];
            this.comment = _data["comment"];
            this.usageTypeId = _data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactPhoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data;
    }
}

export interface IUpdateContactPhoneInput {
    id: number;
    contactId: number;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class UpdateContactStatusesInput implements IUpdateContactStatusesInput {
    contactIds!: number[];
    notifyUsers!: boolean;
    processLeads!: boolean;
    groupId!: string;
    isActive!: boolean;

    constructor(data?: IUpdateContactStatusesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
            this.notifyUsers = _data["notifyUsers"];
            this.processLeads = _data["processLeads"];
            this.groupId = _data["groupId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateContactStatusesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactStatusesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["notifyUsers"] = this.notifyUsers;
        data["processLeads"] = this.processLeads;
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateContactStatusesInput {
    contactIds: number[];
    notifyUsers: boolean;
    processLeads: boolean;
    groupId: string;
    isActive: boolean;
}

export class UpdateContactStatusInput implements IUpdateContactStatusInput {
    contactId!: number;
    notifyUser!: boolean;
    processLead!: boolean;
    groupId!: string;
    isActive!: boolean;

    constructor(data?: IUpdateContactStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.notifyUser = _data["notifyUser"];
            this.processLead = _data["processLead"];
            this.groupId = _data["groupId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateContactStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["notifyUser"] = this.notifyUser;
        data["processLead"] = this.processLead;
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateContactStatusInput {
    contactId: number;
    notifyUser: boolean;
    processLead: boolean;
    groupId: string;
    isActive: boolean;
}

export class UpdateContactTagInput implements IUpdateContactTagInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateContactTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateContactTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateContactTagInput {
    id: number;
    name: string;
}

export class UpdateContactTagsInput implements IUpdateContactTagsInput {
    contactId!: number;
    tags!: ContactTagInput[] | undefined;

    constructor(data?: IUpdateContactTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ContactTagInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateContactTagsInput {
    contactId: number;
    tags: ContactTagInput[] | undefined;
}

export class UpdateContactXrefInput implements IUpdateContactXrefInput {
    contactId!: number;
    xref!: string | undefined;

    constructor(data?: IUpdateContactXrefInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.xref = _data["xref"];
        }
    }

    static fromJS(data: any): UpdateContactXrefInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactXrefInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["xref"] = this.xref;
        return data;
    }
}

export interface IUpdateContactXrefInput {
    contactId: number;
    xref: string | undefined;
}

export class UpdateDocumentTypeInput implements IUpdateDocumentTypeInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateDocumentTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateDocumentTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateDocumentTypeInput {
    id: number;
    name: string;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class UpdateEmailTemplateRequest implements IUpdateEmailTemplateRequest {
    id!: number;
    name!: string;
    type!: EmailTemplateType;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    previewText!: string | undefined;
    body!: string;

    constructor(data?: IUpdateEmailTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.subject = _data["subject"];
            if (Array.isArray(_data["cc"])) {
                this.cc = [] as any;
                for (let item of _data["cc"])
                    this.cc!.push(item);
            }
            if (Array.isArray(_data["bcc"])) {
                this.bcc = [] as any;
                for (let item of _data["bcc"])
                    this.bcc!.push(item);
            }
            this.previewText = _data["previewText"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): UpdateEmailTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["subject"] = this.subject;
        if (Array.isArray(this.cc)) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (Array.isArray(this.bcc)) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["previewText"] = this.previewText;
        data["body"] = this.body;
        return data;
    }
}

export interface IUpdateEmailTemplateRequest {
    id: number;
    name: string;
    type: EmailTemplateType;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    previewText: string | undefined;
    body: string;
}

export class UpdateForecastInput implements IUpdateForecastInput {
    id!: number;
    date!: moment.Moment | undefined;
    amount!: number | undefined;
    bankAccountId!: number | undefined;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    description!: string | undefined;
    transactionDescriptor!: string | undefined;

    constructor(data?: IUpdateForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.bankAccountId = _data["bankAccountId"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.transactionDescriptor = _data["transactionDescriptor"];
        }
    }

    static fromJS(data: any): UpdateForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["transactionDescriptor"] = this.transactionDescriptor;
        return data;
    }
}

export interface IUpdateForecastInput {
    id: number;
    date: moment.Moment | undefined;
    amount: number | undefined;
    bankAccountId: number | undefined;
    cashflowTypeId: string;
    categoryId: number | undefined;
    description: string | undefined;
    transactionDescriptor: string | undefined;
}

export class UpdateForecastScheduleInput implements IUpdateForecastScheduleInput {
    id!: number;
    bankAccountId!: number;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    forecastModelIds!: number[];
    startDate!: moment.Moment;
    frequencyId!: string;
    currencyId!: string;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: IUpdateForecastScheduleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecastModelIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankAccountId = _data["bankAccountId"];
            this.cashflowTypeId = _data["cashflowTypeId"];
            this.categoryId = _data["categoryId"];
            this.transactionDescriptor = _data["transactionDescriptor"];
            if (Array.isArray(_data["forecastModelIds"])) {
                this.forecastModelIds = [] as any;
                for (let item of _data["forecastModelIds"])
                    this.forecastModelIds!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.currencyId = _data["currencyId"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = _data["calculationTypeId"];
            this.amount = _data["amount"];
            this.monthNumber = _data["monthNumber"];
            this.weekNumber = _data["weekNumber"];
            this.dayNumber = _data["dayNumber"];
            this.weekDayNumber = _data["weekDayNumber"];
        }
    }

    static fromJS(data: any): UpdateForecastScheduleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastScheduleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        if (Array.isArray(this.forecastModelIds)) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data;
    }
}

export interface IUpdateForecastScheduleInput {
    id: number;
    bankAccountId: number;
    cashflowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class UpdateForecastsInput implements IUpdateForecastsInput {
    forecasts!: UpdateForecastInput[];

    constructor(data?: IUpdateForecastsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecasts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["forecasts"])) {
                this.forecasts = [] as any;
                for (let item of _data["forecasts"])
                    this.forecasts!.push(UpdateForecastInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateForecastsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.forecasts)) {
            data["forecasts"] = [];
            for (let item of this.forecasts)
                data["forecasts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateForecastsInput {
    forecasts: UpdateForecastInput[];
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class UpdateGroupSortOrderInput implements IUpdateGroupSortOrderInput {
    id!: number;
    sortOrder!: number;

    constructor(data?: IUpdateGroupSortOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateGroupSortOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupSortOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateGroupSortOrderInput {
    id: number;
    sortOrder: number;
}

export class UpdateGroupSortOrderOutput implements IUpdateGroupSortOrderOutput {
    sortOrder!: number;

    constructor(data?: IUpdateGroupSortOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateGroupSortOrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupSortOrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateGroupSortOrderOutput {
    sortOrder: number;
}

export class UpdateInvoiceInput implements IUpdateInvoiceInput {
    id!: number;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment | undefined;
    grandTotal!: number;
    discountTotal!: number | undefined;
    shippingTotal!: number | undefined;
    taxTotal!: number | undefined;
    billingAddress!: InvoiceAddressInput | undefined;
    shippingAddress!: InvoiceAddressInput | undefined;
    description!: string | undefined;
    note!: string | undefined;
    lines!: UpdateInvoiceLineInput[] | undefined;
    bypassValidation!: boolean;

    constructor(data?: IUpdateInvoiceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.number = _data["number"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.grandTotal = _data["grandTotal"];
            this.discountTotal = _data["discountTotal"];
            this.shippingTotal = _data["shippingTotal"];
            this.taxTotal = _data["taxTotal"];
            this.billingAddress = _data["billingAddress"] ? InvoiceAddressInput.fromJS(_data["billingAddress"]) : <any>undefined;
            this.shippingAddress = _data["shippingAddress"] ? InvoiceAddressInput.fromJS(_data["shippingAddress"]) : <any>undefined;
            this.description = _data["description"];
            this.note = _data["note"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(UpdateInvoiceLineInput.fromJS(item));
            }
            this.bypassValidation = _data["bypassValidation"];
        }
    }

    static fromJS(data: any): UpdateInvoiceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["grandTotal"] = this.grandTotal;
        data["discountTotal"] = this.discountTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["taxTotal"] = this.taxTotal;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["bypassValidation"] = this.bypassValidation;
        return data;
    }
}

export interface IUpdateInvoiceInput {
    id: number;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment | undefined;
    grandTotal: number;
    discountTotal: number | undefined;
    shippingTotal: number | undefined;
    taxTotal: number | undefined;
    billingAddress: InvoiceAddressInput | undefined;
    shippingAddress: InvoiceAddressInput | undefined;
    description: string | undefined;
    note: string | undefined;
    lines: UpdateInvoiceLineInput[] | undefined;
    bypassValidation: boolean;
}

export class UpdateInvoiceLineInput implements IUpdateInvoiceLineInput {
    id!: number | undefined;
    quantity!: number;
    rate!: number;
    total!: number;
    commissionableAmount!: number | undefined;
    unitId!: ProductMeasurementUnit;
    productCode!: string | undefined;
    description!: string | undefined;
    sortOrder!: number;

    constructor(data?: IUpdateInvoiceLineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.total = _data["total"];
            this.commissionableAmount = _data["commissionableAmount"];
            this.unitId = _data["unitId"];
            this.productCode = _data["productCode"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateInvoiceLineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceLineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["total"] = this.total;
        data["commissionableAmount"] = this.commissionableAmount;
        data["unitId"] = this.unitId;
        data["productCode"] = this.productCode;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateInvoiceLineInput {
    id: number | undefined;
    quantity: number;
    rate: number;
    total: number;
    commissionableAmount: number | undefined;
    unitId: ProductMeasurementUnit;
    productCode: string | undefined;
    description: string | undefined;
    sortOrder: number;
}

export class UpdateInvoiceStatusInput implements IUpdateInvoiceStatusInput {
    id!: number;
    status!: InvoiceStatus;
    emailId!: number | undefined;

    constructor(data?: IUpdateInvoiceStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.emailId = _data["emailId"];
        }
    }

    static fromJS(data: any): UpdateInvoiceStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["emailId"] = this.emailId;
        return data;
    }
}

export interface IUpdateInvoiceStatusInput {
    id: number;
    status: InvoiceStatus;
    emailId: number | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class UpdateLeadDealInfoInput implements IUpdateLeadDealInfoInput {
    leadId!: number;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;

    constructor(data?: IUpdateLeadDealInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.dealAmount = _data["dealAmount"];
            this.installmentAmount = _data["installmentAmount"];
        }
    }

    static fromJS(data: any): UpdateLeadDealInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadDealInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        return data;
    }
}

export interface IUpdateLeadDealInfoInput {
    leadId: number;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
}

export class UpdateLeadInfoInput implements IUpdateLeadInfoInput {
    id!: number;
    sourceCode!: string | undefined;
    campaignCode!: string | undefined;
    affiliateCode!: string | undefined;
    channelCode!: string | undefined;
    dealAmount!: number | undefined;
    comments!: string | undefined;

    constructor(data?: IUpdateLeadInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceCode = _data["sourceCode"];
            this.campaignCode = _data["campaignCode"];
            this.affiliateCode = _data["affiliateCode"];
            this.channelCode = _data["channelCode"];
            this.dealAmount = _data["dealAmount"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): UpdateLeadInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceCode"] = this.sourceCode;
        data["campaignCode"] = this.campaignCode;
        data["affiliateCode"] = this.affiliateCode;
        data["channelCode"] = this.channelCode;
        data["dealAmount"] = this.dealAmount;
        data["comments"] = this.comments;
        return data;
    }
}

export interface IUpdateLeadInfoInput {
    id: number;
    sourceCode: string | undefined;
    campaignCode: string | undefined;
    affiliateCode: string | undefined;
    channelCode: string | undefined;
    dealAmount: number | undefined;
    comments: string | undefined;
}

export class UpdateLeadSourceContactInput implements IUpdateLeadSourceContactInput {
    leadId!: number;
    sourceContactId!: number | undefined;

    constructor(data?: IUpdateLeadSourceContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.sourceContactId = _data["sourceContactId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["sourceContactId"] = this.sourceContactId;
        return data;
    }
}

export interface IUpdateLeadSourceContactInput {
    leadId: number;
    sourceContactId: number | undefined;
}

export class UpdateLeadSourceContactOutput implements IUpdateLeadSourceContactOutput {
    newSourceOrganizationUnitId!: number | undefined;

    constructor(data?: IUpdateLeadSourceContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newSourceOrganizationUnitId = _data["newSourceOrganizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newSourceOrganizationUnitId"] = this.newSourceOrganizationUnitId;
        return data;
    }
}

export interface IUpdateLeadSourceContactOutput {
    newSourceOrganizationUnitId: number | undefined;
}

export class UpdateLeadSourceContactsInput implements IUpdateLeadSourceContactsInput {
    leadIds!: number[];
    sourceContactId!: number | undefined;
    applyCurrentAffiliateCode!: boolean;

    constructor(data?: IUpdateLeadSourceContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.leadIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["leadIds"])) {
                this.leadIds = [] as any;
                for (let item of _data["leadIds"])
                    this.leadIds!.push(item);
            }
            this.sourceContactId = _data["sourceContactId"];
            this.applyCurrentAffiliateCode = _data["applyCurrentAffiliateCode"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.leadIds)) {
            data["leadIds"] = [];
            for (let item of this.leadIds)
                data["leadIds"].push(item);
        }
        data["sourceContactId"] = this.sourceContactId;
        data["applyCurrentAffiliateCode"] = this.applyCurrentAffiliateCode;
        return data;
    }
}

export interface IUpdateLeadSourceContactsInput {
    leadIds: number[];
    sourceContactId: number | undefined;
    applyCurrentAffiliateCode: boolean;
}

export class UpdateLeadSourceOrganizationUnitInput implements IUpdateLeadSourceOrganizationUnitInput {
    leadId!: number;
    sourceOrganizationUnitId!: number;

    constructor(data?: IUpdateLeadSourceOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.sourceOrganizationUnitId = _data["sourceOrganizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        return data;
    }
}

export interface IUpdateLeadSourceOrganizationUnitInput {
    leadId: number;
    sourceOrganizationUnitId: number;
}

export class UpdateLeadSourceOrganizationUnitsInput implements IUpdateLeadSourceOrganizationUnitsInput {
    leadIds!: number[];
    sourceOrganizationUnitId!: number;

    constructor(data?: IUpdateLeadSourceOrganizationUnitsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.leadIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["leadIds"])) {
                this.leadIds = [] as any;
                for (let item of _data["leadIds"])
                    this.leadIds!.push(item);
            }
            this.sourceOrganizationUnitId = _data["sourceOrganizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceOrganizationUnitsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceOrganizationUnitsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.leadIds)) {
            data["leadIds"] = [];
            for (let item of this.leadIds)
                data["leadIds"].push(item);
        }
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        return data;
    }
}

export interface IUpdateLeadSourceOrganizationUnitsInput {
    leadIds: number[];
    sourceOrganizationUnitId: number;
}

export class UpdateLeadStageInput implements IUpdateLeadStageInput {
    leadId!: number;
    stageId!: number;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean;
    allowPipelineChange!: boolean;

    constructor(data?: IUpdateLeadStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.stageId = _data["stageId"];
            this.sortOrder = _data["sortOrder"];
            this.ignoreChecklist = _data["ignoreChecklist"];
            this.allowPipelineChange = _data["allowPipelineChange"];
        }
    }

    static fromJS(data: any): UpdateLeadStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        data["allowPipelineChange"] = this.allowPipelineChange;
        return data;
    }
}

export interface IUpdateLeadStageInput {
    leadId: number;
    stageId: number;
    sortOrder: number | undefined;
    ignoreChecklist: boolean;
    allowPipelineChange: boolean;
}

export class UpdateLeadStagePointInput implements IUpdateLeadStagePointInput {
    leadId!: number;
    pointId!: number;
    isDone!: boolean;

    constructor(data?: IUpdateLeadStagePointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leadId = _data["leadId"];
            this.pointId = _data["pointId"];
            this.isDone = _data["isDone"];
        }
    }

    static fromJS(data: any): UpdateLeadStagePointInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadStagePointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["pointId"] = this.pointId;
        data["isDone"] = this.isDone;
        return data;
    }
}

export interface IUpdateLeadStagePointInput {
    leadId: number;
    pointId: number;
    isDone: boolean;
}

export class UpdateLearningResourceGroupInput implements IUpdateLearningResourceGroupInput {
    id!: number;
    name!: string;
    htmlColor!: string | undefined;
    isActive!: boolean;

    constructor(data?: IUpdateLearningResourceGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.htmlColor = _data["htmlColor"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateLearningResourceGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLearningResourceGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["htmlColor"] = this.htmlColor;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateLearningResourceGroupInput {
    id: number;
    name: string;
    htmlColor: string | undefined;
    isActive: boolean;
}

export class UpdateLearningResourceInput implements IUpdateLearningResourceInput {
    id!: number;
    type!: LearningResourceType | undefined;
    name!: string;
    url!: string | undefined;
    fileName!: string | undefined;
    fileSize!: number | undefined;
    file!: string | undefined;
    isActive!: boolean;
    memberServiceAssignments!: MemberServiceAssignmentInput[] | undefined;

    constructor(data?: IUpdateLearningResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.file = _data["file"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["memberServiceAssignments"])) {
                this.memberServiceAssignments = [] as any;
                for (let item of _data["memberServiceAssignments"])
                    this.memberServiceAssignments!.push(MemberServiceAssignmentInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateLearningResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLearningResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["file"] = this.file;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.memberServiceAssignments)) {
            data["memberServiceAssignments"] = [];
            for (let item of this.memberServiceAssignments)
                data["memberServiceAssignments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateLearningResourceInput {
    id: number;
    type: LearningResourceType | undefined;
    name: string;
    url: string | undefined;
    fileName: string | undefined;
    fileSize: number | undefined;
    file: string | undefined;
    isActive: boolean;
    memberServiceAssignments: MemberServiceAssignmentInput[] | undefined;
}

export class UpdateLinkInput implements IUpdateLinkInput {
    id!: number;
    url!: string | undefined;
    isActive!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: IUpdateLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.comment = _data["comment"];
            this.linkTypeId = _data["linkTypeId"];
        }
    }

    static fromJS(data: any): UpdateLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data;
    }
}

export interface IUpdateLinkInput {
    id: number;
    url: string | undefined;
    isActive: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class UpdateLinksInput implements IUpdateLinksInput {
    createLinks!: CreateLinkInput[] | undefined;
    updateLinks!: UpdateLinkInput[] | undefined;
    deleteLinks!: number[] | undefined;

    constructor(data?: IUpdateLinksInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["createLinks"])) {
                this.createLinks = [] as any;
                for (let item of _data["createLinks"])
                    this.createLinks!.push(CreateLinkInput.fromJS(item));
            }
            if (Array.isArray(_data["updateLinks"])) {
                this.updateLinks = [] as any;
                for (let item of _data["updateLinks"])
                    this.updateLinks!.push(UpdateLinkInput.fromJS(item));
            }
            if (Array.isArray(_data["deleteLinks"])) {
                this.deleteLinks = [] as any;
                for (let item of _data["deleteLinks"])
                    this.deleteLinks!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateLinksInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLinksInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.createLinks)) {
            data["createLinks"] = [];
            for (let item of this.createLinks)
                data["createLinks"].push(item.toJSON());
        }
        if (Array.isArray(this.updateLinks)) {
            data["updateLinks"] = [];
            for (let item of this.updateLinks)
                data["updateLinks"].push(item.toJSON());
        }
        if (Array.isArray(this.deleteLinks)) {
            data["deleteLinks"] = [];
            for (let item of this.deleteLinks)
                data["deleteLinks"].push(item);
        }
        return data;
    }
}

export interface IUpdateLinksInput {
    createLinks: CreateLinkInput[] | undefined;
    updateLinks: UpdateLinkInput[] | undefined;
    deleteLinks: number[] | undefined;
}

export class UpdateMonthlyGoalInput implements IUpdateMonthlyGoalInput {
    monthlyGoal!: number | undefined;

    constructor(data?: IUpdateMonthlyGoalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monthlyGoal = _data["monthlyGoal"];
        }
    }

    static fromJS(data: any): UpdateMonthlyGoalInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMonthlyGoalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthlyGoal"] = this.monthlyGoal;
        return data;
    }
}

export interface IUpdateMonthlyGoalInput {
    monthlyGoal: number | undefined;
}

export class UpdateNoteInput implements IUpdateNoteInput {
    id!: number;
    contactId!: number;
    text!: string;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    leadId!: number | undefined;
    noteType!: NoteType;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;

    constructor(data?: IUpdateNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.text = _data["text"];
            this.contactPhoneId = _data["contactPhoneId"];
            this.orderId = _data["orderId"];
            this.leadId = _data["leadId"];
            this.noteType = _data["noteType"];
            this.followUpDateTime = _data["followUpDateTime"] ? moment(_data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = _data["addedByUserId"];
        }
    }

    static fromJS(data: any): UpdateNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["text"] = this.text;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["leadId"] = this.leadId;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        return data;
    }
}

export interface IUpdateNoteInput {
    id: number;
    contactId: number;
    text: string;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    leadId: number | undefined;
    noteType: NoteType;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class UpdateOrderAffiliateContactInput implements IUpdateOrderAffiliateContactInput {
    orderId!: number;
    affiliateContactId!: number;
    assignToBuyerContact!: boolean;

    constructor(data?: IUpdateOrderAffiliateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.affiliateContactId = _data["affiliateContactId"];
            this.assignToBuyerContact = _data["assignToBuyerContact"];
        }
    }

    static fromJS(data: any): UpdateOrderAffiliateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderAffiliateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["affiliateContactId"] = this.affiliateContactId;
        data["assignToBuyerContact"] = this.assignToBuyerContact;
        return data;
    }
}

export interface IUpdateOrderAffiliateContactInput {
    orderId: number;
    affiliateContactId: number;
    assignToBuyerContact: boolean;
}

export class UpdateOrderStageInfo implements IUpdateOrderStageInfo {
    orderId!: number;
    stageId!: number;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean;

    constructor(data?: IUpdateOrderStageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.stageId = _data["stageId"];
            this.sortOrder = _data["sortOrder"];
            this.ignoreChecklist = _data["ignoreChecklist"];
        }
    }

    static fromJS(data: any): UpdateOrderStageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        return data;
    }
}

export interface IUpdateOrderStageInfo {
    orderId: number;
    stageId: number;
    sortOrder: number | undefined;
    ignoreChecklist: boolean;
}

export class UpdateOrderStagePointInput implements IUpdateOrderStagePointInput {
    orderId!: number;
    pointId!: number;
    isDone!: boolean;

    constructor(data?: IUpdateOrderStagePointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.pointId = _data["pointId"];
            this.isDone = _data["isDone"];
        }
    }

    static fromJS(data: any): UpdateOrderStagePointInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStagePointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["pointId"] = this.pointId;
        data["isDone"] = this.isDone;
        return data;
    }
}

export interface IUpdateOrderStagePointInput {
    orderId: number;
    pointId: number;
    isDone: boolean;
}

export class UpdateOrderSubscriptionInput implements IUpdateOrderSubscriptionInput {
    contactId!: number | undefined;
    contactXref!: string | undefined;
    leadId!: number | undefined;
    orderNumber!: string | undefined;
    subscriptions!: SubscriptionInput[] | undefined;
    products!: UpdateOrderSubscriptionProductInfo[] | undefined;
    productId!: number | undefined;
    productCode!: string | undefined;
    paymentPeriodType!: RecurringPaymentFrequency | undefined;
    hasRecurringBilling!: boolean;
    skipExisting!: boolean;

    constructor(data?: IUpdateOrderSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.contactXref = _data["contactXref"];
            this.leadId = _data["leadId"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["subscriptions"])) {
                this.subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    this.subscriptions!.push(SubscriptionInput.fromJS(item));
            }
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(UpdateOrderSubscriptionProductInfo.fromJS(item));
            }
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.hasRecurringBilling = _data["hasRecurringBilling"];
            this.skipExisting = _data["skipExisting"];
        }
    }

    static fromJS(data: any): UpdateOrderSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["leadId"] = this.leadId;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["skipExisting"] = this.skipExisting;
        return data;
    }
}

export interface IUpdateOrderSubscriptionInput {
    contactId: number | undefined;
    contactXref: string | undefined;
    leadId: number | undefined;
    orderNumber: string | undefined;
    subscriptions: SubscriptionInput[] | undefined;
    products: UpdateOrderSubscriptionProductInfo[] | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    paymentPeriodType: RecurringPaymentFrequency | undefined;
    hasRecurringBilling: boolean;
    skipExisting: boolean;
}

export class UpdateOrderSubscriptionPeriodInput implements IUpdateOrderSubscriptionPeriodInput {
    subscriptionId!: number;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;

    constructor(data?: IUpdateOrderSubscriptionPeriodInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateOrderSubscriptionPeriodInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderSubscriptionPeriodInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateOrderSubscriptionPeriodInput {
    subscriptionId: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
}

export class UpdateOrderSubscriptionProductInfo implements IUpdateOrderSubscriptionProductInfo {
    productId!: number | undefined;
    productCode!: string | undefined;
    paymentPeriodType!: RecurringPaymentFrequency | undefined;
    hasRecurringBilling!: boolean;
    endDate!: moment.Moment | undefined;

    constructor(data?: IUpdateOrderSubscriptionProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.hasRecurringBilling = _data["hasRecurringBilling"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateOrderSubscriptionProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderSubscriptionProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateOrderSubscriptionProductInfo {
    productId: number | undefined;
    productCode: string | undefined;
    paymentPeriodType: RecurringPaymentFrequency | undefined;
    hasRecurringBilling: boolean;
    endDate: moment.Moment | undefined;
}

export class UpdateOrganizationInfoInput implements IUpdateOrganizationInfoInput {
    id!: number;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    affiliateCode!: string | undefined;
    departmentCode!: string | undefined;

    constructor(data?: IUpdateOrganizationInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.shortName = _data["shortName"];
            this.typeId = _data["typeId"];
            this.industry = _data["industry"];
            this.annualRevenue = _data["annualRevenue"];
            this.ein = _data["ein"];
            this.businessSicCode = _data["businessSicCode"];
            this.formedCountryId = _data["formedCountryId"];
            this.formedStateId = _data["formedStateId"];
            this.description = _data["description"];
            this.formedDate = _data["formedDate"] ? moment(_data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = _data["sizeFrom"];
            this.sizeTo = _data["sizeTo"];
            this.duns = _data["duns"];
            this.ticker = _data["ticker"];
            this.affiliateCode = _data["affiliateCode"];
            this.departmentCode = _data["departmentCode"];
        }
    }

    static fromJS(data: any): UpdateOrganizationInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["affiliateCode"] = this.affiliateCode;
        data["departmentCode"] = this.departmentCode;
        return data;
    }
}

export interface IUpdateOrganizationInfoInput {
    id: number;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    affiliateCode: string | undefined;
    departmentCode: string | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdatePartnerTypeInput implements IUpdatePartnerTypeInput {
    partnerId!: number;
    typeName!: string | undefined;

    constructor(data?: IUpdatePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partnerId = _data["partnerId"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): UpdatePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerId"] = this.partnerId;
        data["typeName"] = this.typeName;
        return data;
    }
}

export interface IUpdatePartnerTypeInput {
    partnerId: number;
    typeName: string | undefined;
}

export class UpdatePersonBANKCodeInput implements IUpdatePersonBANKCodeInput {
    id!: number;
    bankCode!: string | undefined;

    constructor(data?: IUpdatePersonBANKCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankCode = _data["bankCode"];
        }
    }

    static fromJS(data: any): UpdatePersonBANKCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonBANKCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankCode"] = this.bankCode;
        return data;
    }
}

export interface IUpdatePersonBANKCodeInput {
    id: number;
    bankCode: string | undefined;
}

export class UpdatePersonInfoInput implements IUpdatePersonInfoInput {
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    interests!: string[] | undefined;
    id!: number;
    bankCode!: string | undefined;

    constructor(data?: IUpdatePersonInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dob = _data["dob"] ? moment(_data["dob"].toString()) : <any>undefined;
            this.ssn = _data["ssn"];
            this.timeZone = _data["timeZone"];
            this.maritalStatus = _data["maritalStatus"];
            this.marriageDate = _data["marriageDate"] ? moment(_data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.isUSCitizen = _data["isUSCitizen"];
            this.citizenship = _data["citizenship"];
            this.experience = _data["experience"];
            this.profileSummary = _data["profileSummary"];
            this.preferredToD = _data["preferredToD"];
            this.drivingLicense = _data["drivingLicense"];
            this.drivingLicenseState = _data["drivingLicenseState"];
            this.isActiveMilitaryDuty = _data["isActiveMilitaryDuty"];
            if (Array.isArray(_data["interests"])) {
                this.interests = [] as any;
                for (let item of _data["interests"])
                    this.interests!.push(item);
            }
            this.id = _data["id"];
            this.bankCode = _data["bankCode"];
        }
    }

    static fromJS(data: any): UpdatePersonInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (Array.isArray(this.interests)) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["id"] = this.id;
        data["bankCode"] = this.bankCode;
        return data;
    }
}

export interface IUpdatePersonInfoInput {
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    interests: string[] | undefined;
    id: number;
    bankCode: string | undefined;
}

export class UpdatePersonNameInput implements IUpdatePersonNameInput {
    id!: number;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;

    constructor(data?: IUpdatePersonNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.namePrefix = _data["namePrefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nameSuffix = _data["nameSuffix"];
            this.nickName = _data["nickName"];
        }
    }

    static fromJS(data: any): UpdatePersonNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        return data;
    }
}

export interface IUpdatePersonNameInput {
    id: number;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
}

export class UpdatePersonNameOutput implements IUpdatePersonNameOutput {
    fullName!: string | undefined;

    constructor(data?: IUpdatePersonNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): UpdatePersonNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IUpdatePersonNameOutput {
    fullName: string | undefined;
}

export class UpdatePersonOrgRelationInput implements IUpdatePersonOrgRelationInput {
    id!: number;
    relationshipType!: string;
    jobTitle!: string | undefined;

    constructor(data?: IUpdatePersonOrgRelationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.relationshipType = _data["relationshipType"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): UpdatePersonOrgRelationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonOrgRelationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["relationshipType"] = this.relationshipType;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface IUpdatePersonOrgRelationInput {
    id: number;
    relationshipType: string;
    jobTitle: string | undefined;
}

export class UpdateProductGroupInput implements IUpdateProductGroupInput {
    code!: string;
    groupName!: string | undefined;

    constructor(data?: IUpdateProductGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): UpdateProductGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["groupName"] = this.groupName;
        return data;
    }
}

export interface IUpdateProductGroupInput {
    code: string;
    groupName: string | undefined;
}

export class UpdateProductInput implements IUpdateProductInput {
    id!: number;
    code!: string;
    name!: string;
    description!: string | undefined;
    groupId!: number | undefined;
    groupName!: string | undefined;
    type!: ProductType;
    price!: number | undefined;
    commissionableAmount!: number | undefined;
    maxCommissionRate!: number | undefined;
    maxCommissionRateTier2!: number | undefined;
    unit!: ProductMeasurementUnit | undefined;
    productServices!: ProductServiceInfo[] | undefined;
    productSubscriptionOptions!: ProductSubscriptionOptionInfo[] | undefined;

    constructor(data?: IUpdateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.type = _data["type"];
            this.price = _data["price"];
            this.commissionableAmount = _data["commissionableAmount"];
            this.maxCommissionRate = _data["maxCommissionRate"];
            this.maxCommissionRateTier2 = _data["maxCommissionRateTier2"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["productServices"])) {
                this.productServices = [] as any;
                for (let item of _data["productServices"])
                    this.productServices!.push(ProductServiceInfo.fromJS(item));
            }
            if (Array.isArray(_data["productSubscriptionOptions"])) {
                this.productSubscriptionOptions = [] as any;
                for (let item of _data["productSubscriptionOptions"])
                    this.productSubscriptionOptions!.push(ProductSubscriptionOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["type"] = this.type;
        data["price"] = this.price;
        data["commissionableAmount"] = this.commissionableAmount;
        data["maxCommissionRate"] = this.maxCommissionRate;
        data["maxCommissionRateTier2"] = this.maxCommissionRateTier2;
        data["unit"] = this.unit;
        if (Array.isArray(this.productServices)) {
            data["productServices"] = [];
            for (let item of this.productServices)
                data["productServices"].push(item.toJSON());
        }
        if (Array.isArray(this.productSubscriptionOptions)) {
            data["productSubscriptionOptions"] = [];
            for (let item of this.productSubscriptionOptions)
                data["productSubscriptionOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateProductInput {
    id: number;
    code: string;
    name: string;
    description: string | undefined;
    groupId: number | undefined;
    groupName: string | undefined;
    type: ProductType;
    price: number | undefined;
    commissionableAmount: number | undefined;
    maxCommissionRate: number | undefined;
    maxCommissionRateTier2: number | undefined;
    unit: ProductMeasurementUnit | undefined;
    productServices: ProductServiceInfo[] | undefined;
    productSubscriptionOptions: ProductSubscriptionOptionInfo[] | undefined;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    originalImage!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    useGravatarProfilePicture!: boolean;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalImage = _data["originalImage"];
            this.thumbnail = _data["thumbnail"];
            this.source = _data["source"];
            this.useGravatarProfilePicture = _data["useGravatarProfilePicture"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalImage"] = this.originalImage;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["useGravatarProfilePicture"] = this.useGravatarProfilePicture;
        return data;
    }
}

export interface IUpdateProfilePictureInput {
    originalImage: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    useGravatarProfilePicture: boolean;
}

export class UpdateResourceGroupInput implements IUpdateResourceGroupInput {
    resourceId!: number;
    groupId!: number;
    sortOrder!: number | undefined;

    constructor(data?: IUpdateResourceGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.groupId = _data["groupId"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateResourceGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["groupId"] = this.groupId;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateResourceGroupInput {
    resourceId: number;
    groupId: number;
    sortOrder: number | undefined;
}

export class UpdateResourceGroupOutput implements IUpdateResourceGroupOutput {
    sortOrder!: number;

    constructor(data?: IUpdateResourceGroupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateResourceGroupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceGroupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateResourceGroupOutput {
    sortOrder: number;
}

export class UpdateSortOrderInput implements IUpdateSortOrderInput {
    id!: number;
    sortOrder!: number;

    constructor(data?: IUpdateSortOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateSortOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSortOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateSortOrderInput {
    id: number;
    sortOrder: number;
}

export class UpdateSslBindingInput implements IUpdateSslBindingInput {
    id!: number;
    sslCertificateId!: number | undefined;
    organizationUnitId!: number | undefined;
    isActive!: boolean;

    constructor(data?: IUpdateSslBindingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sslCertificateId = _data["sslCertificateId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateSslBindingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSslBindingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sslCertificateId"] = this.sslCertificateId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateSslBindingInput {
    id: number;
    sslCertificateId: number | undefined;
    organizationUnitId: number | undefined;
    isActive: boolean;
}

export class UpdateStageChecklistPointSortOrderInput implements IUpdateStageChecklistPointSortOrderInput {
    id!: number;
    sortOrder!: number;

    constructor(data?: IUpdateStageChecklistPointSortOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateStageChecklistPointSortOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStageChecklistPointSortOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateStageChecklistPointSortOrderInput {
    id: number;
    sortOrder: number;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class UpdateTransactionsCategoryInput implements IUpdateTransactionsCategoryInput {
    transactionIds!: number[] | undefined;
    categoryId!: number | undefined;
    standardDescriptor!: string | undefined;
    descriptorAttributeTypeId!: string | undefined;
    suppressCashflowMismatch!: boolean;

    constructor(data?: IUpdateTransactionsCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppressCashflowMismatch = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transactionIds"])) {
                this.transactionIds = [] as any;
                for (let item of _data["transactionIds"])
                    this.transactionIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.standardDescriptor = _data["standardDescriptor"];
            this.descriptorAttributeTypeId = _data["descriptorAttributeTypeId"];
            this.suppressCashflowMismatch = _data["suppressCashflowMismatch"] !== undefined ? _data["suppressCashflowMismatch"] : false;
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionsCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transactionIds)) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        data["suppressCashflowMismatch"] = this.suppressCashflowMismatch;
        return data;
    }
}

export interface IUpdateTransactionsCategoryInput {
    transactionIds: number[] | undefined;
    categoryId: number | undefined;
    standardDescriptor: string | undefined;
    descriptorAttributeTypeId: string | undefined;
    suppressCashflowMismatch: boolean;
}

export class UpdateTransactionsCategoryWithFilterInput implements IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter!: StatsDetailFilterBase | undefined;
    destinationCategoryId!: number | undefined;
    standardDescriptor!: string | undefined;
    descriptorAttributeTypeId!: string | undefined;
    suppressCashflowMismatch!: boolean;

    constructor(data?: IUpdateTransactionsCategoryWithFilterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppressCashflowMismatch = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionFilter = _data["transactionFilter"] ? StatsDetailFilterBase.fromJS(_data["transactionFilter"]) : <any>undefined;
            this.destinationCategoryId = _data["destinationCategoryId"];
            this.standardDescriptor = _data["standardDescriptor"];
            this.descriptorAttributeTypeId = _data["descriptorAttributeTypeId"];
            this.suppressCashflowMismatch = _data["suppressCashflowMismatch"] !== undefined ? _data["suppressCashflowMismatch"] : false;
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryWithFilterInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionsCategoryWithFilterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionFilter"] = this.transactionFilter ? this.transactionFilter.toJSON() : <any>undefined;
        data["destinationCategoryId"] = this.destinationCategoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        data["suppressCashflowMismatch"] = this.suppressCashflowMismatch;
        return data;
    }
}

export interface IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter: StatsDetailFilterBase | undefined;
    destinationCategoryId: number | undefined;
    standardDescriptor: string | undefined;
    descriptorAttributeTypeId: string | undefined;
    suppressCashflowMismatch: boolean;
}

export class UpdateTypeInput implements IUpdateTypeInput {
    documentId!: string;
    typeId!: number | undefined;

    constructor(data?: IUpdateTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): UpdateTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["typeId"] = this.typeId;
        return data;
    }
}

export interface IUpdateTypeInput {
    documentId: string;
    typeId: number | undefined;
}

export class UpdateUserAffiliateCodeDto implements IUpdateUserAffiliateCodeDto {
    affiliateCode!: string | undefined;

    constructor(data?: IUpdateUserAffiliateCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affiliateCode = _data["affiliateCode"];
        }
    }

    static fromJS(data: any): UpdateUserAffiliateCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserAffiliateCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affiliateCode"] = this.affiliateCode;
        return data;
    }
}

export interface IUpdateUserAffiliateCodeDto {
    affiliateCode: string | undefined;
}

export class UpdateUserBANKCodeDto implements IUpdateUserBANKCodeDto {
    bankCode!: string;
    source!: string | undefined;
    bankCodeSelfAssessmentDto!: BANKCodeSelfAssessmentDto | undefined;

    constructor(data?: IUpdateUserBANKCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.source = _data["source"];
            this.bankCodeSelfAssessmentDto = _data["bankCodeSelfAssessmentDto"] ? BANKCodeSelfAssessmentDto.fromJS(_data["bankCodeSelfAssessmentDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserBANKCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserBANKCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["source"] = this.source;
        data["bankCodeSelfAssessmentDto"] = this.bankCodeSelfAssessmentDto ? this.bankCodeSelfAssessmentDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateUserBANKCodeDto {
    bankCode: string;
    source: string | undefined;
    bankCodeSelfAssessmentDto: BANKCodeSelfAssessmentDto | undefined;
}

export class UpdateUserEmailDto implements IUpdateUserEmailDto {
    id!: number;
    emailAddress!: string;

    constructor(data?: IUpdateUserEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UpdateUserEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IUpdateUserEmailDto {
    id: number;
    emailAddress: string;
}

export class UpdateUserOptionsDto implements IUpdateUserOptionsDto {
    id!: number;
    isActive!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;
    notifyUser!: boolean;

    constructor(data?: IUpdateUserOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.notifyUser = _data["notifyUser"];
        }
    }

    static fromJS(data: any): UpdateUserOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["notifyUser"] = this.notifyUser;
        return data;
    }
}

export interface IUpdateUserOptionsDto {
    id: number;
    isActive: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    notifyUser: boolean;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class UpdateUserPhoneDto implements IUpdateUserPhoneDto {
    id!: number;
    phoneNumber!: string;

    constructor(data?: IUpdateUserPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateUserPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUpdateUserPhoneDto {
    id: number;
    phoneNumber: string;
}

export class UpdateUserPictureInput implements IUpdateUserPictureInput {
    userId!: number;
    image!: string | undefined;
    imageThumbnail!: string | undefined;
    source!: string | undefined;

    constructor(data?: IUpdateUserPictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.image = _data["image"];
            this.imageThumbnail = _data["imageThumbnail"];
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): UpdateUserPictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        data["source"] = this.source;
        return data;
    }
}

export interface IUpdateUserPictureInput {
    userId: number;
    image: string | undefined;
    imageThumbnail: string | undefined;
    source: string | undefined;
}

export class UpdateUserRoleInput implements IUpdateUserRoleInput {
    id!: number;
    roleName!: string;

    constructor(data?: IUpdateUserRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UpdateUserRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUpdateUserRoleInput {
    id: number;
    roleName: string;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class UploadDocumentInput implements IUploadDocumentInput {
    typeId!: number | undefined;
    contactId!: number;
    fileName!: string;
    size!: number;
    file!: string;

    constructor(data?: IUploadDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.contactId = _data["contactId"];
            this.fileName = _data["fileName"];
            this.size = _data["size"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): UploadDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["contactId"] = this.contactId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["file"] = this.file;
        return data;
    }
}

export interface IUploadDocumentInput {
    typeId: number | undefined;
    contactId: number;
    fileName: string;
    size: number;
    file: string;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    id!: number;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    id: number;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    group!: UserGroup | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["group"] = this.group;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    group: UserGroup | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class UserEmailSettings implements IUserEmailSettings {
    isUserSmtpEnabled!: boolean;
    signatureHtml!: string | undefined;
    from!: EmailFromSettings | undefined;
    smtp!: EmailSmtpSettings | undefined;

    constructor(data?: IUserEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserSmtpEnabled = _data["isUserSmtpEnabled"];
            this.signatureHtml = _data["signatureHtml"];
            this.from = _data["from"] ? EmailFromSettings.fromJS(_data["from"]) : <any>undefined;
            this.smtp = _data["smtp"] ? EmailSmtpSettings.fromJS(_data["smtp"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserSmtpEnabled"] = this.isUserSmtpEnabled;
        data["signatureHtml"] = this.signatureHtml;
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["smtp"] = this.smtp ? this.smtp.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserEmailSettings {
    isUserSmtpEnabled: boolean;
    signatureHtml: string | undefined;
    from: EmailFromSettings | undefined;
    smtp: EmailSmtpSettings | undefined;
}

export enum UserGroup {
    Employee = "Employee",
    Member = "Member",
    Partner = "Partner",
    Investor = "Investor",
    Vendor = "Vendor",
    Other = "Other",
}

export class UserInfo implements IUserInfo {
    userName!: string | undefined;
    password!: string | undefined;
    loginUrl!: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.loginUrl = _data["loginUrl"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["loginUrl"] = this.loginUrl;
        return data;
    }
}

export interface IUserInfo {
    userName: string | undefined;
    password: string | undefined;
    loginUrl: string | undefined;
}

export class UserInfoDto implements IUserInfoDto {
    id!: number;
    name!: string | undefined;
    isActive!: boolean;
    photoPublicId!: string | undefined;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.photoPublicId = _data["photoPublicId"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["photoPublicId"] = this.photoPublicId;
        return data;
    }
}

export interface IUserInfoDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
    photoPublicId: string | undefined;
}

export class UserKeyInfo implements IUserKeyInfo {
    id!: number;
    userName!: string | undefined;
    fullName!: string | undefined;

    constructor(data?: IUserKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): UserKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IUserKeyInfo {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    userKey!: string | undefined;
    phoneNumber!: string | undefined;
    profileThumbnailId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    lastLoginTime!: moment.Moment | undefined;
    isActive!: boolean;
    creationTime!: moment.Moment;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.userKey = _data["userKey"];
            this.phoneNumber = _data["phoneNumber"];
            this.profileThumbnailId = _data["profileThumbnailId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["userKey"] = this.userKey;
        data["phoneNumber"] = this.phoneNumber;
        data["profileThumbnailId"] = this.profileThumbnailId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    userKey: string | undefined;
    phoneNumber: string | undefined;
    profileThumbnailId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    profileThumbnailId!: string | undefined;
    bankCode!: string | undefined;
    affiliateCode!: string | undefined;
    affiliateRate!: number | undefined;
    groups!: UserGroup[] | undefined;
    contactId!: number;
    creationTime!: moment.Moment;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.profileThumbnailId = _data["profileThumbnailId"];
            this.bankCode = _data["bankCode"];
            this.affiliateCode = _data["affiliateCode"];
            this.affiliateRate = _data["affiliateRate"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.contactId = _data["contactId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["profileThumbnailId"] = this.profileThumbnailId;
        data["bankCode"] = this.bankCode;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateRate"] = this.affiliateRate;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["contactId"] = this.contactId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    profileThumbnailId: string | undefined;
    bankCode: string | undefined;
    affiliateCode: string | undefined;
    affiliateRate: number | undefined;
    groups: UserGroup[] | undefined;
    contactId: number;
    creationTime: moment.Moment;
    id: number;
}

export class UserNotificationDto implements IUserNotificationDto {
    id!: string;
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotificationDto | undefined;

    constructor(data?: IUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotificationDto.fromJS(_data["notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserNotificationDto {
    id: string;
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotificationDto | undefined;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export enum UtilityType {
    NA = 0,
    Electricity = 1,
    Gas = 2,
    Waste = 4,
    Water = 8,
}

export class UTMParameterInfo implements IUTMParameterInfo {
    source!: string;
    medium!: string | undefined;
    campaign!: string | undefined;
    term!: string | undefined;
    content!: string | undefined;
    keyword!: string | undefined;
    adGroup!: string | undefined;
    name!: string | undefined;

    constructor(data?: IUTMParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"];
            this.medium = _data["medium"];
            this.campaign = _data["campaign"];
            this.term = _data["term"];
            this.content = _data["content"];
            this.keyword = _data["keyword"];
            this.adGroup = _data["adGroup"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UTMParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UTMParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["medium"] = this.medium;
        data["campaign"] = this.campaign;
        data["term"] = this.term;
        data["content"] = this.content;
        data["keyword"] = this.keyword;
        data["adGroup"] = this.adGroup;
        data["name"] = this.name;
        return data;
    }
}

export interface IUTMParameterInfo {
    source: string;
    medium: string | undefined;
    campaign: string | undefined;
    term: string | undefined;
    content: string | undefined;
    keyword: string | undefined;
    adGroup: string | undefined;
    name: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class VoidBankCardPaymentInput implements IVoidBankCardPaymentInput {
    invoiceId!: number | undefined;
    invoiceNumber!: string | undefined;
    transactionId!: number | undefined;
    gatewayName!: string | undefined;
    gatewayTransactionId!: string | undefined;

    constructor(data?: IVoidBankCardPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.transactionId = _data["transactionId"];
            this.gatewayName = _data["gatewayName"];
            this.gatewayTransactionId = _data["gatewayTransactionId"];
        }
    }

    static fromJS(data: any): VoidBankCardPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new VoidBankCardPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["transactionId"] = this.transactionId;
        data["gatewayName"] = this.gatewayName;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        return data;
    }
}

export interface IVoidBankCardPaymentInput {
    invoiceId: number | undefined;
    invoiceNumber: string | undefined;
    transactionId: number | undefined;
    gatewayName: string | undefined;
    gatewayTransactionId: string | undefined;
}

export enum WeekDay {
    Sunday = "Sunday",
    Monday = "Monday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday",
    Thursday = "Thursday",
    Friday = "Friday",
    Saturday = "Saturday",
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class WopiRequestOutcoming implements IWopiRequestOutcoming {
    accessToken!: string | undefined;
    accessTokenTtl!: number;
    wopiUrlsrc!: string | undefined;
    validityPeriodSeconds!: number;

    constructor(data?: IWopiRequestOutcoming) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenTtl = _data["accessTokenTtl"];
            this.wopiUrlsrc = _data["wopiUrlsrc"];
            this.validityPeriodSeconds = _data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): WopiRequestOutcoming {
        data = typeof data === 'object' ? data : {};
        let result = new WopiRequestOutcoming();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenTtl"] = this.accessTokenTtl;
        data["wopiUrlsrc"] = this.wopiUrlsrc;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data;
    }
}

export interface IWopiRequestOutcoming {
    accessToken: string | undefined;
    accessTokenTtl: number;
    wopiUrlsrc: string | undefined;
    validityPeriodSeconds: number;
}

export class WorkflowActionDto implements IWorkflowActionDto {
    name!: string | undefined;
    configurationType!: string | undefined;

    constructor(data?: IWorkflowActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.configurationType = _data["configurationType"];
        }
    }

    static fromJS(data: any): WorkflowActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["configurationType"] = this.configurationType;
        return data;
    }
}

export interface IWorkflowActionDto {
    name: string | undefined;
    configurationType: string | undefined;
}

export class WorkflowRuleDto implements IWorkflowRuleDto {
    id!: number;
    triggerIdentifier!: string | undefined;
    actionIdentifier!: string | undefined;
    configurationType!: string | undefined;
    configurationOptions!: string | undefined;
    isActive!: boolean;

    constructor(data?: IWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.triggerIdentifier = _data["triggerIdentifier"];
            this.actionIdentifier = _data["actionIdentifier"];
            this.configurationType = _data["configurationType"];
            this.configurationOptions = _data["configurationOptions"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): WorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationType"] = this.configurationType;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IWorkflowRuleDto {
    id: number;
    triggerIdentifier: string | undefined;
    actionIdentifier: string | undefined;
    configurationType: string | undefined;
    configurationOptions: string | undefined;
    isActive: boolean;
}

export class WorkflowTriggerDto implements IWorkflowTriggerDto {
    name!: string | undefined;
    supportedActions!: WorkflowActionDto[] | undefined;

    constructor(data?: IWorkflowTriggerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["supportedActions"])) {
                this.supportedActions = [] as any;
                for (let item of _data["supportedActions"])
                    this.supportedActions!.push(WorkflowActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTriggerDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTriggerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.supportedActions)) {
            data["supportedActions"] = [];
            for (let item of this.supportedActions)
                data["supportedActions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTriggerDto {
    name: string | undefined;
    supportedActions: WorkflowActionDto[] | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
    clientId!: string | undefined;
    tenant!: string | undefined;
    metaDataAddress!: string | undefined;
    wtrealm!: string | undefined;
    authority!: string | undefined;

    constructor(data?: IWsFederationExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.tenant = _data["tenant"];
            this.metaDataAddress = _data["metaDataAddress"];
            this.wtrealm = _data["wtrealm"];
            this.authority = _data["authority"];
        }
    }

    static fromJS(data: any): WsFederationExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new WsFederationExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["tenant"] = this.tenant;
        data["metaDataAddress"] = this.metaDataAddress;
        data["wtrealm"] = this.wtrealm;
        data["authority"] = this.authority;
        return data;
    }
}

export interface IWsFederationExternalLoginProviderSettings {
    clientId: string | undefined;
    tenant: string | undefined;
    metaDataAddress: string | undefined;
    wtrealm: string | undefined;
    authority: string | undefined;
}

export enum YardPatioEnum {
    Yes = "Yes",
    No = "No",
    Fenced = "Fenced",
}

export class YTelSettingsEditDto implements IYTelSettingsEditDto {
    isEnabled!: boolean;
    authToken!: string | undefined;
    from!: string | undefined;
    inboundSmsKey!: string | undefined;

    constructor(data?: IYTelSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.authToken = _data["authToken"];
            this.from = _data["from"];
            this.inboundSmsKey = _data["inboundSmsKey"];
        }
    }

    static fromJS(data: any): YTelSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YTelSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["authToken"] = this.authToken;
        data["from"] = this.from;
        data["inboundSmsKey"] = this.inboundSmsKey;
        return data;
    }
}

export interface IYTelSettingsEditDto {
    isEnabled: boolean;
    authToken: string | undefined;
    from: string | undefined;
    inboundSmsKey: string | undefined;
}

export class Flags implements IFlags {
    choice!: boolean;
    best!: boolean;
    travelAndAirlineMiles!: boolean;
    dinigRewards!: boolean;
    gasRewards!: boolean;
    cashBackRewards!: boolean;
    instantDecision!: boolean;
    instantResponse!: boolean;
    noCreditCheck!: boolean;
    guaranteedApproval!: boolean;
    rebuildCredit!: boolean;
    chipCard!: boolean;
    applePay!: boolean;
    groceryRewards!: boolean;
    entertainmentRewards!: boolean;
    hotelRewards!: boolean;
    hasNoRewards!: boolean;
    zeroPercentageOnPurchases!: boolean;
    zeroPercentageInterestTransfers!: boolean;
    special!: boolean;
    newest!: boolean;

    constructor(data?: IFlags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.choice = _data["Choice"];
            this.best = _data["Best"];
            this.travelAndAirlineMiles = _data["TravelAndAirlineMiles"];
            this.dinigRewards = _data["DinigRewards"];
            this.gasRewards = _data["GasRewards"];
            this.cashBackRewards = _data["CashBackRewards"];
            this.instantDecision = _data["InstantDecision"];
            this.instantResponse = _data["InstantResponse"];
            this.noCreditCheck = _data["NoCreditCheck"];
            this.guaranteedApproval = _data["GuaranteedApproval"];
            this.rebuildCredit = _data["RebuildCredit"];
            this.chipCard = _data["ChipCard"];
            this.applePay = _data["ApplePay"];
            this.groceryRewards = _data["GroceryRewards"];
            this.entertainmentRewards = _data["EntertainmentRewards"];
            this.hotelRewards = _data["HotelRewards"];
            this.hasNoRewards = _data["HasNoRewards"];
            this.zeroPercentageOnPurchases = _data["ZeroPercentageOnPurchases"];
            this.zeroPercentageInterestTransfers = _data["ZeroPercentageInterestTransfers"];
            this.special = _data["Special"];
            this.newest = _data["Newest"];
        }
    }

    static fromJS(data: any): Flags {
        data = typeof data === 'object' ? data : {};
        let result = new Flags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Choice"] = this.choice;
        data["Best"] = this.best;
        data["TravelAndAirlineMiles"] = this.travelAndAirlineMiles;
        data["DinigRewards"] = this.dinigRewards;
        data["GasRewards"] = this.gasRewards;
        data["CashBackRewards"] = this.cashBackRewards;
        data["InstantDecision"] = this.instantDecision;
        data["InstantResponse"] = this.instantResponse;
        data["NoCreditCheck"] = this.noCreditCheck;
        data["GuaranteedApproval"] = this.guaranteedApproval;
        data["RebuildCredit"] = this.rebuildCredit;
        data["ChipCard"] = this.chipCard;
        data["ApplePay"] = this.applePay;
        data["GroceryRewards"] = this.groceryRewards;
        data["EntertainmentRewards"] = this.entertainmentRewards;
        data["HotelRewards"] = this.hotelRewards;
        data["HasNoRewards"] = this.hasNoRewards;
        data["ZeroPercentageOnPurchases"] = this.zeroPercentageOnPurchases;
        data["ZeroPercentageInterestTransfers"] = this.zeroPercentageInterestTransfers;
        data["Special"] = this.special;
        data["Newest"] = this.newest;
        return data;
    }
}

export interface IFlags {
    choice: boolean;
    best: boolean;
    travelAndAirlineMiles: boolean;
    dinigRewards: boolean;
    gasRewards: boolean;
    cashBackRewards: boolean;
    instantDecision: boolean;
    instantResponse: boolean;
    noCreditCheck: boolean;
    guaranteedApproval: boolean;
    rebuildCredit: boolean;
    chipCard: boolean;
    applePay: boolean;
    groceryRewards: boolean;
    entertainmentRewards: boolean;
    hotelRewards: boolean;
    hasNoRewards: boolean;
    zeroPercentageOnPurchases: boolean;
    zeroPercentageInterestTransfers: boolean;
    special: boolean;
    newest: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}